# -*- coding: utf-8 -*-
"""Day-ahead redispatch optimization of solar-PV and wind power integrated 36-zone Great Britain energy system.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Djyj5hlkecdkKa2OHIalIUBzsNjgzKGV

#**hybrid optimization of future solar-PV and wind power integrated Great Britain energy system**


###**Mount the Google Drive**
"""

# Mount the Google Drive
from google.colab import drive
print(drive.mount('/content/gdrive'))

# Check if GPU is connected and display its Details
gpu_info = !nvidia-smi
gpu_info = '\n'.join(gpu_info)
if gpu_info.find('failed') >= 0:
  print('Not connected to a GPU')
else:
  print(gpu_info)

"""###**Install and Import Needed Packages**"""

import shutil
import os
import sys
if not shutil.which("pyomo"):
    #!pip install -q pyomo
    assert(shutil.which("pyomo"))
import condacolab
condacolab.install()
import powerplantmatching as pm

import sys
print("To install it, either uncomment the cell bellow, or type, in a command prompt:\n{}".format(("\t{} -m pip install -m pip install -U git+https://github.com/rte-france/grid2viz --user".format(sys.executable))))

import sys
if "google.colab" in sys.modules:
    #!wget "https://raw.githubusercontent.com/ndcbe/CBE60499/main/notebooks/helper.py"
    import helper
    helper.install_idaes()
    helper.install_ipopt()

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from IPython.display import display, HTML
import shutil
import sys
import os.path
from matplotlib.lines import Line2D
import copy
import pyomo.environ as pyo
import pyomo.gdp as gdp
if "google.colab" in sys.modules:
    #!wget "https://raw.githubusercontent.com/ndcbe/CBE60499/main/notebooks/helper.py"
    import helper
    helper.install_idaes()
    helper.install_ipopt()
import torch
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F
import pickle
import torch
import os
import numpy as np
import numpy.random as rd
import pandas as pd
import pyomo.environ as pyo
import pyomo.kernel as pmo
#from omlt import OmltBlock
from gurobipy import *
#from omlt.neuralnet import NetworkDefinition, FullSpaceNNFormulation,ReluBigMFormulation
#from omlt.io.onnx import write_onnx_model_with_bounds,load_onnx_neural_network_with_bounds
import tempfile
import torch.onnx
import torch.nn as nn
from copy import deepcopy
import datetime
import pydantic
import requests
from pathlib import Path
from collections import defaultdict
import powerplantmatching as pm
import cartopy.crs as ccrs
import hvplot
#import hvplot.pandas  # noqa
#import hvplot.xarray
import holoviews as hv
#import geoviews as gv
#import geoviews.tile_sources as gvts
from pyomo.core.base.config import default_pyomo_config
from pyomo.core.base.piecewise import Bound
from pyomo.environ import *
from pyomo.opt import SolverFactory
import gurobipy as gp
from gurobipy import GRB
from gurobipy import *
from pyomo.environ import ConcreteModel, Var, Binary, NonNegativeReals
import pickle
import seaborn as sns
from re import escape
from datetime import datetime, timedelta
import math
import csv
import pandas as pd
from elexon import ElexonRawClient
import warnings
from collections import deque
import pdb
#from ElexonDataPortal import api
import datetime
import pydantic
import requests
from pathlib import Path
from collections import defaultdict
from holoviews import opts
from holoviews.plotting.util import process_cmap
from xarray import align
import pypsa
from powerplantmatching.core import get_config, get_obj_if_Acc
from powerplantmatching.utils import lookup, set_uncommon_fueltypes_to_other, to_list_if_other
from shapely.wkt import loads
from scipy.spatial import cKDTree as KDTree
import folium
from folium.plugins import Draw, MousePosition, MiniMap, LocateControl
import geopandas as gpd
import time
from geopy.distance import geodesic
import warnings
from shapely.errors import ShapelyDeprecationWarning
warnings.filterwarnings("ignore", category=ShapelyDeprecationWarning)
from io import StringIO
from xarray import DataArray
from pypsa.optimization.common import reindex
from pypsa.descriptors import get_switchable_as_dense as get_as_dense
from pypsa.descriptors import nominal_attrs
from pypsa.descriptors import (
    additional_linkports,
    expand_series,
    get_activity_mask,
    get_bounds_pu,
)
from linopy.expressions import LinearExpression, merge
# Pandapower
import pandapower as pp
import pandapower.plotting as plotting
import pandapower.networks
import pandapower.grid_equivalents
import pandapower.plotting as plot
try:
    import seaborn
    colors = seaborn.color_palette()
except:
    colors = ["b", "g", "r", "c", "y"]
# %matplotlib inline
res = None
try:
    from jyquickhelper import add_notebook_menu
    res = add_notebook_menu()
except ModuleNotFoundError:
    print("Impossible to automatically add a menu / table of content to this notebook.\nYou can download \"jyquickhelper\" package with: \n\"pip install jyquickhelper\"")
res
import time
import shapefile as shp
#from torchmetrics import Accuracy
import geopandas as gpd
import contextily as cx
#from ray.tune import CLIReporter
#from ray.tune.schedulers import ASHAScheduler
#import pvlib
#from pvlib.tools import cosd, sind
#from pvlib.location import Location
from siphon.catalog import TDSCatalog
from siphon.ncss import NCSS
from mpl_toolkits.basemap import Basemap
from captum.attr import Saliency, IntegratedGradients
import matplotlib as mpl
import shapefile as sf
import wget
import os
import tarfile
import pickle
import glob
from shapely.geometry import Point, Polygon
from __future__ import division
from __future__ import print_function
import os
import sys
from time import time
sys.path.append(
    os.path.abspath(os.path.join(os.path.dirname("__file__"), '..')))
import numpy as np
from numpy import percentile
import matplotlib.pyplot as plt
import matplotlib.font_manager
from sklearn.metrics import roc_auc_score
from os import makedirs
import typing
import random
import pdb
import pandas as pd
from time import time
import json
import re
import functools
import math
import os
import datetime
from datetime import datetime
from datetime import date
import urllib.request
import inspect
import logging
import urllib
import zipfile
import copy
import tqdm
from tqdm.notebook import tqdm
import os.path as osp
from math import ceil
import IPython
import IPython.display
import requests
from collections import OrderedDict
from time import time
import csv
# Helper function for visualization.
# %matplotlib inline
import matplotlib.pyplot as plt
# %matplotlib inline
from matplotlib import colors
import matplotlib.lines as mlines
from matplotlib import pyplot
import matplotlib as mpl
from matplotlib.ticker import MaxNLocator
import seaborn as sns
sns.set()
sns.set_style('whitegrid')
from matplotlib.pyplot import figure
import networkx as nx
import plotly.graph_objects as go
import io
from sklearn.cluster import KMeans
from sklearn.metrics.cluster import (v_measure_score, homogeneity_score, completeness_score)
from sklearn.metrics import roc_auc_score
from sklearn.decomposition import PCA
from sklearn.model_selection import cross_val_score
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.model_selection import GridSearchCV
from typing import Optional, List, Union
from collections import defaultdict
from itertools import repeat
from collections import abc as container_abcs
import matplotlib as mpl
import pytz
import mpl_toolkits
mpl_toolkits.__path__.append('/usr/lib/python3.7/dist-packages/mpl_toolkits/')
from typing import Collection, Optional, Union
import folium
import pylab as plt
from ipywidgets.widgets import HTML
from tqdm import tqdm
import community as louvain
import torch
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F
from torch.nn import Parameter
from torch.utils.tensorboard import SummaryWriter
from torch.nn import Sequential, Linear, ReLU
from torch.nn import Parameter, Module, Sigmoid
from torch.nn import Parameter as Param
from torch import Tensor
from IPython.display import Javascript
from torch.nn import Linear
from shutil import copyfile
from torch.utils.tensorboard import SummaryWriter
import folium
from tqdm import tqdm
import time
from time import time
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from torch.optim.lr_scheduler import StepLR
from torch.optim.lr_scheduler import ExponentialLR
from torch.optim.lr_scheduler import ReduceLROnPlateau
from torch.optim.lr_scheduler import OneCycleLR
from torch.optim.lr_scheduler import CyclicLR
from torch.optim.lr_scheduler import LambdaLR
from torch.optim.lr_scheduler import MultiplicativeLR
from torch.optim.lr_scheduler import MultiStepLR
from torch.optim.lr_scheduler import CosineAnnealingLR
from torch.optim.lr_scheduler import CosineAnnealingWarmRestarts
from sklearn.metrics import accuracy_score
from torch.optim import SGD, RMSprop, Adam
from torch.utils.data import (Dataset, TensorDataset,
                             DataLoader, Subset)
from scipy.spatial.distance import squareform, pdist, cdist
import subprocess
import matplotlib.dates as mdates
# Helper function for visualization.
# %matplotlib inline
import matplotlib.pyplot as plt
# %matplotlib inline
from matplotlib import colors
import matplotlib.lines as mlines
from matplotlib import pyplot
import matplotlib as mpl
from matplotlib.ticker import MaxNLocator
from matplotlib.pyplot import figure
from matplotlib import cm
from math import sin, cos, pi
import os.path as osp
import networkx as nx
from scipy.stats import gaussian_kde
from matplotlib.font_manager import FontProperties
from matplotlib.path import Path
from matplotlib.textpath import TextToPath
import warnings
import matplotlib.cbook
warnings.filterwarnings("ignore", category=matplotlib.cbook.mplDeprecation)
import seaborn as sns
import pandas as pd
from shapely.geometry import Point
import plotly.graph_objects as go
from __future__ import division
from __future__ import print_function
from numpy import percentile
import matplotlib.font_manager
#import tensorflow
from sklearn.neighbors import KernelDensity
from numpy import where, random, array, quantile
from sklearn.preprocessing import scale
from sklearn.metrics import precision_recall_curve
from sklearn.metrics import accuracy_score
from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report
import matplotlib.pyplot as plt
from sklearn import metrics
from sklearn import preprocessing
from sklearn.feature_selection import VarianceThreshold
from scipy.linalg import toeplitz
from pandas_datareader.data import DataReader
import pandas_datareader as pdr
from statsmodels.compat import lzip
import seaborn
from scipy import stats
import pylab
import seaborn as sns
from io import StringIO
from matplotlib.patches import Ellipse
from IPython.display import Image
import requests
from io import BytesIO
from zipfile import ZipFile
from io import BytesIO
from zipfile import ZipFile
from statsmodels.tsa.forecasting.theta import ThetaModel
from statsmodels.multivariate.pca import PCA
from sklearn.metrics import r2_score
from sklearn.model_selection import KFold
from sklearn.metrics import mean_squared_error
from scipy.signal import medfilt, wiener, savgol_filter
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.decomposition import PCA
from sklearn.feature_selection import RFE
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import TimeSeriesSplit
from sklearn.neighbors import KernelDensity
from numpy import where, random, array, quantile
from sklearn.model_selection import RandomizedSearchCV, GridSearchCV, train_test_split, LeaveOneOut
from scipy.interpolate import interp1d
import pywt
from scipy.spatial.distance import euclidean
from torch.utils.data import Dataset
import argparse
import yaml
import numpy as np
from easydict import EasyDict as edict
import torch
import torch.nn.functional as F
import random
from torch.utils.data import DataLoader
from logging import getLogger
from tqdm import tqdm
import scipy.sparse as sp
import torch
import torch.nn.functional as F
import torch.nn as nn
from sklearn.feature_selection import SelectKBest, mutual_info_regression
from sklearn.impute import KNNImputer
from logging import getLogger
from IPython.display import clear_output
from matplotlib.colors import ListedColormap
from mpl_toolkits.axes_grid1 import make_axes_locatable
from scipy import special
from sklearn.metrics import (brier_score_loss, precision_score, recall_score, f1_score)
import matplotlib.ticker as mticker
from torch.utils.data import Dataset, DataLoader
from torch.autograd import Variable
from torch.optim.lr_scheduler import ExponentialLR
from argparse import Namespace
from functools import partial
from scipy import stats, interpolate
from __future__ import division
from torch.nn import init
import numbers
from functools import partial
import torchvision
import torchvision.transforms as transforms
#from ray import tune
#from ray.air import Checkpoint, session
#from ray.tune.schedulers import ASHAScheduler
#import optuna
#from optuna.trial import TrialState
from torchvision import datasets
from torchvision import transforms
from filelock import FileLock
from torchvision import transforms
#from ray import air, tune
#from ray.air.config import RunConfig, ScalingConfig, CheckpointConfig
#from ray.tune.schedulers import ASHAScheduler, PopulationBasedTraining
from scipy.stats import multivariate_normal
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import MinMaxScaler
from scipy.stats.mstats import winsorize
from scipy.stats import pearsonr
import hyperopt
from hyperopt import fmin, tpe, hp, STATUS_OK, Trials
from copy import deepcopy
from typing import Dict, Union, Any
from hyperopt.pyll.base import scope
from hyperopt import SparkTrials
from hyperopt import space_eval
from sklearn.isotonic import IsotonicRegression
from sklearn.preprocessing import MinMaxScaler
from scipy.optimize import minimize_scalar
from argparse import Namespace
from scipy.ndimage import gaussian_filter1d
from scipy.stats import norm
from torch.optim.swa_utils import AveragedModel, SWALR
# PV Outputs
from datetime import date
import matplotlib.dates as mdates
import tables
import warnings
from datetime import date, datetime, timedelta
from io import StringIO
from typing import Dict, Iterable, List, Optional, Union
from urllib.parse import urljoin
import logging
import yaml
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
# %matplotlib inline
from tqdm.autonotebook import tqdm
from pathlib import Path
import matplotlib.ticker as ticker
import matplotlib.patches as mpatches
import matplotlib.dates as mdates

import os
import yaml
import urllib.request
from rq import get_current_job
import json, os, hashlib, yaml
from atlite.gis import spdiag, compute_indicatormatrix
import xarray as xr
import scipy as sp
from shapely.geometry import box, Point, Polygon, MultiPolygon
import solve
import hashlib, json
import pandapower as pp
import pandapower.networks as pn
from pandapower.plotting.plotly import simple_plotly, vlevel_plotly, pf_res_plotly
from pandapower import runpp
import pandapower.plotting as plot
from adjustText import adjust_text
import logging
import subprocess
import country_converter as coco
import yaml
import shapely.prepared
import shapely.wkt
from scipy.sparse import csgraph
from shapely.geometry import LineString, Point
from shapely.ops import unary_union
import snakemake as sm
from snakemake.script import Snakemake
import hashlib
from tqdm.auto import tqdm
import urllib3
import itertools
import multiprocessing as mp
from collections import namedtuple
import struct
import zlib
from itertools import accumulate
import hvplot.pandas

from six import iteritems
from itertools import product
from vresutils import plot as vplot
from snakemake.rules import expand
from itertools import product, chain
from six.moves import map, zip
from six import itervalues, iterkeys
from collections import OrderedDict as odict
from matplotlib.patches import Circle, Ellipse
from matplotlib.legend_handler import HandlerPatch
to_rgba = mpl.colors.colorConverter.to_rgba

import atlite
import cartopy.crs as ccrs
from rasterio.plot import show
from atlite.gis import shape_availability, ExclusionContainer
import xarray as xr
import geopandas as gpd
import geoviews as gv
import holoviews as hv
from rasterio.plot import show
from atlite.gis import shape_availability, ExclusionContainer
import scipy.sparse as sp
import pgeocode
from collections import OrderedDict
# %matplotlib inline
import cartopy.io.shapereader as shpreader
from cartopy.crs import PlateCarree as plate
from matplotlib.gridspec import GridSpec
from pandas.plotting import register_matplotlib_converters
from pyproj import Proj, transform
import geoviews.tile_sources as gvts
'''from grid2op.Chronics import ChangeNothing
from chronix2grid.GeneratorBackend import GeneratorBackend
import chronix2grid.generation.generation_utils as gu
from chronix2grid.kpi.Generator_parameter_checker import EnergyMix_AprioriChecker
from chronix2grid.kpi.Generator_parameter_checker import Ramps_Pmax_Pmin_APrioriCheckers
from chronix2grid.kpi.Generator_parameter_checker import Aposteriori_renewableCapacityFactor_Checkers
import chronix2grid.constants as cst
from chronix2grid.generation.dispatch.PypsaDispatchBackend import PypsaDispatcher
import chronix2grid.kpi.main as kpis
from chronix2grid.main import create_directory_tree
from chronix2grid import default_backend
import gymnasium as gym
from gymnasium import Env
import gym
from gym import spaces'''
from pypsa.plot import add_legend_circles, add_legend_lines, add_legend_patches
from shapely.prepared import prep
from shapely.validation import make_valid
from itertools import product
import scipy.sparse as sparse
from SALib.sample import saltelli
from SALib.analyze import sobol

from pandas import json_normalize  # convert json into dataframe
import shapely, shapely.prepared
from shapely.geometry import Point, LineString
from shapely.wkt import loads
from pyproj import Geod
import networkx as nx
import cartopy.crs as ccrs
from cartopy.io.img_tiles import OSM
import cartopy.feature as cfeature
from shapely import wkt
import re
from geopy.distance import geodesic as GD
from pypsa.statistics import get_bus_and_carrier
from snakemake.utils import update_config
from entsoe import EntsoePandasClient
from entsoe.exceptions import NoMatchingDataError

USE_CUDA = torch.cuda.is_available()
DEVICE = torch.device('cuda:0')
print("CUDA:", USE_CUDA, DEVICE)
# Get gpu if you can
device = 'cuda' if torch.cuda.is_available() else 'cpu'
print(f"Using {device}")

"""**Create the Plotting Function**"""

#!sudo apt install cm-super dvipng texlive-latex-extra texlive-latex-recommended
import matplotlib.pyplot as plt
import matplotlib
matplotlib.rc('text', usetex=True)
pd.options.display.notebook_repr_html=False

"""#**Optimization of future solar-PV and wind power integrated Great Britain energy system considering uncertainty and different spatial resolutions**

We use the ‚ÄúPyPSA-Earth" - A New Global Open Energy System Optimization Model by Parzen et al., 2022 to model the future solar-PV and wind power integrated Great Britain energy system.

To find cost-effective future GB highly penetrated solar-PV and wind energy system, we modelled the system as a large-scale optimization problem with the objective to minimize the annualized investment and system costs simultatneously. We focus on analysing the different GB FES and cost assumptions up to 2050, and different spatial resoultion considering uncertainties of technology cost assumptions in order to determine the cost-effective future energy system while meeting the set CO2 emission reduction targets.

This is important for informed decision-making while operating the energy system or during expansion planning feasibility studies.

To achieve this, we obtained the data needed to formulate this optimization problem, which include:

1. Existing and planned transmission network data - AC lines, substations, and HVDC links
2. Coventional power plants database
3. Total demand time series
4. Variable renewable generator availability time series
5. Geographical potential data for the expansion of solar and wind generation

**Modelling the Uncertainty**

PyPSA-Earth is deterministic which means that a set of inputs give a set of outputs.

Parameter sweeps can help to explore the uncertainty of the outputs cause by parameter changes.

Many are familiar with the classical "sensitivity analysis" that can be applied by varying the input of only one feature, while exploring its outputs changes. Here implemented is a "global sensitivity analysis" that can help to explore the multi-dimensional uncertainty space when more than one feature are changed at the same time.

**Consideration of uncertain load, solar and wind generations inflows**

We reformulate the deterministic model as stochastic ones, using different MC Sampling methods/strategy such as - pydoe2 (Creates Latin Hypercube Sample (LHS) - Randomized designs implementation from PyDOE2), chaospy (Creates Latin Hypercube Sample (LHS)implementation from chaospy), and scipy (Creates Latin Hypercube Sample (LHS) implementation from SciPy) to help to explore the multi-dimensional uncertainty space when more than one feature are changed at the same time. Supported distributions include uniform, normal, lognormal, triangle, beta, and gamma.

With these new stochastic models we can compute what is the value of using a stochastic model instead of a deterministic one.

We define the Expected Cost of Ignoring Uncertainty (ECIU). The ECIU quantifies how much worse are, in expectation, deterministic solutions compared to the optimal stochastic one.

When comparing the two approaches (ignoring uncertainty versus modeling uncertainty explicitly) the natural question to ask is how much difference it really makes to the quality of the decisions reached?

The ECIU is the additional expected cost of assuming that future is certain. The ECIU measures the value of using a stochastic model (or the expected costs of ignoring uncertainty when using a deterministic model).

ùê∏ùê∏ùëâ is the expected costs of the (na√Øve) solution of expected value problem, while ùëÜùëÜ is the stochastic solution. Therefore,
                                  ùë¨ùë™ùë∞ùëº = ùë¨ùë¨ùëΩ ‚àí ùë∫ùë∫

Here, we compute the cost if the system planner needs to make an investment decision under uncertainty and without considering uncertainty.

#**Modelling Workflow Structure**

1. **Download and filter data:**
First raw input data such as OpenStreetMap data, specific potential of renewable sources, population, GDP, etc, are downloaded, filtered to remove non-valid data, and normalized since the data are gathered from multiple sources.
retrieve_databundle_light enables a simplified approach to download the main

*   ***retrieve_databundle_light rule*** enables a simplified approach to download the main databundle of raw data. These include common GIS datasets like EEZ shapes, Copernicus Landcover, Hydrobasins and also electricity specific summary statistics like historic per country yearly totals of hydro generation, GDP and POP on NUTS3 levels and per-country load time-series.

*   ***build_shapes rule*** automatically downloads administrative country shapes from the GADM dataset and generates GeoJSON files with shapes of the countries, exclusive economic zones and administrative zones at the desired resolution (e.g. region, district, etc.).

2. **Populate data: **
Filtered data are then processed by means of **specific methods** to derive the main input data of the optimization methods, such as renewable energy production, demand, etc. For example, the renewable energy source potential can be transformed into time series for desired locations by using the **tool Atlite**.

The following list of rules apply:

* ***build_cutout*** prepares smaller weather data portions from ERA5.

Atlite, a free software, xarray-based Python library is used for converting the weather data (such as wind speeds, solar radiation, temperature and runoff) into power systems data (such as wind power, solar power, hydro power and heating demand time series).

Atlite processes weather data and converts it into energy system relevant quantities, mainly you can create data for Wind power generation: Using predefined or custom turbine properties and smoothing options for modelling more realistic results. New: Turbines can also be imported from the Open Energy Database. Solar (PV) power generation: Using predefined or custom panel properties. Solar (thermal) heat generation from solar collectors. Hydro (run-off) power generation. Heating demand (based on degree-day approx.).

Altite works by starting from a global weather dataset, e.g. our standard data source ECMWF‚Äôs ERA5 dataset, enabling the creation of a cutout, a spatial and temporal subset of the original data which includes all relevant data such as wind velocity, influx, temperature etc. The cutout consists of grid cells of a certain resolution (depending on your input data, here 30 km x 30 km) each having its own weather timeseries. The cutout builds the starting point to the calculations.

From there, you can extract various quantities and general properties of the data, e.g. wind capacity factors per grid cell for a specific turbine type.

Atlite does not provide exact prediction of the time-series generation at high resolution in a future point in time. The spatial resolution of the results is limited by the input data used. The accuracy of the results is in parts limited by the methodologies used for translating weather data into generation and the underlying assumptions. With the current assumptions Atlite is not suited for predicting the output of single wind turbines or solar panels.

* As the results of Atlite are theoretical and are not validated per se, and while usually a good approximation, can deviate significantly from reality. While in the past and also at the moment datasets generate by packages similar to Atlite where commonly used without a comparison and validation with reality, there is currently a trend to **validate the datasets before using them** to make sure that results are at least plausible.

* ***build_bus_regions*** determines Voronoi cells for all substations (busese) representing both onshore and offshore regions.

* ***build_powerplants*** for today‚Äôs thermal power plant capacities using powerplantmatching allocating these to the closest substation for each powerplant

* ***build_natura_raster*** for rasterising World Database on Protected Areas (WDPA)

* ***build_renewable_profiles*** for the hourly capacity factors and installation potentials constrained by land-use in each substation‚Äôs Voronoi cell for PV, onshore and offshore wind

* ***build_demand_profiles*** for the hourly demand profiles for each substation. The rule build_demand creates load demand profiles in correspondence of the buses of the network. It creates the load paths for GEGIS outputs by combining the input parameters of the countries, weather year, prediction year, and SSP scenario. Then with a function that takes in the PyPSA network ‚Äúbase.nc‚Äù, region and gadm shape data, the countries of interest, a scale factor, and the snapshots, it returns a csv file called ‚Äúdemand_profiles.csv‚Äù, that allocates the load to the buses of the network according to GDP and population.

3. **Create network model:**
Once the necessary model inputs are drawn, then the network model is developed using the Energy System Modelling framework called **PyPSA**

The simplification snakemake rules prepare approximations of the full model, for which it is computationally viable to co-optimize generation, storage and transmission capacities.

* ***base_network rule*** builds and stores the base network with all buses, HVAC lines and HVDC links.

* ***add_electricity rule*** adds the generators and demand to the network model

* ***simplify_network rule*** transforms the transmission grid to a 380 kV only equivalent network

* ***cluster_network rule*** uses a clustering approach (e.g. k-means ) to partition the network into a given number of zones and then reduce the network to a representation with one bus per zone.

* ***add_extra_components rule*** add extra components to the model, such as storage

* ***prepare_network rule*** introduces optional constraints and requirements in the modelling, such as CO2 emissions, security margins, etc, such as:

- adding an annual limit of carbon-dioxide emissions,
- adding an exogenous price per tonne emissions of carbon-dioxide (or other kinds),
- setting an N-1 security margin factor for transmission line capacities,
- specifying an expansion limit on the cost of transmission expansion,
- specifying an expansion limit on the volume of transmission expansion, and
- reducing the temporal resolution by averaging over multiple hours or segmenting time series into chunks of varying lengths using tsam.

4. **Solve network:**
Execute the optimization for the desired problem, e.g. dispatch, planning, etc.

After generating and simplifying the networks they can be solved through the rule solve_network by using the collection rule solve_all_networks.
* Moreover, networks can be solved for another focus with the derivative rules solve_network by using the collection rule solve_operations_network for dispatch-only analyses on an already solved network.

* It solves linear optimal power flow for a network iteratively while updating reactances.

* Capital costs of existing network components are not included in the objective function, since for the optimisation problem they are just a constant term (no influence on optimal result).
Therefore, these capital costs are not included in network.objective!
* If you want to calculate the full total annual system costs add these to the objective value.

5. **Summary and plotting:**
Once the model has been solved, produce nice summaries and plotting

#**Data Required**

The energy modeling workflow takes power grid layout data, climate inputs, and environmental, economical and technological datasets.

1. **Grid topology data**

OpenStreetMap OSM data are used to build power grid topology model. OSM is the biggest crowd-sourced collection of geographic information, which is daily updated and includes geolocation references.

2. **Climate data**

The climate data processing is provided by atlite package. It extracts all the required weather and climate data to generate the time series of renewable potential using the generate_renewable_profiles rule. The main data source on climate variables is ERA5 reanalysis.

3. **Environmental**

- ***copernicus*** contains the raw data on the land covering as available from the Copernicus database. It is used in the build_renewable_profiles rule to quantify what are the land regions available for the installation of renewable resources, e.g. renewable assets may not be installed on arable land.

- ***eez*** is the dataset of the Exclusive Economic Zones (EEZ) available from Marine Regions. This file is used in the rule build_shapes to identify the marine region by country and provide shapes of the maritime regions to be possibly used to estimate off-shore renewable potential, for example.

- ***gebco*** gridded bathymetric data which can be translated into depths and shapes of underwater terrain. These data are used in the build_renewable_profiles rule. GEBCO stands for General Bathymetric Chart of the Oceans.

- ***hydrobasins*** datasets on watershed boundaries and basins, as available from HydroBASINS. These data are used to estimate the hydropower generation in the build_renewable_profiles rule.

- ***landcover*** describes the shapes of world protected areas that are needed to identify in what areas no (renewable) assets can be installed. The landcover dataset was used to generate a natura.tiff raster. Nowadays the pre-compiled natura.tiff raster has global coverage, so there is no need to re-calculate it locally to being able run the modeling workflow.

4. **Economical**

- ***costs.csv*** file contains the default costs of the technologies along with their typical lifetime and efficiency values. The dataset is intended to give a starting point for running the model while regional adjustments may be needed.

- ***gadm*** folder contains data of the shapes of administrative zones by country (e.g. regions, districts, provinces, ‚Ä¶), depending on the level of resolution desired by the configuration file. The data in this folder are automatically populated by the build_shapes rule that download such data from the gadm website.

- ***GDP*** raster dataset of the Gross Domestic Product (GDP) by arcs of the world, as available from DRYAD.

***WorldPop*** raster dataset of the population by arc as automatically by build_shapes rule from WorldPop.

5. **Technological**

- ***eia_hydro_annual_generation.csv*** contains data on total energy production of existing plants as reported per country by the open US Energy Information Administration EIA platforms. Is used to calibrate the runoff time series are obtained from the global reanalysis data.

**Pre-calculated datasets**

There are some datasets which were prepared to ensure smooth run of the model. However, they may (and, in some cases, must) be replaced by custom ones.

- natura.tiff contains geo-spatial data on location of protected and reserved areas and may be used as a mask to exclude such areas when calculating the renewable potential by build_renewable_profiles rule. The natura flag in the configuration file allows to switch-on this option while presence of the natura.tiff in the resources folder is needed to run the model.
Currently the pre-build file is calculated for Africa, global natura.tiff raster is under development.

- electricity demand profiles are provided by PyPSA-Earth as globally hourly demand loads corresponding to Shared Socioeconomic Pathways SSP for 2030, 2040, 2050 and 2100 and weather conditions years of 2011, 2013 and 2018. Pre-calculated data on electricity demand are placed in data/{ssp_scenario_id}/{ssp_year}/era5_2013/{continent_name}.nc folder and loaded automatically during the model run.

* The demand time series were modeled by **synde package** which implements a workflow management system to extract the demand data created with the open source **Global-Energy GIS GEGIS package**. GEGIS produces hourly demand time series by applying machine learning methods using as predictors temperature profiles, population, GDP.

#**Energy system modelling and optimization framework**

###**Model configuration**

The main regional-dependent parameters are:

- countries parameter which defines a set of the countries to be included into the model;

- cutouts and cutout parameters which refer to a name of the climate data archive (so called cutout) to be used for calculation of the renewable potential.

* The run section is used for running and storing scenarios with different configurations which are not covered by Wildcards.

* It is easy to run PyPSA-Earth for **multiple scenarios** using the wildcards feature of snakemake.
Wildcards allow to generalise a rule to produce all files that follow a regular expression pattern which e.g. defines one particular scenario.

- snapshots
Specifies the temporal range for the historical weather data, which is used to build the energy system model. The date range must be in the past (before 2022).
Here, we selected the YEAR 2021.

- augmented_line_connection is enabled to increase the connectivity of the network and ensure the network graph stays connected using the k-edge-augmentation algorithm from the NetworkX Python package.

- The Minimum lines connection per node is set to 2. The type of expanded new lines can be both HVDC or HVAC lines.
- The newly created line capacity is set to 1 MW.
- The Minimum line length of HVDC line is set to 600 Km.

- The network is simplified to substation nodes using the K-means Clustering algorithm.

- All Carriers are considered in the simplified network rule.

- Stub lines and links, i.e. dead-ends of the network, are sequentially removed from the network and across borders.

- Isolated buses are discarded if bus mean power is below 20 MW, and merged into a single isolated bus if bus mean power is below 300 MW.

- K-means Clustering algorithm used in the cluster_network rule considering all carriers using voronoi cell shapes.

- The cluster nodes are distributed per zone according to the load demand.

- p_nom, p_nom_max, p_nom_min of the generators in the clustered are aggregated by summing to represent the new generator; p_min_pu, marginal_cost, and efficieny of the generators are computed using mean to obtain the value of the new generator; ramp_limit_up, and ramp_limit_down of the new generator are computed using the max values; while the commit status of the aggregated generator is set to any.

- The entire GB network is divided into region/county-like shapes representing different zones.

- Reference year used to derive shapes, info on population and info on GDP s 2021.

- The population and GDP are added to every shape by pulling from the web using 1km*1km raster, while the contended areas are assigned to the countries according to the GADM database.

- The OSM data is cleaned by removing assets such as cable, line, generator, etc, whose threshold are below 35000 V; substations with 'transmission' tag are filtered, line endings are added to the dataset of the substations, and generators are named after the closest_city.

- In building the OSM network, close buses with a tolerance of 5000 metres are merged and guarantee the voltage matching among line endings; also, lines overpassing buses within a tolerance of 1 metre are splitted and connected to the buses.

- A Minimum voltage of 35,000 V are set to the offshore substations and base network.

- The future electricity load demand is estimated considering the shared socio-economic pathway (GDP and population growth) scenario and computed (GDP and population) for Years 2025, 2030, 2035, 2040, 2045, 2050. A historical weather year (different renewable potentials) of 2021 is used.

- A Base voltage of 380 V to which all lines are simplified/aggregated is selected, while a subset of [220, 300, 380] Voltage levels are considered for the Voltages of GB Transmission network in ESO ETYS 2023.

- A Cap on system total annual carbon dioxide equivalent emissions of 339.54 MtCO2e for UK in 2021 is selected for GB Network.

- Emissions are obtained from automatic emission extraction procedure from 1990 base year.

- HVDC cables are modeled as PyPSA Link components.

* Contingency reserves represent requirements for upward ramping capability within a specified time frame to compensated for forced outages or unplanned failures of generators or transmission lines (e.g. N-1 contingencies).
- Operational reserve requirements are considered in the model.
- A Share of total load and total renewable supply that is required for operational reserve are set to 2% each.
- An Operational reserve added as a contigency is 5000 MW.

- The Amount of time it takes to fully charge batteries from empty if done at maximum power rate is set to 6 hours, while that of hydrogen storage is set to 168 hours.

- Only solar, onwind, offwind-ac, offwind-dc are extendable by default according to their potentials. OCGT and/or CCGT are not set to be extendable.

- Extendable storage units (battery and hydrogen) are added at every node/bus after clustering without capacity limits and with zero initial capacity.

- Extendable links (H2 pipelines only) are added at every connection where there are lines or HVDC links without capacity limits and with zero initial capacity.

- Only powerplantmatching (ppm) database is used to select today‚Äôs thermal power plants and their capacities.

- nuclear, oil, OCGT, CCGT, coal, lignite, geothermal, biomass conventional power plants are included in the model.

- solar, onwind, offwind-ac, offwind-dc, hydro renewable power plants are included in the model.

- To estimate_renewable_capacities, the greenfield generation expansion is selected for the 2021 reference year, and the maximum nominal power expansion constraint set to use the estimated renewable potentials.

- The electricity line parameters (AC & DC) are specified according to the PyPSA implementation to assume for the different voltage levels 220., 300., 380..

- A Correction factor for line nominal capacities (s_nom) to approximate N-1
 security is selected to be 0.7, while the Global upper limit for the maximum capacity of each extendable line is set to infinity.

 - A Correction factor to account for the fact that buses are not connected by lines through air-line distance, i.e as the crow flies is selected to be 1.25.

 - The capacity of lines which are currently under construction are set to zero.

 - The parameters of the Link between two buses with controllable active power are set to have a Correction factor for link capacities of 1.0; the Global upper limit for the maximum capacity of each extendable DC link is set to infinity; and the capacity of links which are currently under construction are set to zero.

 - The transformers parameters and types such that they have a Series reactance of 0.1 per unit; and 2000 MVA of apparent power which can pass through the branch.

- The parameter used for calculating renewable potentials and time-series using the atlite tool are specified. The tool's database is based on a 30 km x 30 km grid and hourly resolution. The reanalysis weather dataset is era5.

- The ranges of longitudes and latitudes to download weather data for default to the spatial bounds of all bus shapes.

- The Time span to download weather data for is set to 2022.

- The options to obtain renewable potentials in every cutout are set for onshore and offshore wind with both AC and DC connections, solar, and hydro power:

- For onshore wind resource, turbine type and its characteristic power curve are selected as given in the atlite tool:
* name: V112 3MW
* manufacturer: Vestas
* Hub height in meters 80.0
* The Allowable density of wind turbine placement, i.e capacities_per_sqkm is set to 3MW/Km2.
* The areas based on Copernicus CORINE Land Cover which generally eligible for onshore wind turbine placement are set.
* Natural protection areas based on Natura 2000 are included in the model.
* A SIMPLE method is used to compute the maximal installable potential for a node.
* The renewables` per-unit availability time series values that are too small are clipped to zero.
* In nodes where there is no onwind generation, we added a zero-capacity onwind generator so that onwind is considered in the capacity expansion.

- For offshore (AC) wind resource, turbine type and its characteristic power curve are selected as given in the atlite tool:
* name: 2020 ATB Reference 20 MW
* manufacturer: NREL
* Hub height in meters 156
* The Allowable density of wind turbine placement, i.e capacities_per_sqkm is set to 3MW/Km2.
* The areas based on Copernicus CORINE Land Cover which generally eligible for offshore wind turbine placement are set.
* Natural protection areas based on Natura 2000 are included in the model.
* A SIMPLE method is used to compute the maximal installable potential for a node.
* The renewables` per-unit availability time series values that are too small are clipped to zero.
* In nodes where there is no offwind generation, we added a zero-capacity onwind generator so that offwind is considered in the capacity expansion.
* A correction_factor of 0.8855 is selected to account for wake losses according to Bosch et al., 2018.
* A Maximum sea water depth at which wind turbines can be build of 50 metres is set.
* A Maximum distance to the shore beyond which wind turbines with AC connections cannot be build is set to 30000 metres.

- For offshore (DC) wind resource, turbine type and its characteristic power curve are selected as given in the atlite tool is set SAME AS ABOVE for AC offshore wind.

- For Solar PV resource, the solar panel technology and its characteristic attributes are selected as given in the atlite tool:
* name: CSi
* efficiency: 0.1
* Panel temperature coefficient of ambient temperature is 1
* Panel temperature coefficient of irradiance is 0.035 # 0.035 K / (W/m2)
* Reference conditions
** r_tamb: 293 # 20 degC
** r_tmod: 298 # 25 degC
** r_irradiance: 1000 # W/m^2
* inverter_efficiency is set to 0.9
* The orientation is set to latitude_optimal (atlite function which returns the optimal slope and azimuth) to obtain an optimal design.
* A tilt angle (or slope) of 30 degrees of the solar panel is asumed.
* An azimuth orientation of the solar panel is aasumed to be 180 degrees facing South.
* The Allowable density of wind turbine placement, i.e capacities_per_sqkm is set to 4.6 MW/Km2.
* A correction factor for the capacity factor (availability) time series of 0.854337 is selected according to Pietzcker, Robert Carl, et al., 2014.
* The areas based on Copernicus CORINE Land Cover which generally eligible for Solar PV placement are set.
* Natural protection areas based on Natura 2000 are included in the model.
* A SIMPLE method is used to compute the maximal installable potential for a node.
* The renewables` per-unit availability time series values that are too small are clipped to zero.
* In nodes where there is no SOLAR generation, we added a zero-capacity SOLAR generator so that SOLAR is considered in the capacity expansion.

- For Hydro resource, the Atlite method used to calculate renewable potential are selected as given in the atlite tool:
* A file location used to make the runoff calibration, and define a polygon to compute the available water surface using a surface integral is specified.
* A flowspeed of 1 m/s is selected.
* The types of hydro power plants to build per-unit availability time series for such as - ‚Äòror‚Äô stands for run-of-river plants, ‚ÄòPHS‚Äô represents pumped-hydro storage, and ‚Äòhydro‚Äô stands for hydroelectric dams are selected.
* The Maximum state of charge capacity of the pumped-hydro storage (PHS) in terms of hours at full output capacity p_nom is set to 6 hours.
* The Maximum state of charge capacity of the hydro (hydroelectric dams) in terms of hours at full output capacity p_nom is set to the energy_capacity_totals_by_country.
* To avoid too small values in the inflow time series, values below 1 W are set to zero.
* In nodes where there is no hydro generation, we added a zero-capacity hydro generator so that hydro is considered in the capacity expansion.
* To adhere to national statistics, the hydro time series are normalized by rescaling the hydro runoff using the ‚Äòhydro_capacities‚Äô data source file for the year 2021.
* A multiplier factor of 1.1 is applied after the normalization of the hydro production.

- The cost assumptions of the technologies considered are specified for Year 2025, 2030, and 2035, 2040, 2045, 2050.

* Cost information is obtained from the config file and the file data/costs.csv (obtained from Aarhus University's compilation assumptions on energy system technologies (such as costs, efficiencies, lifetimes, etc.) for chosen years; UK Governemnt Energy and emissions projections up to 2040; Department for Business, Energy & Industrial Strategy(BEIS) ELECTRICITY GENERATION COSTS 2016 & 2020; and Storage cost and technical assumptions for BEIS), which can also be modified manually.

* These include cost assumptions for all included technologies for specific years from various sources, namely for:
- discount rate,
- lifetime,
- investment (CAPEX),
- fixed operation and maintenance (FOM),
- variable operation and maintenance (VOM),
- fuel costs,
- efficiency, and
- carbon-dioxide intensity.

* The Share of rooftop PV when calculating capital cost of solar (joint rooftop and utility-scale PV) is set to 0.14.

* The Exogenous price of carbon-dioxide is added using the assumptions of high economic growth taken from the Energy and emissions projections data.

- In this study, our focus is analyzing the unerctainty of highly renewable Energy System Modelling. Therefore, we considered this by Specifying the options for Monte Carlo sampling as thus:

* We selected the number of samples for the optimization, i.e. the number of total sample networks that will be optimized, and the sampling strategy to use between pydoe2, chaospy, or scipy to create an experimental design. Then, we selected the dynamic PyPSA network object that requires the uncertainty analysis which includes the load, solar, and wind generation. A uniform distribution with upper and lower bounds is selected also.

- To solve the optimization problem, we Specify the linear power flow formulation and optimization solver settings as thus:

* The Kirchoff's linearized power flow formulation is selected for use in the optimisation problem.

* We added generators with a prohibitively high marginal cost to simulate load shedding and avoid problem infeasibilities.

* We added random noise to marginal cost of generators and also to the capital cost of lines and links.

* To avoid too small values in the renewables` per-unit availability time series values less than 0.01 are set to zero.

* The glpk solver is selected to use for optimisation problems in the workflow.

###**Build the custom cutout**

- The cutout is an archive containing a spatio-temporal subset of one or more topology and weather datasets.

- To generate the cutout we will use the build_cutouts rule.

- To run it, we first registered on the Copernicus Climate Data Store, and installed cdsapi package (can be installed with pip), and then setup the CDS API key in order to use the CDS API which allows an automatic file download while executing build_cutouts rule.

- Normally cutout extent is calculated from the shape of the requested region defined by the countries parameter.

###**Validation**

- The data validation section aims to assess the data quality with publicly available data

1. Network topology and length
2. Electricity consumption
3. Solar and wind power potentials
4. Power plant database

**Demonstration of optimization capabilities**

- The model is tested on two least-cost power system optimizations, one to reproduce the historical system behaviour and one representing a decarbonized
scenario.

##**Execute different parts of the workflow structure**

###**Retrieve the cleaned OSM data, and plot the OSM Network - Explores osm_build_network**

OpenStreetMap OSM data are used to build power grid topology model.

**Obtain GB shape and Power clean data**
"""

world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))
gbplot = world.query('name == "Great Britain"')

# Clean Data
path_gen_clean = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/all_clean_generators.geojson"
path_sub_clean = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/all_clean_substations.geojson"
path_lin_clean = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/all_clean_lines.geojson"
generators_clean = gpd.read_file(path_gen_clean).set_crs(epsg=4326, inplace=True)
substations_clean = gpd.read_file(path_sub_clean).set_crs(epsg=4326, inplace=True)
lines_clean = gpd.read_file(path_lin_clean).set_crs(epsg=4326, inplace=True)

# line2network:
paths = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/all_buses_build_network.csv"
pathl = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/all_lines_build_network.csv"
patht = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/all_transformers_build_network.csv"
substations = gpd.read_file(
    paths, GEOM_POSSIBLE_NAMES="geometry", KEEP_GEOM_COLUMNS="NO"
)
substations["geometry"] = gpd.points_from_xy(
    pd.to_numeric(substations.lon, downcast="float"),
    pd.to_numeric(substations.lat, downcast="float"),
)
substations = substations.set_crs(epsg=4326, inplace=True)
lines = gpd.read_file(
    pathl, GEOM_POSSIBLE_NAMES="geometry", KEEP_GEOM_COLUMNS="NO"
).set_crs(epsg=4326, inplace=True)
transformers = gpd.read_file(
    patht, GEOM_POSSIBLE_NAMES="geometry", KEEP_GEOM_COLUMNS="NO"
).set_crs(epsg=4326, inplace=True)

"""###**Retrieve the build shapes data and plot GB Shapes**"""

# path of the country shapes
path_country_shapes = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/country_shapes.geojson"
# path of the off shore shapes
path_off_shore_shapes = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/offshore_shapes.geojson"
# path of the gadm shapes
path_gadm_shapes = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/gadm_shapes.geojson"
# Images setups
max_width_image = 30
max_height_image = 30
dpi = 300

# Auxiliary functions
def calculate_width_height_image(
    width_image, height_image, max_width=max_width_image, max_height=max_height_image
):
    """
    Function to identify the width and height of an image to plot
    while keeping the proportions of the image
    """
    if width_image / height_image >= max_width / max_height:
        # image width is the limiting factor
        return (max_width, max_width / width_image * height_image)
    else:
        # image height is the limiting factor
        return (max_height / height_image * width_image, max_height)

# gadm file imports
countries = gpd.read_file(path_country_shapes)
off_shore = gpd.read_file(path_off_shore_shapes)
gadm = gpd.read_file(path_gadm_shapes)

# Plot GB Country Shape and clean OSM data
total_bounds_countries = countries.total_bounds
delta_bounds_xy = (
    total_bounds_countries[2] - total_bounds_countries[0],  # maxx - minx
    total_bounds_countries[3] - total_bounds_countries[1],
)  # maxy - miny
size_image = calculate_width_height_image(*delta_bounds_xy)
ax2 = gadm.plot(
    column="pop",
    cmap="OrRd",
    figsize=size_image,
    legend=False,
    label=True,
    norm=matplotlib.colors.LogNorm(
        vmin=gadm["pop"].min() + 1, vmax=gadm["pop"].max(), clip=True
    ),
    legend_kwds={"extend": "max", "label": "Population in administrative zones"},
)  # column="pop",
#off_shore.plot(ax=ax2, label=None)  # "offshore")
lines_clean.plot(ax=ax2, color="navy", label="OSM lines")
substations_clean.plot(
    ax=ax2, color="papayawhip", label="OSM substations", alpha=0.7, markersize=10
)
legend = plt.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
plt.axis("off")
plt.savefig("GB_image.png", dpi=dpi, bbox_inches="tight")

specific_country = ["GB"]
ax = gadm[gadm.country.isin(specific_country)].boundary.plot(figsize=size_image)
# off_shore.plot(ax=ax)
transformers.plot(ax=ax, marker='o', markersize=20, color="green", label="Transformers",
                  )
substations_clean.plot(
    ax=ax, color="blue", label="Substations",
)
lines_clean.plot(
    ax=ax, color="orange", label="Lines",
)
#plt.title("Substations, Lines, and Transformers Map - Great Britain", fontsize=25, fontweight='bold')
legend = plt.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
for text in legend.get_texts():
    text.set_fontsize(20)  # Set font size
    text.set_fontweight("bold")
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
plt.axis("off")
plt.savefig("border_osm_GB.png", dpi=dpi, bbox_inches="tight")

"""###**Plot the GB Base Network**"""

# base_network file path
network_path_b = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/base.nc"
# base_network PyPSA model
n_b = pypsa.Network(network_path_b)
lines_raw = n_b.lines.copy()
lines_raw["geometry"] = lines_raw["geometry"].map(loads)
lines = gpd.GeoDataFrame(geometry=lines_raw.geometry, crs="epsg:4326")
buses_raw = n_b.buses.copy()
buses_raw["geometry"] = gpd.points_from_xy(buses_raw.lon, buses_raw.lat)
buses = gpd.GeoDataFrame(geometry=buses_raw.geometry, crs="epsg:4326")
ax = countries.plot(figsize=(15, 10), color="skyblue")
#off_shore.plot(ax=ax)
buses.plot(ax=ax, color="black", label="Substations", alpha=0.9,
           markersize=10)
lines.plot(ax=ax, color="blue", label="Transmission Lines", markersize=1, alpha=0.9)
#plt.title("Base Network - Great Britain", fontsize=18, fontweight='bold')
legend = plt.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
for text in legend.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
plt.axis("off")
plt.savefig("Base_Network_GB_2.png", dpi=dpi, bbox_inches="tight")

"""##**Analyse/Explore the Build Cutouts Outputs for GB - Year 2022**

The Outputs are wind, solar, and run-off river relevant time series that are created using the atlite tool.

* Cutouts in Atlite are rasterized weather and environment cells
"""

plt.rcParams["figure.figsize"] = [7, 7]
weather_cell_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/cutout-2022-2023-era5.nc"
weather_cell = xr.open_dataset(weather_cell_path)
print('===============================================================================')
print(weather_cell)
print('===============================================================================')

"""###**Visualize the ERA5 Reanalysis Weather Data Variables for the UK in Year 2022**"""

# Temperature
y_idx = 56.1
x_idx = -4.5
y_idx = int(y_idx)
x_idx = int(x_idx)
temperature_da = weather_cell.temperature
temperature_da = xr.DataArray(temperature_da, dims=['time', 'y', 'x'])
temperature_time_series_scotland = temperature_da.isel(y=y_idx, x=x_idx)
y_idx = 51.3
x_idx = -3.3
y_idx = int(y_idx)
x_idx = int(x_idx)
temperature_da = weather_cell.temperature
temperature_da = xr.DataArray(temperature_da, dims=['time', 'y', 'x'])
temperature_time_series_wales = temperature_da.isel(y=y_idx, x=x_idx)
y_idx = 51.6
x_idx = 0.3
y_idx = int(y_idx)
x_idx = int(x_idx)
temperature_da = weather_cell.temperature
temperature_da = xr.DataArray(temperature_da, dims=['time', 'y', 'x'])
temperature_time_series_essex = temperature_da.isel(y=y_idx, x=x_idx)
y_idx = 53.7
x_idx = -1.5
y_idx = int(y_idx)
x_idx = int(x_idx)
temperature_da = weather_cell.temperature
temperature_da = xr.DataArray(temperature_da, dims=['time', 'y', 'x'])
temperature_time_series_wakefield = temperature_da.isel(y=y_idx, x=x_idx)
# Wind @ 100 metres
y_idx = 56.1
x_idx = -4.5
y_idx = int(y_idx)
x_idx = int(x_idx)
wnd100m_da = weather_cell.wnd100m
wnd100m_da = xr.DataArray(wnd100m_da, dims=['time', 'y', 'x'])
wnd100m_time_series_scotland = wnd100m_da.isel(y=y_idx, x=x_idx)
y_idx = 51.3
x_idx = -3.3
y_idx = int(y_idx)
x_idx = int(x_idx)
wnd100m_da = weather_cell.wnd100m
wnd100m_da = xr.DataArray(wnd100m_da, dims=['time', 'y', 'x'])
wnd100m_time_series_wales = wnd100m_da.isel(y=y_idx, x=x_idx)
y_idx = 51.6
x_idx = 0.3
y_idx = int(y_idx)
x_idx = int(x_idx)
wnd100m_da = weather_cell.wnd100m
wnd100m_da = xr.DataArray(wnd100m_da, dims=['time', 'y', 'x'])
wnd100m_time_series_essex = wnd100m_da.isel(y=y_idx, x=x_idx)
y_idx = 53.7
x_idx = -1.5
y_idx = int(y_idx)
x_idx = int(x_idx)
wnd100m_da = weather_cell.wnd100m
wnd100m_da = xr.DataArray(wnd100m_da, dims=['time', 'y', 'x'])
wnd100m_time_series_wakefield = wnd100m_da.isel(y=y_idx, x=x_idx)
# albedo
y_idx = 56.1
x_idx = -4.5
y_idx = int(y_idx)
x_idx = int(x_idx)
runoff_da = weather_cell.albedo
runoff_da = xr.DataArray(runoff_da, dims=['time', 'y', 'x'])
runoff_time_series_scotland = runoff_da.isel(y=y_idx, x=x_idx)
y_idx = 51.3
x_idx = -3.3
y_idx = int(y_idx)
x_idx = int(x_idx)
runoff_da = weather_cell.albedo
runoff_da = xr.DataArray(runoff_da, dims=['time', 'y', 'x'])
runoff_time_series_wales = runoff_da.isel(y=y_idx, x=x_idx)
y_idx = 51.6
x_idx = 0.3
y_idx = int(y_idx)
x_idx = int(x_idx)
runoff_da = weather_cell.albedo
runoff_da = xr.DataArray(runoff_da, dims=['time', 'y', 'x'])
runoff_time_series_essex = runoff_da.isel(y=y_idx, x=x_idx)
y_idx = 53.7
x_idx = -1.5
y_idx = int(y_idx)
x_idx = int(x_idx)
runoff_da = weather_cell.albedo
runoff_da = xr.DataArray(runoff_da, dims=['time', 'y', 'x'])
runoff_time_series_wakefield = runoff_da.isel(y=y_idx, x=x_idx)
# roughness
y_idx = 56.1
x_idx = -4.5
y_idx = int(y_idx)
x_idx = int(x_idx)
influx_toa_da = weather_cell.roughness
influx_toa_da = xr.DataArray(influx_toa_da, dims=['time', 'y', 'x'])
influx_toa_time_series_scotland = influx_toa_da.isel(y=y_idx, x=x_idx)
y_idx = 51.3
x_idx = -3.3
y_idx = int(y_idx)
x_idx = int(x_idx)
influx_toa_da = weather_cell.roughness
influx_toa_da = xr.DataArray(influx_toa_da, dims=['time', 'y', 'x'])
influx_toa_time_series_wales = influx_toa_da.isel(y=y_idx, x=x_idx)
y_idx = 51.6
x_idx = 0.3
y_idx = int(y_idx)
x_idx = int(x_idx)
influx_toa_da = weather_cell.roughness
influx_toa_da = xr.DataArray(influx_toa_da, dims=['time', 'y', 'x'])
influx_toa_time_series_essex = influx_toa_da.isel(y=y_idx, x=x_idx)
y_idx = 53.7
x_idx = -1.5
y_idx = int(y_idx)
x_idx = int(x_idx)
influx_toa_da = weather_cell.roughness
influx_toa_da = xr.DataArray(influx_toa_da, dims=['time', 'y', 'x'])
influx_toa_time_series_wakefield = influx_toa_da.isel(y=y_idx, x=x_idx)

sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (16, 12)
fig, axs = plt.subplots(2, 2)
#plt.subplots_adjust(wspace=0.8, hspace=0.4, bottom=0.5)
plt.autoscale(tight=True)

# Plot Temperature in ax[1]
axs[0, 0].cla()
axs[0, 0].set_facecolor("white")
axs[0, 0].spines[['top', 'right']].set_visible(False)
axs[0, 0].set_ylabel('Degree Celsius', size=15, fontweight='bold')
axs[0, 0].set_xlabel('Selected Sub-stations', size=20, fontweight='bold')

axs[0, 0].plot(temperature_time_series_scotland, color='b', label='Scotland')
axs[0, 0].plot(temperature_time_series_wales, color='r', label='Wales')
axs[0, 0].plot(temperature_time_series_essex, color='g', label='Essex')
axs[0, 0].plot(temperature_time_series_wakefield, color='y', label='Wakefield')
legend1 = axs[0, 0].legend(loc='best', ncol=2, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
#axs[0, 0].set_title('Temperature At 2 Metres', size=20, fontweight='bold')
fig.text(0.27, 0.51, '(a) Temperature At 2 Metres', ha='center', size=20, fontweight='bold')
#axs[0, 0].tick_params(axis='x', rotation=30, labelsize=20)
axs[0, 0].tick_params(axis='y', rotation=0, labelsize=20)
#axs[0, 0].set_xticks([r + 1.5 * bar_width for r in range(len(bus_labels))])
#axs[0, 0].set_xticklabels(bus_labels, rotation=30)
#axs[1] = plt.gca()
for spine in axs[0, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0, 0].xaxis.grid(False)
axs[0, 0].yaxis.grid(False)
axs[0, 0].set_yscale('log')

# Plot Wind in ax[2]
axs[0, 1].cla()
axs[0, 1].set_facecolor("white")
axs[0, 1].spines[['top', 'right']].set_visible(False)
axs[0, 1].set_ylabel('m/s', size=15, fontweight='bold')
axs[0, 1].set_xlabel('Selected Sub-stations', size=20, fontweight='bold')

axs[0, 1].plot(wnd100m_time_series_scotland, color='b', label='Scotland')
axs[0, 1].plot(wnd100m_time_series_wales, color='r', label='Wales')
axs[0, 1].plot(wnd100m_time_series_essex, color='g', label='Essex')
axs[0, 1].plot(wnd100m_time_series_wakefield, color='y', label='Wakefiled')
legend2 = axs[0, 1].legend(loc='best', ncol=2, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
#axs[0, 1].set_title('Wind Speed At 100 Metres', size=20, fontweight='bold')
fig.text(0.77, 0.51, '(b) Wind Speed At 100 Metres', ha='center', size=20, fontweight='bold')
#axs[0, 1].tick_params(axis='x', rotation=30, labelsize=20)
axs[0, 1].tick_params(axis='y', rotation=0, labelsize=20)
#axs[0, 1].set_xticks([r + 1.5 * bar_width for r in range(len(bus_labels))])
#axs[0, 1].set_xticklabels(bus_labels, rotation=30)
#axs[1] = plt.gca()
for spine in axs[0, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0, 1].xaxis.grid(False)
axs[0, 1].yaxis.grid(False)
axs[0, 1].set_yscale('log')

# Plot albedo in ax[3]
axs[1, 0].cla()
axs[1, 0].set_facecolor("white")
axs[1, 0].spines[['top', 'right']].set_visible(False)
axs[1, 0].set_ylabel('Albedo', size=15, fontweight='bold')
axs[1, 0].set_xlabel('Selected Sub-stations', size=20, fontweight='bold')

axs[1, 0].plot(runoff_time_series_scotland,
               color='b', label='Scotland')
axs[1, 0].plot(runoff_time_series_wales,
               color='r', label='Wales')
axs[1, 0].plot(runoff_time_series_essex,
               color='g', label='Essex')
axs[1, 0].plot(runoff_time_series_wakefield,
               color='y', label='Wakefield')
legend3 = axs[1, 0].legend(loc='best', ncol=2, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend3.get_frame().set_edgecolor('black')
legend3.get_frame().set_linewidth(1)
#axs[1, 0].set_title('Surface Albedo', size=20, fontweight='bold')
fig.text(0.27, -0.01, '(c) Surface Albedo', ha='center', size=20, fontweight='bold')
#axs[0, 0].tick_params(axis='x', rotation=30, labelsize=20)
axs[1, 0].tick_params(axis='y', rotation=0, labelsize=20)
#axs[1, 0].set_xticks([r + 1.5 * bar_width for r in range(len(bus_labels))])
#axs[1, 0].set_xticklabels(bus_labels, rotation=30)
#axs[1] = plt.gca()
for spine in axs[1, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1, 0].xaxis.grid(False)
axs[1, 0].yaxis.grid(False)
axs[1, 0].set_yscale('log')

# Plot roughness in ax[4]
axs[1, 1].cla()
axs[1, 1].set_facecolor("white")
axs[1, 1].spines[['top', 'right']].set_visible(False)
axs[1, 1].set_ylabel('metres', size=15, fontweight='bold')
axs[1, 1].set_xlabel('Selected Sub-stations', size=20, fontweight='bold')

axs[1, 1].plot(influx_toa_time_series_scotland,
               color='b', label='Scotland')
axs[1, 1].plot(influx_toa_time_series_wales,
               color='r', label='Wales')
axs[1, 1].plot(influx_toa_time_series_essex,
               color='g', label='Essex')
axs[1, 1].plot(influx_toa_time_series_wakefield,
               color='y', label='Wakefiled')
legend4 = axs[1, 1].legend(loc='best', ncol=2, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend4.get_frame().set_edgecolor('black')
legend4.get_frame().set_linewidth(1)
#axs[1, 1].set_title('Surface Roughness', size=20, fontweight='bold')
fig.text(0.76, -0.01, '(d) Surface Roughness', ha='center', size=20, fontweight='bold')
#axs[0, 0].tick_params(axis='x', rotation=30, labelsize=20)
axs[1, 1].tick_params(axis='y', rotation=0, labelsize=20)
#axs[1, 1].set_xticks([r + 1.5 * bar_width for r in range(len(bus_labels))])
#axs[1, 1].set_xticklabels(bus_labels, rotation=30)
#axs[1] = plt.gca()
for spine in axs[1, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1, 1].xaxis.grid(False)
axs[1, 1].yaxis.grid(False)
axs[1, 1].set_yscale('log')

# Save the plot to a directory in Google Drive
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/WeatherData_TimeSeries_of_Selected_Locations.png')
plt.tight_layout()
plt.subplots_adjust(wspace=0.2, hspace=0.4)
plt.show()

"""##**Analyses the Renewable Profiles and its Outputs**

Outputs are timeseries of wind or solar power plants as well as the resource potential. There are two types of potentials:

- technical installable power potential [MW] which does not need hourly profiles (area demand per tech. MW/km^2 * general available area m^2 * availability factor);

- technical 'resource' energy potential [MWh] which needs hourly per unit profiles and the above power potential.

The Renewable Profiles such as solar-PV, onshore wind, Offshore wind (AC & DC), and Hydro are build with inputs such as:

- natura raster, areas where renewables are excluded i.e. areas under protection (generated in build_natura_raster).
- copernicus, global land cover data (classifies land data).
- gebco, bathemetry data (deepness of sea).
- country_shapes and offshore_shapes, to determine the region of interest.
- hydro_capacities, capacities of hydro power plants.
- eia_hydro_generation, annual hydro generation from the IEA (International Energy Agency) to rescale the data if desired.
- powerplants, list of power plants.
- regions, to identify the regions that correspond to each bus; and
- cutout, environmental data timeseries such as wind speed and irradiation.

###**Load the .nc Renewable Profile files**
"""

solar_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/profile_solar.nc"
solar = xr.open_dataset(solar_path)

onwind_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/profile_onwind.nc"
onwind = xr.open_dataset(onwind_path)

offwind_ac_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/profile_offwind-ac.nc"
offwind_ac = xr.open_dataset(offwind_ac_path)

offwind_dc_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/profile_offwind-dc.nc"
offwind_dc = xr.open_dataset(offwind_dc_path)

hydro_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/profile_hydro.nc"
hydro = xr.open_dataset(hydro_path)

"""###**Plot Technical Installable Onshore Wind Power Potential in GW**"""

import cartopy
data = onwind.potential
figsize = (10, 10)
projection = ccrs.PlateCarree() # ccrs.Mercator()
region = ["United Kingdom"]
cmap = "BuGn"
cb_label = "Potential"
gridlabels = True
title = "Onshore Wind Potential in Great Britain [GW]"
filename = "rasterized-onshore-wind-potential.png"
format = "png"

font_scale = figsize[0] / 10  # according to width
plt.rcParams.update({"font.size": 17 * font_scale})
fig, ax = plt.subplots(figsize=figsize, subplot_kw={"projection": projection})
(data / 1000).plot(ax = ax,
                   cmap = cmap,
                   edgecolor = "grey", #grey
                   linestyle = ":",
                   add_colorbar = True,
                   cbar_kwargs = {"shrink": 1, "label": cb_label},
                   )
ax.coastlines()
ax.add_feature(cartopy.feature.BORDERS.with_scale("110m"))
world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))
shapes_country = world[world.name.isin(region)]
shapes_continent = world[world.continent.isin(region)]
shapes = pd.concat([shapes_country, shapes_continent])
shapes.plot(ax=ax, edgecolor="k", color="None", linewidth=2.0)
buffer = 0.5
minx, miny, maxx, maxy = (shapes.to_crs(ccrs.PlateCarree()).bounds).values.flatten()
minx, miny = [minx - buffer, miny - buffer]
maxx, maxy = [maxx + buffer, maxy + buffer]
ax.set_extent([minx, maxx, miny, maxy], crs=ccrs.PlateCarree())  # Nigeria
#  ax.set_extent([-23, 55, -35, 40], crs=ccrs.PlateCarree())  #  Africa
#ax.set_aspect("auto")
if gridlabels == True:
    gl = ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True)
    gl.top_labels = False
    gl.right_labels = False
    gl.xlines = False
    gl.ylines = False
    gl.xlabel_style = {"size": 12 * font_scale}
    gl.ylabel_style = {"size": 12 * font_scale}
#plt.title(title, fontdict={'fontsize': 13, 'fontweight': 'bold'})
plt.savefig(filename, format=format, bbox_inches="tight")
Image(filename)
plt.show()

"""###**Plot Technical Installable Solar PV Power Potential in GW**"""

data = solar.potential
figsize = (10, 10)
projection = ccrs.PlateCarree() # ccrs.Mercator()
region = ["United Kingdom"]
cmap="OrRd"
cb_label = "Potential"
gridlabels = True
filename = "rasterized-solvar-pv-potential.PNG"
format = "png"

font_scale = figsize[0] / 10  # according to width
plt.rcParams.update({"font.size": 17 * font_scale})
fig, ax = plt.subplots(figsize=figsize, subplot_kw={"projection": projection})
(data / 1000).plot(ax = ax,
                   cmap = cmap,
                   edgecolor = "grey", #grey
                   linestyle = ":",
                   add_colorbar = True,
                   cbar_kwargs = {"shrink": 1, "label": cb_label},
                   )
ax.coastlines()
ax.add_feature(cartopy.feature.BORDERS.with_scale("110m"))
world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))
shapes_country = world[world.name.isin(region)]
shapes_continent = world[world.continent.isin(region)]
shapes = pd.concat([shapes_country, shapes_continent])
shapes.plot(ax=ax, edgecolor="k", color="None", linewidth=2.0)
buffer = 0.5
minx, miny, maxx, maxy = (shapes.to_crs(ccrs.PlateCarree()).bounds).values.flatten()
minx, miny = [minx - buffer, miny - buffer]
maxx, maxy = [maxx + buffer, maxy + buffer]
ax.set_extent([minx, maxx, miny, maxy], crs=ccrs.PlateCarree())  # Nigeria
#  ax.set_extent([-23, 55, -35, 40], crs=ccrs.PlateCarree())  #  Africa
#ax.set_aspect("auto")
if gridlabels == True:
    gl = ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True)
    gl.top_labels = False
    gl.right_labels = False
    gl.xlines = False
    gl.ylines = False
    gl.xlabel_style = {"size": 12 * font_scale}
    gl.ylabel_style = {"size": 12 * font_scale}
#plt.title(title, fontdict={'fontsize': 13, 'fontweight': 'bold'})
plt.savefig(filename, format=format, bbox_inches="tight")
Image(filename)
plt.show()

"""###**Plot Technical Installable Offshore Wind (AC) Power Potential in GW**"""

data = offwind_ac.potential
figsize = (10, 10)
projection = ccrs.PlateCarree() # ccrs.Mercator()
region = ["United Kingdom"]
cmap="YlGnBu"
cb_label = "Potential"
gridlabels = True
filename = "rasterized-offwind_ac-potential.PNG"
format = "png"

font_scale = figsize[0] / 10  # according to width
plt.rcParams.update({"font.size": 17 * font_scale})
fig, ax = plt.subplots(figsize=figsize, subplot_kw={"projection": projection})
(data / 1000).plot(ax = ax,
                   cmap = cmap,
                   edgecolor = "grey", #grey
                   linestyle = ":",
                   add_colorbar = True,
                   cbar_kwargs = {"shrink": 1, "label": cb_label},
                   )
ax.coastlines()
ax.add_feature(cartopy.feature.BORDERS.with_scale("110m"))
world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))
shapes_country = world[world.name.isin(region)]
shapes_continent = world[world.continent.isin(region)]
shapes = pd.concat([shapes_country, shapes_continent])
shapes.plot(ax=ax, edgecolor="k", color="None", linewidth=2.0)
buffer = 0.5
minx, miny, maxx, maxy = (shapes.to_crs(ccrs.PlateCarree()).bounds).values.flatten()
minx, miny = [minx - buffer, miny - buffer]
maxx, maxy = [maxx + buffer, maxy + buffer]
ax.set_extent([minx, maxx, miny, maxy], crs=ccrs.PlateCarree())  # Nigeria
#  ax.set_extent([-23, 55, -35, 40], crs=ccrs.PlateCarree())  #  Africa
#ax.set_aspect("auto")
if gridlabels == True:
    gl = ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True)
    gl.top_labels = False
    gl.right_labels = False
    gl.xlines = False
    gl.ylines = False
    gl.xlabel_style = {"size": 12 * font_scale}
    gl.ylabel_style = {"size": 12 * font_scale}
#plt.title(title, fontdict={'fontsize': 13, 'fontweight': 'bold'})
plt.savefig(filename, format=format, bbox_inches="tight")
Image(filename)
plt.show()

"""###**Plot Technical Installable Offshore Wind (DC) Power Potential in GW**"""

data = offwind_dc.potential
figsize = (10, 10)
projection = ccrs.PlateCarree() # ccrs.Mercator()
region = ["United Kingdom"]
cmap="PuRd"
cb_label = "Potential"
gridlabels = True
filename = "rasterized-offwind_dc-potential.PNG"
format = "png"

font_scale = figsize[0] / 10  # according to width
plt.rcParams.update({"font.size": 17 * font_scale})
fig, ax = plt.subplots(figsize=figsize, subplot_kw={"projection": projection})
(data / 1000).plot(ax = ax,
                   cmap = cmap,
                   edgecolor = "grey", #grey
                   linestyle = ":",
                   add_colorbar = True,
                   cbar_kwargs = {"shrink": 1, "label": cb_label},
                   )
ax.coastlines()
ax.add_feature(cartopy.feature.BORDERS.with_scale("110m"))
world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))
shapes_country = world[world.name.isin(region)]
shapes_continent = world[world.continent.isin(region)]
shapes = pd.concat([shapes_country, shapes_continent])
shapes.plot(ax=ax, edgecolor="k", color="None", linewidth=2.0)
buffer = 0.5
minx, miny, maxx, maxy = (shapes.to_crs(ccrs.PlateCarree()).bounds).values.flatten()
minx, miny = [minx - buffer, miny - buffer]
maxx, maxy = [maxx + buffer, maxy + buffer]
ax.set_extent([minx, maxx, miny, maxy], crs=ccrs.PlateCarree())  # Nigeria
#  ax.set_extent([-23, 55, -35, 40], crs=ccrs.PlateCarree())  #  Africa
#ax.set_aspect("auto")
if gridlabels == True:
    gl = ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True)
    gl.top_labels = False
    gl.right_labels = False
    gl.xlines = False
    gl.ylines = False
    gl.xlabel_style = {"size": 12 * font_scale}
    gl.ylabel_style = {"size": 12 * font_scale}
#plt.title(title, fontdict={'fontsize': 13, 'fontweight': 'bold'})
plt.savefig(filename, format=format, bbox_inches="tight")
Image(filename)
plt.show()

# Data for first plot
data1 = offwind_dc.potential
cmap1 = "PuRd"
cb_label1 = "Potential"
filename1 = "rasterized-offwind_dc-potential.PNG"

# Data for second plot
data2 = offwind_ac.potential
cmap2 = "YlGnBu"
cb_label2 = "Potential"
filename2 = "rasterized-offwind_ac-potential.PNG"

# General plot settings
figsize = (20, 12)
projection = ccrs.PlateCarree()
region = ["United Kingdom"]
format = "png"
font_scale = figsize[0] / 20  # according to width
plt.rcParams.update({"font.size": 17 * font_scale})

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=figsize, subplot_kw={"projection": projection})

# First plot
(data1 / 1000).plot(ax=ax1,
                   cmap=cmap1,
                   edgecolor="grey",
                   linestyle=":",
                   add_colorbar=True,
                   cbar_kwargs={"shrink": 1, "label": cb_label1},
                   )
ax1.coastlines()
ax1.add_feature(cartopy.feature.BORDERS.with_scale("110m"))
world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))
shapes_country = world[world.name.isin(region)]
shapes_continent = world[world.continent.isin(region)]
shapes = pd.concat([shapes_country, shapes_continent])
shapes.plot(ax=ax1, edgecolor="k", color="None", linewidth=2.0)
buffer = 0.5
minx, miny, maxx, maxy = (shapes.to_crs(ccrs.PlateCarree()).bounds).values.flatten()
minx, miny = [minx - buffer, miny - buffer]
maxx, maxy = [maxx + buffer, maxy + buffer]
ax1.set_extent([minx, maxx, miny, maxy], crs=ccrs.PlateCarree())
if gridlabels:
    gl = ax1.gridlines(crs=ccrs.PlateCarree(), draw_labels=True)
    gl.top_labels = False
    gl.right_labels = False
    gl.xlines = False
    gl.ylines = False
    gl.xlabel_style = {"size": 12 * font_scale}
    gl.ylabel_style = {"size": 12 * font_scale}
#ax1.set_title("Offshore Wind DC Potential", fontdict={'fontsize': 18, 'fontweight': 'bold'})
fig.text(0.25, 0.06, '(a) Offshore Wind DC Potential', ha='center',
            size=18, fontweight='bold')
# Second plot
(data2 / 1000).plot(ax=ax2,
                   cmap=cmap2,
                   edgecolor="grey",
                   linestyle=":",
                   add_colorbar=True,
                   cbar_kwargs={"shrink": 1, "label": cb_label2},
                   )
ax2.coastlines()
ax2.add_feature(cartopy.feature.BORDERS.with_scale("110m"))
shapes.plot(ax=ax2, edgecolor="k", color="None", linewidth=2.0)
ax2.set_extent([minx, maxx, miny, maxy], crs=ccrs.PlateCarree())
if gridlabels:
    gl = ax2.gridlines(crs=ccrs.PlateCarree(), draw_labels=True)
    gl.top_labels = False
    gl.right_labels = False
    gl.xlines = False
    gl.ylines = False
    gl.xlabel_style = {"size": 12 * font_scale}
    gl.ylabel_style = {"size": 12 * font_scale}
#ax2.set_title("Offshore Wind AC Potential", fontdict={'fontsize': 18, 'fontweight': 'bold'})
fig.text(0.74, 0.06, '(b) Offshore Wind AC Potential', ha='center',
            size=18, fontweight='bold')
plt.savefig(filename1, format=format, bbox_inches="tight")
Image(filename1)
plt.show()

"""###**Technical Installable Onshore Wind Power Potential At Each Substations**"""

import cartopy
data = onwind.potential / 1000
cmap = "Blues"
projection = ccrs.PlateCarree()  # Use Cartopy PlateCarree projection object
region = ["United Kingdom"]
filename = "onwind-gridcell.png"

plt.rcParams.update({"font.size": 12})
fig, ax = plt.subplots(figsize=(12, 8), subplot_kw={"projection": projection})
data.plot.imshow(ax=ax, transform=ccrs.PlateCarree(), cmap=cmap,
                 label="Potential [GW]")
ax.coastlines()
ax.add_feature(cartopy.feature.BORDERS.with_scale("110m"))
world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))
shapes_country = world[world.name.isin(region)]
shapes_continent = world[world.continent.isin(region)]
shapes = pd.concat([shapes_country, shapes_continent])
shapes.plot(ax=ax, edgecolor="k", color="None")
buffer = 0.5
minx, miny, maxx, maxy = (shapes.to_crs(ccrs.PlateCarree()).bounds).values.flatten()
minx, miny = [minx - buffer, miny - buffer]
maxx, maxy = [maxx + buffer, maxy + buffer]
ax.set_extent([minx, maxx, miny, maxy], crs=ccrs.PlateCarree())
br = gpd.read_file(f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/regions_onshore.geojson")
br.plot(ax=ax,
        transform=ccrs.PlateCarree(),
        facecolor="none",
        linewidth=0.25,
        edgecolor="k",
        )
plt.savefig(filename, bbox_inches="tight")
Image(filename)
plt.show

"""###**Technical Installable Solar PV Power Potential At Each Substations**"""

data = solar.potential / 1000
cmap = "OrRd"
projection = ccrs.PlateCarree()  # Use Cartopy PlateCarree projection object
region = ["United Kingdom"]
filename = "solar-gridcell.png"

plt.rcParams.update({"font.size": 12})
fig, ax = plt.subplots(figsize=(12, 8), subplot_kw={"projection": projection})
data.plot.imshow(ax=ax, transform=ccrs.PlateCarree(), cmap=cmap,
                 label="Potential [GW]")
ax.coastlines()
ax.add_feature(cartopy.feature.BORDERS.with_scale("110m"))
world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))
shapes_country = world[world.name.isin(region)]
shapes_continent = world[world.continent.isin(region)]
shapes = pd.concat([shapes_country, shapes_continent])
shapes.plot(ax=ax, edgecolor="k", color="None")
buffer = 0.5
minx, miny, maxx, maxy = (shapes.to_crs(ccrs.PlateCarree()).bounds).values.flatten()
minx, miny = [minx - buffer, miny - buffer]
maxx, maxy = [maxx + buffer, maxy + buffer]
ax.set_extent([minx, maxx, miny, maxy], crs=ccrs.PlateCarree())
br = gpd.read_file(f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/regions_onshore.geojson")
br.plot(ax=ax,
        transform=ccrs.PlateCarree(),
        facecolor="none",
        linewidth=0.25,
        edgecolor="k",
        )
plt.savefig(filename, bbox_inches="tight")
Image(filename)
plt.show

"""###**Plot Potential Density For all Technologies**

**Onshore Wind**
"""

br = gpd.read_file(f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/regions_onshore.geojson")
elec = pypsa.Network(f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec.nc")
n = elec
carrier = "onwind"
cmap = "Blues"
projection = ccrs.PlateCarree()
region = ["United Kingdom"]
filename = "onwind-cell.png"

g = n.generators.loc[n.generators.carrier == carrier]
br = gpd.read_file(f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/regions_onshore.geojson").set_index("name")
br_area = br.to_crs("ESRI:54009")
br_area = br_area.geometry.area * 1e-6
br["p_nom_max"] = g.groupby("bus").sum().p_nom_max / br_area
fig, ax = plt.subplots(figsize=(12, 8), subplot_kw={"projection": projection})
plt.rcParams.update({"font.size": 10})
br.plot(ax=ax,
        column="p_nom_max",
        transform=ccrs.PlateCarree(),
        linewidth=0.25,
        edgecolor="k",
        cmap=cmap,
        vmin=0,
        vmax=br["p_nom_max"].max(),
        legend=True,
        legend_kwds={"label": r"Potential Density"},
        )
ax.coastlines()
ax.add_feature(cartopy.feature.BORDERS.with_scale("110m"))
world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))
shapes_country = world[world.name.isin(region)]
shapes_continent = world[world.continent.isin(region)]
shapes = pd.concat([shapes_country, shapes_continent])
shapes.plot(ax=ax, edgecolor="k", color="None")
buffer = 0.5
minx, miny, maxx, maxy = (shapes.to_crs(ccrs.PlateCarree()).bounds).values.flatten()
minx, miny = [minx - buffer, miny - buffer]
maxx, maxy = [maxx + buffer, maxy + buffer]
ax.set_extent([minx, maxx, miny, maxy], crs=ccrs.PlateCarree())
plt.savefig(filename, bbox_inches="tight")
Image(filename)
plt.show

"""**Solar-PV**"""

br = gpd.read_file(f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/regions_onshore.geojson")
elec = pypsa.Network(f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec.nc")
n = elec
carrier = "solar"
cmap = "OrRd"
projection = ccrs.PlateCarree()
region = ["United Kingdom"]
filename = "solar-cell.png"

g = n.generators.loc[n.generators.carrier == carrier]
br = gpd.read_file(f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/regions_onshore.geojson").set_index("name")
br_area = br.to_crs("ESRI:54009")
br_area = br_area.geometry.area * 1e-6
br["p_nom_max"] = g.groupby("bus").sum().p_nom_max / br_area
fig, ax = plt.subplots(figsize=(12, 8), subplot_kw={"projection": projection})
plt.rcParams.update({"font.size": 10})
br.plot(ax=ax,
        column="p_nom_max",
        transform=ccrs.PlateCarree(),
        linewidth=0.25,
        edgecolor="k",
        cmap=cmap,
        vmin=0,
        vmax=br["p_nom_max"].max(),
        legend=True,
        legend_kwds={"label": r"Potential Density"},
        )
ax.coastlines()
ax.add_feature(cartopy.feature.BORDERS.with_scale("110m"))
world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))
shapes_country = world[world.name.isin(region)]
shapes_continent = world[world.continent.isin(region)]
shapes = pd.concat([shapes_country, shapes_continent])
shapes.plot(ax=ax, edgecolor="k", color="None")
buffer = 0.5
minx, miny, maxx, maxy = (shapes.to_crs(ccrs.PlateCarree()).bounds).values.flatten()
minx, miny = [minx - buffer, miny - buffer]
maxx, maxy = [maxx + buffer, maxy + buffer]
ax.set_extent([minx, maxx, miny, maxy], crs=ccrs.PlateCarree())
plt.savefig(filename, bbox_inches="tight")
Image(filename)
plt.show

# First plot
data = solar.potential / 1000
cmap = "OrRd"
projection = ccrs.PlateCarree()
region = ["United Kingdom"]
filename1 = "solar-gridcell.png"

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 12), subplot_kw={"projection": projection})

plt.rcParams.update({"font.size": 15})
data.plot.imshow(ax=ax1, transform=ccrs.PlateCarree(), cmap=cmap, label="Potential [GW]")
ax1.coastlines()
ax1.add_feature(cartopy.feature.BORDERS.with_scale("110m"))
world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))
shapes_country = world[world.name.isin(region)]
shapes_continent = world[world.continent.isin(region)]
shapes = pd.concat([shapes_country, shapes_continent])
shapes.plot(ax=ax1, edgecolor="k", color="None")
buffer = 0.5
minx, miny, maxx, maxy = (shapes.to_crs(ccrs.PlateCarree()).bounds).values.flatten()
minx, miny = [minx - buffer, miny - buffer]
maxx, maxy = [maxx + buffer, maxy + buffer]
ax1.set_extent([minx, maxx, miny, maxy], crs=ccrs.PlateCarree())
br = gpd.read_file("/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/regions_onshore.geojson")
br.plot(ax=ax1, transform=ccrs.PlateCarree(), facecolor="none", linewidth=0.25, edgecolor="k",
        legend_kwds={"label": r"Potential"})
#ax1.set_title("Solar PV Potential", fontdict={'fontsize': 18, 'fontweight': 'bold'})
fig.text(0.26, 0.06, '(a) Solar PV Potential', ha='center',
            size=18, fontweight='bold')
plt.savefig(filename1, bbox_inches="tight")
Image(filename1)

# Second plot
br = gpd.read_file("/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/regions_onshore.geojson")
elec = pypsa.Network("/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec.nc")
n = elec
carrier = "solar"
cmap = "OrRd"
filename2 = "solar-cell.png"

g = n.generators.loc[n.generators.carrier == carrier]
br = gpd.read_file("/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/regions_onshore.geojson").set_index("name")
br_area = br.to_crs("ESRI:54009")
br_area = br_area.geometry.area * 1e-6
br["p_nom_max"] = g.groupby("bus").sum().p_nom_max / br_area

plt.rcParams.update({"font.size": 15})
br.plot(ax=ax2, column="p_nom_max", transform=ccrs.PlateCarree(), linewidth=0.25,
        edgecolor="k", cmap=cmap,
        vmin=0, vmax=br["p_nom_max"].max(), legend=True,
        legend_kwds={"label": r"Potential Density"})
ax2.coastlines()
ax2.add_feature(cartopy.feature.BORDERS.with_scale("110m"))
world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))
shapes_country = world[world.name.isin(region)]
shapes_continent = world[world.continent.isin(region)]
shapes = pd.concat([shapes_country, shapes_continent])
shapes.plot(ax=ax2, edgecolor="k", color="None")
buffer = 0.5
minx, miny, maxx, maxy = (shapes.to_crs(ccrs.PlateCarree()).bounds).values.flatten()
minx, miny = [minx - buffer, miny - buffer]
maxx, maxy = [maxx + buffer, maxy + buffer]
ax2.set_extent([minx, maxx, miny, maxy], crs=ccrs.PlateCarree())
#ax2.set_title("Solar PV Potential Density", fontdict={'fontsize': 18, 'fontweight': 'bold'})
fig.text(0.75, 0.06, '(b) Solar PV Potential Density', ha='center',
            size=18, fontweight='bold')
plt.savefig(filename2, bbox_inches="tight")
Image(filename2)
plt.show()

# First plot
data = onwind.potential / 1000
cmap = "Blues"
projection = ccrs.PlateCarree()
region = ["United Kingdom"]
filename1 = "onwind-gridcell.png"

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 12), subplot_kw={"projection": projection})

plt.rcParams.update({"font.size": 15})
data.plot.imshow(ax=ax1, transform=ccrs.PlateCarree(), cmap=cmap, label="Potential [GW]")
ax1.coastlines()
ax1.add_feature(cartopy.feature.BORDERS.with_scale("110m"))
world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))
shapes_country = world[world.name.isin(region)]
shapes_continent = world[world.continent.isin(region)]
shapes = pd.concat([shapes_country, shapes_continent])
shapes.plot(ax=ax1, edgecolor="k", color="None")
buffer = 0.5
minx, miny, maxx, maxy = (shapes.to_crs(ccrs.PlateCarree()).bounds).values.flatten()
minx, miny = [minx - buffer, miny - buffer]
maxx, maxy = [maxx + buffer, maxy + buffer]
ax1.set_extent([minx, maxx, miny, maxy], crs=ccrs.PlateCarree())
br = gpd.read_file("/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/regions_onshore.geojson")
br.plot(ax=ax1, transform=ccrs.PlateCarree(), facecolor="none", linewidth=0.25, edgecolor="k",
        legend_kwds={"label": r"Potential"})
#ax1.set_title("Onshore Wind Power Potential", fontdict={'fontsize': 18, 'fontweight': 'bold'})
fig.text(0.26, 0.06, '(a) Onshore Wind Power Potential', ha='center',
            size=18, fontweight='bold')
plt.savefig(filename1, bbox_inches="tight")
Image(filename1)

# Second plot
br = gpd.read_file("/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/regions_onshore.geojson")
elec = pypsa.Network("/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec.nc")
n = elec
carrier = "onwind"
cmap = "Blues"
filename2 = "onwind-cell.png"

g = n.generators.loc[n.generators.carrier == carrier]
br = gpd.read_file("/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/regions_onshore.geojson").set_index("name")
br_area = br.to_crs("ESRI:54009")
br_area = br_area.geometry.area * 1e-6
br["p_nom_max"] = g.groupby("bus").sum().p_nom_max / br_area

plt.rcParams.update({"font.size": 15})
br.plot(ax=ax2, column="p_nom_max", transform=ccrs.PlateCarree(), linewidth=0.25,
        edgecolor="k", cmap=cmap,
        vmin=0, vmax=br["p_nom_max"].max(), legend=True,
        legend_kwds={"label": r"Potential Density"})
ax2.coastlines()
ax2.add_feature(cartopy.feature.BORDERS.with_scale("110m"))
world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))
shapes_country = world[world.name.isin(region)]
shapes_continent = world[world.continent.isin(region)]
shapes = pd.concat([shapes_country, shapes_continent])
shapes.plot(ax=ax2, edgecolor="k", color="None")
buffer = 0.5
minx, miny, maxx, maxy = (shapes.to_crs(ccrs.PlateCarree()).bounds).values.flatten()
minx, miny = [minx - buffer, miny - buffer]
maxx, maxy = [maxx + buffer, maxy + buffer]
ax2.set_extent([minx, maxx, miny, maxy], crs=ccrs.PlateCarree())
#ax2.set_title("Onshore wind Power Potential Density", fontdict={'fontsize': 18, 'fontweight': 'bold'})
fig.text(0.75, 0.06, '(b) Onshore wind Power Potential Density', ha='center',
            size=18, fontweight='bold')
plt.savefig(filename2, bbox_inches="tight")
Image(filename2)
plt.show()

"""###**Technical 'Resource' Energy Potential in GB [TWh]**"""

#df.to_csv('/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/bus_station_names.csv')

technical_solar_potential_twh = (
    sum(solar["p_nom_max"] * solar["profile"]).sum() / 10**6
)  # MWh to TWH conversion

technical_onwind_potential_twh = (
    sum(onwind["p_nom_max"] * onwind["profile"]).sum() / 10**6
)  # MWh to TWH conversion

technical_offwind_ac_potential_twh = (
    sum(offwind_ac["p_nom_max"] * offwind_ac["profile"]).sum() / 10**6
)  # MWh to TWH conversion

technical_offwind_dc_potential_twh = (
    sum(offwind_dc["p_nom_max"] * offwind_dc["profile"]).sum() / 10**6
)  # MWh to TWH conversion

technical_hydro_potential_twh = (hydro["inflow"].sum() / 10**6)  # MWh to TWH conversion

print(
    f"Technical Solar PV Potential: {technical_solar_potential_twh.values} \n",
    f"Technical Onshore Wind Potential: {technical_onwind_potential_twh.values} \n",
    f"Technical Offshore Wind (AC) Potential: {technical_offwind_ac_potential_twh.values} \n",
    f"Technical Offshore Wind (DC) Potential: {technical_offwind_dc_potential_twh.values} \n",
    f"Technical Hydro Potential: {technical_hydro_potential_twh.values}",
)

# Solar PV Power
winter_dates = ((solar["profile"].time.dt.month >= 12) | (solar["profile"].time.dt.month <= 2))
spring_dates = (solar["profile"].time.dt.month >= 3) & (solar["profile"].time.dt.month <= 5)
summer_dates = (solar["profile"].time.dt.month >= 6) & (solar["profile"].time.dt.month <= 8)
autumn_dates = (solar["profile"].time.dt.month >= 9) & (solar["profile"].time.dt.month <= 11)
# Select data for each season
winter_data = solar["profile"].sel(time=winter_dates)
spring_data = solar["profile"].sel(time=spring_dates)
summer_data = solar["profile"].sel(time=summer_dates)
autumn_data = solar["profile"].sel(time=autumn_dates)
# Winter
technical_solar_potential_twh = (
    (solar["p_nom_max"] * winter_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_solar_potential_twh), size=10, replace=False)
selected_technical_solar_potential_twh_winter = technical_solar_potential_twh[random_indices]
data_array_winter = selected_technical_solar_potential_twh_winter
# Summer
technical_solar_potential_twh = (
    (solar["p_nom_max"] * summer_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_solar_potential_twh), size=10, replace=False)
selected_technical_solar_potential_twh_summer = technical_solar_potential_twh[random_indices]
data_array_summer = selected_technical_solar_potential_twh_summer
# Spring
technical_solar_potential_twh = (
    (solar["p_nom_max"] * spring_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_solar_potential_twh), size=10, replace=False)
selected_technical_solar_potential_twh_spring = technical_solar_potential_twh[random_indices]
data_array_spring = selected_technical_solar_potential_twh_spring
# autumn
technical_solar_potential_twh = (
    (solar["p_nom_max"] * autumn_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_solar_potential_twh), size=10, replace=False)
selected_technical_solar_potential_twh_autumn = technical_solar_potential_twh[random_indices]
data_array_autumn = selected_technical_solar_potential_twh_autumn

sum_values_winter = data_array_winter.sum(dim='time')
sum_values_summer = data_array_summer.sum(dim='time')
sum_values_spring = data_array_spring.sum(dim='time')
sum_values_autumn = data_array_autumn.sum(dim='time')
# Extract bus labels and sum values for Solar PV
buses = sum_values_winter['bus'].values
sums_winter_PV = sum_values_winter.values
sums_summer_PV = sum_values_summer.values
sums_spring_PV = sum_values_spring.values
sums_autumn_PV = sum_values_autumn.values

# Onshore Wind Power
winter_dates = ((onwind["profile"].time.dt.month >= 12) | (onwind["profile"].time.dt.month <= 2))
spring_dates = (onwind["profile"].time.dt.month >= 3) & (onwind["profile"].time.dt.month <= 5)
summer_dates = (onwind["profile"].time.dt.month >= 6) & (onwind["profile"].time.dt.month <= 8)
autumn_dates = (onwind["profile"].time.dt.month >= 9) & (onwind["profile"].time.dt.month <= 11)
# Select data for each season
winter_data = onwind["profile"].sel(time=winter_dates)
spring_data = onwind["profile"].sel(time=spring_dates)
summer_data = onwind["profile"].sel(time=summer_dates)
autumn_data = onwind["profile"].sel(time=autumn_dates)
# Winter
technical_onwind_potential_twh = (
    (onwind["p_nom_max"] * winter_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_onwind_potential_twh), size=10, replace=False)
selected_technical_onwind_potential_twh_winter = technical_onwind_potential_twh[random_indices]
data_array_winter = selected_technical_onwind_potential_twh_winter
# Summer
technical_onwind_potential_twh = (
    (onwind["p_nom_max"] * summer_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_onwind_potential_twh), size=10, replace=False)
selected_technical_onwind_potential_twh_summer = technical_onwind_potential_twh[random_indices]
data_array_summer = selected_technical_onwind_potential_twh_summer
# Spring
technical_onwind_potential_twh = (
    (onwind["p_nom_max"] * spring_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_onwind_potential_twh), size=10, replace=False)
selected_technical_onwind_potential_twh_spring = technical_onwind_potential_twh[random_indices]
data_array_spring = selected_technical_onwind_potential_twh_spring
# autumn
technical_onwind_potential_twh = (
    (onwind["p_nom_max"] * autumn_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_onwind_potential_twh), size=10, replace=False)
selected_technical_onwind_potential_twh_autumn = technical_onwind_potential_twh[random_indices]
data_array_autumn = selected_technical_onwind_potential_twh_autumn

sum_values_winter = data_array_winter.sum(dim='time')
sum_values_summer = data_array_summer.sum(dim='time')
sum_values_spring = data_array_spring.sum(dim='time')
sum_values_autumn = data_array_autumn.sum(dim='time')
# Extract bus labels and sum values for onwind
buses = sum_values_winter['bus'].values
sums_winter_onwind = sum_values_winter.values
sums_summer_onwind = sum_values_summer.values
sums_spring_onwind = sum_values_spring.values
sums_autumn_onwind = sum_values_autumn.values

# Offshore Wind Power AC
winter_dates = ((offwind_ac["profile"].time.dt.month >= 12) | (offwind_ac["profile"].time.dt.month <= 2))
spring_dates = (offwind_ac["profile"].time.dt.month >= 3) & (offwind_ac["profile"].time.dt.month <= 5)
summer_dates = (offwind_ac["profile"].time.dt.month >= 6) & (offwind_ac["profile"].time.dt.month <= 8)
autumn_dates = (offwind_ac["profile"].time.dt.month >= 9) & (offwind_ac["profile"].time.dt.month <= 11)
# Select data for each season
winter_data = offwind_ac["profile"].sel(time=winter_dates)
spring_data = offwind_ac["profile"].sel(time=spring_dates)
summer_data = offwind_ac["profile"].sel(time=summer_dates)
autumn_data = offwind_ac["profile"].sel(time=autumn_dates)
# Winter
technical_offwind_ac_potential_twh = (
    (offwind_ac["p_nom_max"] * winter_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_offwind_ac_potential_twh), size=10, replace=False)
selected_technical_offwind_ac_potential_twh_winter = technical_offwind_ac_potential_twh[random_indices]
data_array_winter = selected_technical_offwind_ac_potential_twh_winter
# Summer
technical_offwind_ac_potential_twh = (
    (offwind_ac["p_nom_max"] * summer_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_offwind_ac_potential_twh), size=10, replace=False)
selected_technical_offwind_ac_potential_twh_summer = technical_offwind_ac_potential_twh[random_indices]
data_array_summer = selected_technical_offwind_ac_potential_twh_summer
# Spring
technical_offwind_ac_potential_twh = (
    (offwind_ac["p_nom_max"] * spring_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_offwind_ac_potential_twh), size=10, replace=False)
selected_technical_offwind_ac_potential_twh_spring = technical_offwind_ac_potential_twh[random_indices]
data_array_spring = selected_technical_offwind_ac_potential_twh_spring
# autumn
technical_offwind_ac_potential_twh = (
    (offwind_ac["p_nom_max"] * autumn_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_offwind_ac_potential_twh), size=10, replace=False)
selected_technical_offwind_ac_potential_twh_autumn = technical_offwind_ac_potential_twh[random_indices]
data_array_autumn = selected_technical_offwind_ac_potential_twh_autumn

sum_values_winter = data_array_winter.sum(dim='time')
sum_values_summer = data_array_summer.sum(dim='time')
sum_values_spring = data_array_spring.sum(dim='time')
sum_values_autumn = data_array_autumn.sum(dim='time')
# Extract bus labels and sum values for offwind_ac
buses = sum_values_winter['bus'].values
sums_winter_offwind_ac = sum_values_winter.values
sums_summer_offwind_ac = sum_values_summer.values
sums_spring_offwind_ac = sum_values_spring.values
sums_autumn_offwind_ac = sum_values_autumn.values

# Offshore Wind Power DC
winter_dates = ((offwind_dc["profile"].time.dt.month >= 12) | (offwind_dc["profile"].time.dt.month <= 2))
spring_dates = (offwind_dc["profile"].time.dt.month >= 3) & (offwind_dc["profile"].time.dt.month <= 5)
summer_dates = (offwind_dc["profile"].time.dt.month >= 6) & (offwind_dc["profile"].time.dt.month <= 8)
autumn_dates = (offwind_dc["profile"].time.dt.month >= 9) & (offwind_dc["profile"].time.dt.month <= 11)
# Select data for each season
winter_data = offwind_dc["profile"].sel(time=winter_dates)
spring_data = offwind_dc["profile"].sel(time=spring_dates)
summer_data = offwind_dc["profile"].sel(time=summer_dates)
autumn_data = offwind_dc["profile"].sel(time=autumn_dates)
# Winter
technical_offwind_dc_potential_twh = (
    (offwind_dc["p_nom_max"] * winter_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_offwind_dc_potential_twh), size=10, replace=False)
selected_technical_offwind_dc_potential_twh_winter = technical_offwind_dc_potential_twh[random_indices]
data_array_winter = selected_technical_offwind_dc_potential_twh_winter
# Summer
technical_offwind_dc_potential_twh = (
    (offwind_dc["p_nom_max"] * summer_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_offwind_dc_potential_twh), size=10, replace=False)
selected_technical_offwind_dc_potential_twh_summer = technical_offwind_dc_potential_twh[random_indices]
data_array_summer = selected_technical_offwind_dc_potential_twh_summer
# Spring
technical_offwind_dc_potential_twh = (
    (offwind_dc["p_nom_max"] * spring_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_offwind_dc_potential_twh), size=10, replace=False)
selected_technical_offwind_dc_potential_twh_spring = technical_offwind_dc_potential_twh[random_indices]
data_array_spring = selected_technical_offwind_dc_potential_twh_spring
# autumn
technical_offwind_dc_potential_twh = (
    (offwind_dc["p_nom_max"] * autumn_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_offwind_dc_potential_twh), size=10, replace=False)
selected_technical_offwind_dc_potential_twh_autumn = technical_offwind_dc_potential_twh[random_indices]
data_array_autumn = selected_technical_offwind_dc_potential_twh_autumn

sum_values_winter = data_array_winter.sum(dim='time')
sum_values_summer = data_array_summer.sum(dim='time')
sum_values_spring = data_array_spring.sum(dim='time')
sum_values_autumn = data_array_autumn.sum(dim='time')
# Extract bus labels and sum values for offwind_ac
buses = sum_values_winter['bus'].values
sums_winter_offwind_dc = sum_values_winter.values
sums_summer_offwind_dc = sum_values_summer.values
sums_spring_offwind_dc = sum_values_spring.values
sums_autumn_offwind_dc = sum_values_autumn.values

# Hydro Power Inflow Time Series
winter_dates = ((hydro["inflow"].time.dt.month >= 12) | (hydro["inflow"].time.dt.month <= 2))
spring_dates = (hydro["inflow"].time.dt.month >= 3) & (hydro["inflow"].time.dt.month <= 5)
summer_dates = (hydro["inflow"].time.dt.month >= 6) & (hydro["inflow"].time.dt.month <= 8)
autumn_dates = (hydro["inflow"].time.dt.month >= 9) & (hydro["inflow"].time.dt.month <= 11)
# Select data for each season
winter_data = hydro["inflow"].sel(time=winter_dates)
spring_data = hydro["inflow"].sel(time=spring_dates)
summer_data = hydro["inflow"].sel(time=summer_dates)
autumn_data = hydro["inflow"].sel(time=autumn_dates)
# Winter
technical_hydro_potential_twh = (winter_data / 10**6)
# Select 10 random indices
random_indices = np.random.choice(len(technical_hydro_potential_twh), size=10, replace=False)
selected_technical_hydro_potential_twh_winter = technical_hydro_potential_twh[random_indices]
data_array_winter = selected_technical_hydro_potential_twh_winter
# Summer
technical_hydro_potential_twh = (summer_data / 10**6)
# Select 10 random indices
random_indices = np.random.choice(len(technical_hydro_potential_twh), size=10, replace=False)
selected_technical_hydro_potential_twh_summer = technical_hydro_potential_twh[random_indices]
data_array_summer = selected_technical_hydro_potential_twh_summer
# Spring
technical_hydro_potential_twh = (spring_data / 10**6)
# Select 10 random indices
random_indices = np.random.choice(len(technical_hydro_potential_twh), size=10, replace=False)
selected_technical_hydro_potential_twh_spring = technical_hydro_potential_twh[random_indices]
data_array_spring = selected_technical_hydro_potential_twh_spring
# Autumn
technical_hydro_potential_twh = (autumn_data / 10**6)
# Select 10 random indices
random_indices = np.random.choice(len(technical_hydro_potential_twh), size=10, replace=False)
selected_technical_hydro_potential_twh_autumn = technical_hydro_potential_twh[random_indices]
data_array_autumn = selected_technical_hydro_potential_twh_autumn

sum_values_winter = data_array_winter.sum(dim='time')
sum_values_summer = data_array_summer.sum(dim='time')
sum_values_spring = data_array_spring.sum(dim='time')
sum_values_autumn = data_array_autumn.sum(dim='time')
# Extract bus labels and sum values for offwind_ac
plants = sum_values_winter['plant'].values
sums_winter_hydro = sum_values_winter.values
sums_summer_hydro = sum_values_summer.values
sums_spring_hydro = sum_values_spring.values
sums_autumn_hydro = sum_values_autumn.values

# Adding station_bus_number to bus labels
bus_labels = [f'Station_{bus}' for bus in buses]
plant_labels = [f'Plant_{plant}' for plant in plants]
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (16, 12)
fig, axs = plt.subplots(3, 2)
#plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)

# Plot Solar Potential in ax[1]
axs[0, 0].cla()
axs[0, 0].set_facecolor("white")
axs[0, 0].spines[['top', 'right']].set_visible(False)
axs[0, 0].set_ylabel('Solar Potential [TWh]', size=15, fontweight='bold')
#axs[0, 0].set_xlabel('Selected Sub-stations', size=20, fontweight='bold')
bar_width = 0.2
r1 = np.arange(len(bus_labels))
r2 = [x + bar_width for x in r1]
r3 = [x + bar_width for x in r2]
r4 = [x + bar_width for x in r3]

axs[0, 0].bar(r1, sums_winter_PV, color='b', width=bar_width, edgecolor='grey', label='Winter')
axs[0, 0].bar(r2, sums_summer_PV, color='r', width=bar_width, edgecolor='grey', label='Summer')
axs[0, 0].bar(r3, sums_autumn_PV, color='g', width=bar_width, edgecolor='grey', label='Autumn')
axs[0, 0].bar(r4, sums_spring_PV, color='y', width=bar_width, edgecolor='grey', label='Spring')
legend1 = axs[0, 0].legend(loc='best', ncol=2, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
#axs[0, 0].set_title('Technical Solar Potential in the UK', size=20, fontweight='bold')
fig.text(0.25, 0.66, '(a) Technical Solar Potential in the UK', ha='center',
            size=19, fontweight='bold')
#axs[0, 0].tick_params(axis='x', rotation=30, labelsize=20)
axs[0, 0].tick_params(axis='y', rotation=0, labelsize=20)
axs[0, 0].set_xticks([r + 1.5 * bar_width for r in range(len(bus_labels))])
axs[0, 0].set_xticklabels(bus_labels, rotation=30)
#axs[1] = plt.gca()
for spine in axs[0, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0, 0].xaxis.grid(False)
axs[0, 0].yaxis.grid(False)
axs[0, 0].set_yscale('log')

# Plot Onshore Wind Power Potential in ax[2]
axs[0, 1].cla()
axs[0, 1].set_facecolor("white")
axs[0, 1].spines[['top', 'right']].set_visible(False)
axs[0, 1].set_ylabel('Onshore Wind Potential [TWh]', size=15, fontweight='bold')
#axs[0, 1].set_xlabel('Selected Sub-stations', size=20, fontweight='bold')
bar_width = 0.2
r1 = np.arange(len(bus_labels))
r2 = [x + bar_width for x in r1]
r3 = [x + bar_width for x in r2]
r4 = [x + bar_width for x in r3]

axs[0, 1].bar(r1, sums_winter_onwind, color='b', width=bar_width, edgecolor='grey', label='Winter')
axs[0, 1].bar(r2, sums_summer_onwind, color='r', width=bar_width, edgecolor='grey', label='Summer')
axs[0, 1].bar(r3, sums_autumn_onwind, color='g', width=bar_width, edgecolor='grey', label='Autumn')
axs[0, 1].bar(r4, sums_spring_onwind, color='y', width=bar_width, edgecolor='grey', label='Spring')
legend2 = axs[0, 1].legend(loc='best', ncol=2, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
#axs[0, 1].set_title('Technical Onshore Wind Potential in the UK', size=20, fontweight='bold')
fig.text(0.75, 0.66, '(b) Technical Onshore Wind Potential in the UK', ha='center',
            size=19, fontweight='bold')
#axs[0, 1].tick_params(axis='x', rotation=30, labelsize=20)
axs[0, 1].tick_params(axis='y', rotation=0, labelsize=20)
axs[0, 1].set_xticks([r + 1.5 * bar_width for r in range(len(bus_labels))])
axs[0, 1].set_xticklabels(bus_labels, rotation=30)
#axs[1] = plt.gca()
for spine in axs[0, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0, 1].xaxis.grid(False)
axs[0, 1].yaxis.grid(False)
axs[0, 1].set_yscale('log')

# Plot Offshore Wind Power (AC) Potential in ax[3]
axs[1, 0].cla()
axs[1, 0].set_facecolor("white")
axs[1, 0].spines[['top', 'right']].set_visible(False)
axs[1, 0].set_ylabel('Offshore Wind (AC) Potential [TWh]', size=15, fontweight='bold')
axs[1, 0].set_xlabel('Selected Sub-stations', size=20, fontweight='bold')
bar_width = 0.2
r1 = np.arange(len(bus_labels))
r2 = [x + bar_width for x in r1]
r3 = [x + bar_width for x in r2]
r4 = [x + bar_width for x in r3]

axs[1, 0].bar(r1, sums_winter_offwind_ac, color='b', width=bar_width, edgecolor='grey', label='Winter')
axs[1, 0].bar(r2, sums_summer_offwind_ac, color='r', width=bar_width, edgecolor='grey', label='Summer')
axs[1, 0].bar(r3, sums_autumn_offwind_ac, color='g', width=bar_width, edgecolor='grey', label='Autumn')
axs[1, 0].bar(r4, sums_spring_offwind_ac, color='y', width=bar_width, edgecolor='grey', label='Spring')
legend3 = axs[1, 0].legend(loc='best', ncol=2, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend3.get_frame().set_edgecolor('black')
legend3.get_frame().set_linewidth(1)
#axs[1, 0].set_title('Technical Offshore Wind (AC) Potential in the UK', size=20, fontweight='bold')
fig.text(0.25, 0.33, '(c) Technical Offshore Wind (AC) Potential in the UK', ha='center',
            size=19, fontweight='bold')
#axs[0, 0].tick_params(axis='x', rotation=30, labelsize=20)
axs[1, 0].tick_params(axis='y', rotation=0, labelsize=20)
axs[1, 0].set_xticks([r + 1.5 * bar_width for r in range(len(bus_labels))])
axs[1, 0].set_xticklabels(bus_labels, rotation=30)
#axs[1] = plt.gca()
for spine in axs[1, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1, 0].xaxis.grid(False)
axs[1, 0].yaxis.grid(False)
axs[1, 0].set_yscale('log')

# Plot Offshore Wind Power (DC) Potential in ax[4]
axs[1, 1].cla()
axs[1, 1].set_facecolor("white")
axs[1, 1].spines[['top', 'right']].set_visible(False)
axs[1, 1].set_ylabel('Offshore Wind (DC) Potential [TWh]', size=15, fontweight='bold')
axs[1, 1].set_xlabel('Selected Sub-stations', size=20, fontweight='bold')
bar_width = 0.2
r1 = np.arange(len(bus_labels))
r2 = [x + bar_width for x in r1]
r3 = [x + bar_width for x in r2]
r4 = [x + bar_width for x in r3]

axs[1, 1].bar(r1, sums_winter_offwind_dc, color='b', width=bar_width, edgecolor='grey', label='Winter')
axs[1, 1].bar(r2, sums_summer_offwind_dc, color='r', width=bar_width, edgecolor='grey', label='Summer')
axs[1, 1].bar(r3, sums_autumn_offwind_dc, color='g', width=bar_width, edgecolor='grey', label='Autumn')
axs[1, 1].bar(r4, sums_spring_offwind_dc, color='y', width=bar_width, edgecolor='grey', label='Spring')
legend4 = axs[1, 1].legend(loc='best', ncol=2, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend4.get_frame().set_edgecolor('black')
legend4.get_frame().set_linewidth(1)
#axs[1, 1].set_title('Technical Offshore Wind (DC) Potential in the UK', size=20, fontweight='bold')
fig.text(0.75, 0.33, '(d) Technical Offshore Wind (DC) Potential in the UK', ha='center',
            size=19, fontweight='bold')
#axs[0, 0].tick_params(axis='x', rotation=30, labelsize=20)
axs[1, 1].tick_params(axis='y', rotation=0, labelsize=20)
axs[1, 1].set_xticks([r + 1.5 * bar_width for r in range(len(bus_labels))])
axs[1, 1].set_xticklabels(bus_labels, rotation=30)
#axs[1] = plt.gca()
for spine in axs[1, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1, 1].xaxis.grid(False)
axs[1, 1].yaxis.grid(False)
axs[1, 1].set_yscale('log')

# Plot Hydro Inflow Time Series in ax[5]
axs[2, 0].cla()
axs[2, 0].set_facecolor("white")
axs[2, 0].spines[['top', 'right']].set_visible(False)
axs[2, 0].set_ylabel('Hydro Inflow Time Series [TWh]', size=15, fontweight='bold')
axs[2, 0].set_xlabel('Selected Hydro Plants', size=20, fontweight='bold')
bar_width = 0.2
r1 = np.arange(len(bus_labels))
r2 = [x + bar_width for x in r1]
r3 = [x + bar_width for x in r2]
r4 = [x + bar_width for x in r3]

axs[2, 0].bar(r1, sums_winter_hydro, color='b', width=bar_width, edgecolor='grey', label='Winter')
axs[2, 0].bar(r2, sums_summer_hydro, color='r', width=bar_width, edgecolor='grey', label='Summer')
axs[2, 0].bar(r3, sums_autumn_hydro, color='g', width=bar_width, edgecolor='grey', label='Autumn')
axs[2, 0].bar(r4, sums_spring_hydro, color='y', width=bar_width, edgecolor='grey', label='Spring')
legend5 = axs[2, 0].legend(loc='best', ncol=2, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend5.get_frame().set_edgecolor('black')
legend5.get_frame().set_linewidth(1)
#axs[2, 0].set_title('Hydro Inflow Time Series in the UK', size=20, fontweight='bold')
fig.text(0.25, -0.01, '(e) Hydro Inflow Time Series in the UK', ha='center',
            size=19, fontweight='bold')
#axs[0, 0].tick_params(axis='x', rotation=30, labelsize=20)
axs[2, 0].tick_params(axis='y', rotation=0, labelsize=20)
axs[2, 0].set_xticks([r + 1.5 * bar_width for r in range(len(plant_labels))])
axs[2, 0].set_xticklabels(plant_labels, rotation=30)
#axs[1] = plt.gca()
for spine in axs[2, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[2, 0].xaxis.grid(False)
axs[2, 0].yaxis.grid(False)
axs[2, 0].set_yscale('log')

axs[-1, -1].axis('off')

# Save the plot to a directory in Google Drive
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Technical_Potentials_of_Selected_Substations.png')
plt.tight_layout()
plt.subplots_adjust(wspace=0.2, hspace=0.7)
plt.show()

"""**Visualize the Technical Resource Potential For All Renewables**

###**Plot Timeseries to analyse the Seasonality and General Variability**
"""

# Solar PV Power
winter_dates = ((solar["profile"].time.dt.month >= 12) | (solar["profile"].time.dt.month <= 2))
spring_dates = (solar["profile"].time.dt.month >= 3) & (solar["profile"].time.dt.month <= 5)
summer_dates = (solar["profile"].time.dt.month >= 6) & (solar["profile"].time.dt.month <= 8)
autumn_dates = (solar["profile"].time.dt.month >= 9) & (solar["profile"].time.dt.month <= 11)
# Select data for each season
winter_data = solar["profile"].sel(time=winter_dates)
spring_data = solar["profile"].sel(time=spring_dates)
summer_data = solar["profile"].sel(time=summer_dates)
autumn_data = solar["profile"].sel(time=autumn_dates)
# Winter
technical_solar_potential_twh = (
    (solar["p_nom_max"] * winter_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_solar_potential_twh), size=1, replace=False)
selected_technical_solar_potential_twh_winter = technical_solar_potential_twh[random_indices]
data_array_winter = selected_technical_solar_potential_twh_winter
# Summer
technical_solar_potential_twh = (
    (solar["p_nom_max"] * summer_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_solar_potential_twh), size=1, replace=False)
selected_technical_solar_potential_twh_summer = technical_solar_potential_twh[random_indices]
data_array_summer = selected_technical_solar_potential_twh_summer
# Spring
technical_solar_potential_twh = (
    (solar["p_nom_max"] * spring_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_solar_potential_twh), size=1, replace=False)
selected_technical_solar_potential_twh_spring = technical_solar_potential_twh[random_indices]
data_array_spring = selected_technical_solar_potential_twh_spring
# autumn
technical_solar_potential_twh = (
    (solar["p_nom_max"] * autumn_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_solar_potential_twh), size=1, replace=False)
selected_technical_solar_potential_twh_autumn = technical_solar_potential_twh[random_indices]
data_array_autumn = selected_technical_solar_potential_twh_autumn

sum_values_winter = data_array_winter
sum_values_summer = data_array_summer
sum_values_spring = data_array_spring
sum_values_autumn = data_array_autumn
# Extract bus labels and sum values for Solar PV
buses = sum_values_winter['bus'].values
sums_winter_PV = sum_values_winter
sums_summer_PV = sum_values_summer
sums_spring_PV = sum_values_spring
sums_autumn_PV = sum_values_autumn
bus_PV = sum_values_winter.bus

# Onshore Wind Power
winter_dates = ((onwind["profile"].time.dt.month >= 12) | (onwind["profile"].time.dt.month <= 2))
spring_dates = (onwind["profile"].time.dt.month >= 3) & (onwind["profile"].time.dt.month <= 5)
summer_dates = (onwind["profile"].time.dt.month >= 6) & (onwind["profile"].time.dt.month <= 8)
autumn_dates = (onwind["profile"].time.dt.month >= 9) & (onwind["profile"].time.dt.month <= 11)
# Select data for each season
winter_data = onwind["profile"].sel(time=winter_dates)
spring_data = onwind["profile"].sel(time=spring_dates)
summer_data = onwind["profile"].sel(time=summer_dates)
autumn_data = onwind["profile"].sel(time=autumn_dates)
# Winter
technical_onwind_potential_twh = (
    (onwind["p_nom_max"] * winter_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_onwind_potential_twh), size=1, replace=False)
selected_technical_onwind_potential_twh_winter = technical_onwind_potential_twh[random_indices]
data_array_winter = selected_technical_onwind_potential_twh_winter
# Summer
technical_onwind_potential_twh = (
    (onwind["p_nom_max"] * summer_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_onwind_potential_twh), size=1, replace=False)
selected_technical_onwind_potential_twh_summer = technical_onwind_potential_twh[random_indices]
data_array_summer = selected_technical_onwind_potential_twh_summer
# Spring
technical_onwind_potential_twh = (
    (onwind["p_nom_max"] * spring_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_onwind_potential_twh), size=1, replace=False)
selected_technical_onwind_potential_twh_spring = technical_onwind_potential_twh[random_indices]
data_array_spring = selected_technical_onwind_potential_twh_spring
# autumn
technical_onwind_potential_twh = (
    (onwind["p_nom_max"] * autumn_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_onwind_potential_twh), size=1, replace=False)
selected_technical_onwind_potential_twh_autumn = technical_onwind_potential_twh[random_indices]
data_array_autumn = selected_technical_onwind_potential_twh_autumn

sum_values_winter = data_array_winter
sum_values_summer = data_array_summer
sum_values_spring = data_array_spring
sum_values_autumn = data_array_autumn
# Extract bus labels and sum values for onwind
buses = sum_values_winter['bus'].values
sums_winter_onwind = sum_values_winter
sums_summer_onwind = sum_values_summer
sums_spring_onwind = sum_values_spring
sums_autumn_onwind = sum_values_autumn
bus_onwind = sum_values_winter.bus

# Offshore Wind Power AC
winter_dates = ((offwind_ac["profile"].time.dt.month >= 12) | (offwind_ac["profile"].time.dt.month <= 2))
spring_dates = (offwind_ac["profile"].time.dt.month >= 3) & (offwind_ac["profile"].time.dt.month <= 5)
summer_dates = (offwind_ac["profile"].time.dt.month >= 6) & (offwind_ac["profile"].time.dt.month <= 8)
autumn_dates = (offwind_ac["profile"].time.dt.month >= 9) & (offwind_ac["profile"].time.dt.month <= 11)
# Select data for each season
winter_data = offwind_ac["profile"].sel(time=winter_dates)
spring_data = offwind_ac["profile"].sel(time=spring_dates)
summer_data = offwind_ac["profile"].sel(time=summer_dates)
autumn_data = offwind_ac["profile"].sel(time=autumn_dates)
# Winter
technical_offwind_ac_potential_twh = (
    (offwind_ac["p_nom_max"] * winter_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_offwind_ac_potential_twh), size=1, replace=False)
selected_technical_offwind_ac_potential_twh_winter = technical_offwind_ac_potential_twh[random_indices]
data_array_winter = selected_technical_offwind_ac_potential_twh_winter
# Summer
technical_offwind_ac_potential_twh = (
    (offwind_ac["p_nom_max"] * summer_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_offwind_ac_potential_twh), size=1, replace=False)
selected_technical_offwind_ac_potential_twh_summer = technical_offwind_ac_potential_twh[random_indices]
data_array_summer = selected_technical_offwind_ac_potential_twh_summer
# Spring
technical_offwind_ac_potential_twh = (
    (offwind_ac["p_nom_max"] * spring_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_offwind_ac_potential_twh), size=1, replace=False)
selected_technical_offwind_ac_potential_twh_spring = technical_offwind_ac_potential_twh[random_indices]
data_array_spring = selected_technical_offwind_ac_potential_twh_spring
# autumn
technical_offwind_ac_potential_twh = (
    (offwind_ac["p_nom_max"] * autumn_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_offwind_ac_potential_twh), size=1, replace=False)
selected_technical_offwind_ac_potential_twh_autumn = technical_offwind_ac_potential_twh[random_indices]
data_array_autumn = selected_technical_offwind_ac_potential_twh_autumn

sum_values_winter = data_array_winter
sum_values_summer = data_array_summer
sum_values_spring = data_array_spring
sum_values_autumn = data_array_autumn
# Extract bus labels and sum values for offwind_ac
buses = sum_values_winter['bus'].values
sums_winter_offwind_ac = sum_values_winter
sums_summer_offwind_ac = sum_values_summer
sums_spring_offwind_ac = sum_values_spring
sums_autumn_offwind_ac = sum_values_autumn
bus_offwind_ac = sum_values_winter.bus

# Offshore Wind Power DC
winter_dates = ((offwind_dc["profile"].time.dt.month >= 12) | (offwind_dc["profile"].time.dt.month <= 2))
spring_dates = (offwind_dc["profile"].time.dt.month >= 3) & (offwind_dc["profile"].time.dt.month <= 5)
summer_dates = (offwind_dc["profile"].time.dt.month >= 6) & (offwind_dc["profile"].time.dt.month <= 8)
autumn_dates = (offwind_dc["profile"].time.dt.month >= 9) & (offwind_dc["profile"].time.dt.month <= 11)
# Select data for each season
winter_data = offwind_dc["profile"].sel(time=winter_dates)
spring_data = offwind_dc["profile"].sel(time=spring_dates)
summer_data = offwind_dc["profile"].sel(time=summer_dates)
autumn_data = offwind_dc["profile"].sel(time=autumn_dates)
# Winter
technical_offwind_dc_potential_twh = (
    (offwind_dc["p_nom_max"] * winter_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_offwind_dc_potential_twh), size=1, replace=False)
selected_technical_offwind_dc_potential_twh_winter = technical_offwind_dc_potential_twh[random_indices]
data_array_winter = selected_technical_offwind_dc_potential_twh_winter
# Summer
technical_offwind_dc_potential_twh = (
    (offwind_dc["p_nom_max"] * summer_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_offwind_dc_potential_twh), size=1, replace=False)
selected_technical_offwind_dc_potential_twh_summer = technical_offwind_dc_potential_twh[random_indices]
data_array_summer = selected_technical_offwind_dc_potential_twh_summer
# Spring
technical_offwind_dc_potential_twh = (
    (offwind_dc["p_nom_max"] * spring_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_offwind_dc_potential_twh), size=1, replace=False)
selected_technical_offwind_dc_potential_twh_spring = technical_offwind_dc_potential_twh[random_indices]
data_array_spring = selected_technical_offwind_dc_potential_twh_spring
# autumn
technical_offwind_dc_potential_twh = (
    (offwind_dc["p_nom_max"] * autumn_data) / 10**6
)
# Select 10 random indices
random_indices = np.random.choice(len(technical_offwind_dc_potential_twh), size=1, replace=False)
selected_technical_offwind_dc_potential_twh_autumn = technical_offwind_dc_potential_twh[random_indices]
data_array_autumn = selected_technical_offwind_dc_potential_twh_autumn

sum_values_winter = data_array_winter
sum_values_summer = data_array_summer
sum_values_spring = data_array_spring
sum_values_autumn = data_array_autumn
# Extract bus labels and sum values for offwind_ac
buses = sum_values_winter['bus'].values
sums_winter_offwind_dc = sum_values_winter
sums_summer_offwind_dc = sum_values_summer
sums_spring_offwind_dc = sum_values_spring
sums_autumn_offwind_dc = sum_values_autumn
bus_offwind_dc = sum_values_winter.bus

# Hydro Power Inflow Time Series
winter_dates = ((hydro["inflow"].time.dt.month >= 12) | (hydro["inflow"].time.dt.month <= 2))
spring_dates = (hydro["inflow"].time.dt.month >= 3) & (hydro["inflow"].time.dt.month <= 5)
summer_dates = (hydro["inflow"].time.dt.month >= 6) & (hydro["inflow"].time.dt.month <= 8)
autumn_dates = (hydro["inflow"].time.dt.month >= 9) & (hydro["inflow"].time.dt.month <= 11)
# Select data for each season
winter_data = hydro["inflow"].sel(time=winter_dates)
spring_data = hydro["inflow"].sel(time=spring_dates)
summer_data = hydro["inflow"].sel(time=summer_dates)
autumn_data = hydro["inflow"].sel(time=autumn_dates)
# Winter
technical_hydro_potential_twh = (winter_data / 10**6)
# Select 10 random indices
random_indices = np.random.choice(len(technical_hydro_potential_twh), size=1, replace=False)
selected_technical_hydro_potential_twh_winter = technical_hydro_potential_twh[random_indices]
data_array_winter = selected_technical_hydro_potential_twh_winter
# Summer
technical_hydro_potential_twh = (summer_data / 10**6)
# Select 10 random indices
random_indices = np.random.choice(len(technical_hydro_potential_twh), size=1, replace=False)
selected_technical_hydro_potential_twh_summer = technical_hydro_potential_twh[random_indices]
data_array_summer = selected_technical_hydro_potential_twh_summer
# Spring
technical_hydro_potential_twh = (spring_data / 10**6)
# Select 10 random indices
random_indices = np.random.choice(len(technical_hydro_potential_twh), size=1, replace=False)
selected_technical_hydro_potential_twh_spring = technical_hydro_potential_twh[random_indices]
data_array_spring = selected_technical_hydro_potential_twh_spring
# Autumn
technical_hydro_potential_twh = (autumn_data / 10**6)
# Select 10 random indices
random_indices = np.random.choice(len(technical_hydro_potential_twh), size=1, replace=False)
selected_technical_hydro_potential_twh_autumn = technical_hydro_potential_twh[random_indices]
data_array_autumn = selected_technical_hydro_potential_twh_autumn

sum_values_winter = data_array_winter
sum_values_summer = data_array_summer
sum_values_spring = data_array_spring
sum_values_autumn = data_array_autumn
# Extract bus labels and sum values for offwind_ac
plants = sum_values_winter['plant'].values
sums_winter_hydro = sum_values_winter
sums_summer_hydro = sum_values_summer
sums_spring_hydro = sum_values_spring
sums_autumn_hydro = sum_values_autumn
bus_hydro = sum_values_winter.plant

# Adding station_bus_number to bus labels
bus_labels = [f'Station_{bus}' for bus in buses]
plant_labels = [f'Plant_{plant}' for plant in plants]
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (16, 12)
fig, axs = plt.subplots(3, 2)
#plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)

# Plot Solar Potential in ax[1]
axs[0, 0].cla()
axs[0, 0].set_facecolor("white")
axs[0, 0].spines[['top', 'right']].set_visible(False)
axs[0, 0].set_ylabel('Solar Potential [TWh]', size=15, fontweight='bold')
axs[0, 0].set_xlabel('Selected Sub-stations', size=20, fontweight='bold')

axs[0, 0].plot(sums_winter_PV.values.reshape(-1), color='b', label='Winter')
axs[0, 0].plot(sums_summer_PV.values.reshape(-1), color='r', label='Summer')
axs[0, 0].plot(sums_autumn_PV.values.reshape(-1), color='g', label='Autumn')
axs[0, 0].plot(sums_spring_PV.values.reshape(-1), color='y', label='Spring')
legend1 = axs[0, 0].legend(loc='best', ncol=2, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
#axs[0, 0].set_title('Technical Solar Potential in the UK', size=20, fontweight='bold')
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
#axs[0, 0].set_title('Technical Solar Potential in the UK', size=20, fontweight='bold')
fig.text(0.25, 0.66, '(a) Technical Solar Potential in the UK', ha='center',
            size=19, fontweight='bold')
#axs[0, 0].tick_params(axis='x', rotation=30, labelsize=20)
axs[0, 0].tick_params(axis='y', rotation=0, labelsize=20)
#axs[0, 0].set_xticks([r + 1.5 * bar_width for r in range(len(bus_labels))])
#axs[0, 0].set_xticklabels(bus_labels, rotation=30)
#axs[1] = plt.gca()
for spine in axs[0, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0, 0].xaxis.grid(False)
axs[0, 0].yaxis.grid(False)
axs[0, 0].set_yscale('log')

# Plot Onshore Wind Power Potential in ax[2]
axs[0, 1].cla()
axs[0, 1].set_facecolor("white")
axs[0, 1].spines[['top', 'right']].set_visible(False)
axs[0, 1].set_ylabel('Onshore Wind Potential [TWh]', size=15, fontweight='bold')
axs[0, 1].set_xlabel('Selected Sub-stations', size=20, fontweight='bold')

axs[0, 1].plot(sums_winter_onwind.values.reshape(-1), color='b', label='Winter')
axs[0, 1].plot(sums_summer_onwind.values.reshape(-1), color='r', label='Summer')
axs[0, 1].plot(sums_autumn_onwind.values.reshape(-1), color='g', label='Autumn')
axs[0, 1].plot(sums_spring_onwind.values.reshape(-1), color='y', label='Spring')
legend2 = axs[0, 1].legend(loc='best', ncol=2, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
#axs[0, 1].set_title('Technical Onshore Wind Potential in the UK', size=20, fontweight='bold')
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
#axs[0, 1].set_title('Technical Onshore Wind Potential in the UK', size=20, fontweight='bold')
fig.text(0.75, 0.66, '(b) Technical Onshore Wind Potential in the UK', ha='center',
            size=19, fontweight='bold')
#axs[0, 1].tick_params(axis='x', rotation=30, labelsize=20)
axs[0, 1].tick_params(axis='y', rotation=0, labelsize=20)
#axs[0, 1].set_xticks([r + 1.5 * bar_width for r in range(len(bus_labels))])
#axs[0, 1].set_xticklabels(bus_labels, rotation=30)
#axs[1] = plt.gca()
for spine in axs[0, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0, 1].xaxis.grid(False)
axs[0, 1].yaxis.grid(False)
axs[0, 1].set_yscale('log')

# Plot Offshore Wind Power (AC) Potential in ax[3]
axs[1, 0].cla()
axs[1, 0].set_facecolor("white")
axs[1, 0].spines[['top', 'right']].set_visible(False)
axs[1, 0].set_ylabel('Offshore Wind (AC) Potential [TWh]', size=15, fontweight='bold')
axs[1, 0].set_xlabel('Selected Sub-stations', size=20, fontweight='bold')

axs[1, 0].plot(sums_winter_offwind_ac.values.reshape(-1),
               color='b', label='Winter')
axs[1, 0].plot(sums_summer_offwind_ac.values.reshape(-1),
               color='r', label='Summer')
axs[1, 0].plot(sums_autumn_offwind_ac.values.reshape(-1),
               color='g', label='Autumn')
axs[1, 0].plot(sums_spring_offwind_ac.values.reshape(-1),
               color='y', label='Spring')
legend3 = axs[1, 0].legend(loc='best', ncol=2, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
#axs[1, 0].set_title('Technical Offshore Wind (AC) Potential in the UK', size=20, fontweight='bold')
legend3.get_frame().set_edgecolor('black')
legend3.get_frame().set_linewidth(1)
#axs[1, 0].set_title('Technical Offshore Wind (AC) Potential in the UK', size=20, fontweight='bold')
fig.text(0.25, 0.33, '(c) Technical Offshore Wind (AC) Potential in the UK', ha='center',
            size=19, fontweight='bold')
#axs[0, 0].tick_params(axis='x', rotation=30, labelsize=20)
axs[1, 0].tick_params(axis='y', rotation=0, labelsize=20)
#axs[1, 0].set_xticks([r + 1.5 * bar_width for r in range(len(bus_labels))])
#axs[1, 0].set_xticklabels(bus_labels, rotation=30)
#axs[1] = plt.gca()
for spine in axs[1, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1, 0].xaxis.grid(False)
axs[1, 0].yaxis.grid(False)
axs[1, 0].set_yscale('log')

# Plot Offshore Wind Power (DC) Potential in ax[4]
axs[1, 1].cla()
axs[1, 1].set_facecolor("white")
axs[1, 1].spines[['top', 'right']].set_visible(False)
axs[1, 1].set_ylabel('Offshore Wind (DC) Potential [TWh]', size=15, fontweight='bold')
axs[1, 1].set_xlabel('Selected Sub-stations', size=20, fontweight='bold')

bus = bus_offwind_dc
axs[1, 1].plot(sums_winter_offwind_dc.values.reshape(-1),
               color='b', label='Winter')
axs[1, 1].plot(sums_summer_offwind_dc.values.reshape(-1),
               color='r', label='Summer')
axs[1, 1].plot(sums_autumn_offwind_dc.values.reshape(-1),
               color='g', label='Autumn')
axs[1, 1].plot(sums_spring_offwind_dc.values.reshape(-1),
               color='y', label='Spring')
legend4 = axs[1, 1].legend(loc='best', ncol=2, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
#axs[1, 1].set_title('Technical Offshore Wind (DC) Potential in the UK', size=20, fontweight='bold')
legend4.get_frame().set_edgecolor('black')
legend4.get_frame().set_linewidth(1)
#axs[1, 1].set_title('Technical Offshore Wind (DC) Potential in the UK', size=20, fontweight='bold')
fig.text(0.75, 0.33, '(d) Technical Offshore Wind (DC) Potential in the UK', ha='center',
            size=19, fontweight='bold')
#axs[0, 0].tick_params(axis='x', rotation=30, labelsize=20)
axs[1, 1].tick_params(axis='y', rotation=0, labelsize=20)
#axs[1, 1].set_xticks([r + 1.5 * bar_width for r in range(len(bus_labels))])
#axs[1, 1].set_xticklabels(bus_labels, rotation=30)
#axs[1] = plt.gca()
for spine in axs[1, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1, 1].xaxis.grid(False)
axs[1, 1].yaxis.grid(False)
axs[1, 1].set_yscale('log')

# Plot Hydro Inflow Time Series in ax[5]
axs[2, 0].cla()
axs[2, 0].set_facecolor("white")
axs[2, 0].spines[['top', 'right']].set_visible(False)
axs[2, 0].set_ylabel('Hydro Inflow Time Series [TWh]', size=15, fontweight='bold')
axs[2, 0].set_xlabel('Selected Hydro Plants', size=20, fontweight='bold')

bus = bus_hydro
axs[2, 0].plot(sums_winter_hydro.values.reshape(-1), color='b',
               label='Winter')
axs[2, 0].plot(sums_summer_hydro.values.reshape(-1), color='r',
               label='Summer')
axs[2, 0].plot(sums_autumn_hydro.values.reshape(-1),
               color='g', label='Autumn')
axs[2, 0].plot(sums_spring_hydro.values.reshape(-1),
               color='y', label='Spring')
legend5 = axs[2, 0].legend(loc='best', ncol=2, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
#axs[2, 0].set_title('Hydro Inflow Time Series in the UK', size=20, fontweight='bold')
legend5.get_frame().set_edgecolor('black')
legend5.get_frame().set_linewidth(1)
#axs[2, 0].set_title('Hydro Inflow Time Series in the UK', size=20, fontweight='bold')
fig.text(0.25, -0.01, '(e) Hydro Inflow Time Series in the UK', ha='center',
            size=19, fontweight='bold')
#axs[0, 0].tick_params(axis='x', rotation=30, labelsize=20)
axs[2, 0].tick_params(axis='y', rotation=0, labelsize=20)
#axs[2, 0].set_xticks([r + 1.5 * bar_width for r in range(len(plant_labels))])
#axs[2, 0].set_xticklabels(plant_labels, rotation=30)
#axs[1] = plt.gca()
for spine in axs[2, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[2, 0].xaxis.grid(False)
axs[2, 0].yaxis.grid(False)
axs[2, 0].set_yscale('log')

axs[-1, -1].axis('off')

# Save the plot to a directory in Google Drive
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Technical_Potentials_of_Selected_Substations2.png')
plt.tight_layout()
plt.subplots_adjust(wspace=0.3, hspace=0.7)
plt.show()

"""#**Technical Validation of Renewable Potential and Feed-in Time Series**

###**Network Analysis Comparison between OSM and ENTSOE Data**

- Network data were extracted from two primary sources: OpenStreetMap (OSM) and the European Network of Transmission System Operators for Electricity (ENTSOE).

- The aim is to explore the differences and similarities between these datasets to gain insights into grid topology and capacity.

- Data Sources:
**OpenStreetMap (OSM):** OSM is a collaborative mapping platform that provides open-access geographical data.

**ENTSOE:** ENTSOE represents a European organization of transmission system operators in the field of electricity. The ENTSOE dataset used here is based on their official data sources.

**CRS Check**

- There is a need to confirm that the length of lines in OSM data corresponds to the lines length measured on google maps. Lines length measured manually on google maps can be reproduced using geopy.
"""

# loading the data into variables
entsoe = pypsa.Network("/content/gdrive/MyDrive/Energy_System_RL_Modeling_Data/elec-entsoe.nc")
osm = pypsa.Network("/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec.nc")

# filter for ac lines and voltage greater than or equals to 220.0kV
osm_df = osm.lines[(osm.lines['dc'] == False) & (osm.lines['v_nom'] >= 220.0)] \
 [['country', 'length', 'v_nom']].reset_index().drop(['Line'], axis=1)

entsoe_df = entsoe.lines[entsoe.lines['v_nom'] >= 220.0].merge(
    entsoe.buses['country'].reset_index(), how='left', left_on='bus0',right_on='Bus'
    )[['country', 'v_nom', 'length']]
entsoe_df_UK = entsoe_df[entsoe_df['country'] == 'GB']
    # Intercomparison of length in km between OSM and ENTSOE data
osm_country = osm_df.groupby(['country'])['length'].sum().reset_index()
entsoe_country = entsoe_df_UK.groupby(['country'])['length'].sum().reset_index()

# Intercomparison by voltage levels
osm_voltage = osm_df.groupby(['v_nom'])['length'].sum().reset_index()
entsoe_voltage = entsoe_df_UK.groupby(['v_nom'])['length'].sum().reset_index()

# Plot
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (16, 12)
fig, axs = plt.subplots(1, 1)
plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)
bar_width = 0.3
r1 = np.arange(len(osm_voltage.v_nom))
r2 = [x + bar_width for x in r1]
axs.cla()
axs.set_facecolor("white")
axs.spines[['top', 'right']].set_visible(False)
axs.set_ylabel('Length [km]', size=30, fontweight='bold')
axs.set_xlabel('Voltage [kV]', size=30, fontweight='bold')

axs.bar(r1, osm_voltage.length, width=bar_width, color='darkorange', edgecolor='grey',
        label='PyPSA Earth Model Data')
axs.bar(r2, entsoe_voltage.length, width=bar_width, color='olive', edgecolor='grey',
        label='ENTSOE Data')
legend = axs.legend(loc='best', ncol=1, frameon=True, fontsize='15',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
axs.tick_params(axis='x', rotation=0, labelsize=25)
axs.tick_params(axis='y', rotation=0, labelsize=25)
axs.set_xticks([r + 0.5 * bar_width for r in range(len(osm_voltage.v_nom))])
axs.set_xticklabels(osm_voltage.v_nom, rotation=0)
#axs[1] = plt.gca()
for spine in axs.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs.xaxis.grid(False)
axs.yaxis.grid(False)
#axs.set_yscale('log')

# Save the plot to a directory in Google Drive
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Technical_Validation_of_Installed_Capacity.png')
plt.tight_layout()
plt.show()

"""**Furter Validation Using Base Network CSV Data Representing the Base Network Lines**

In this section, the cleaned OSM data are used to draw plots of the entire network, to reproduce the image available from the UK ESO (https://www.nationalgrid.com/electricity-transmission/network-and-infrastructure/network-route-maps) and verify the quality of the pypsa-earth model.
"""

# Clean Data
path_lin_clean = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/all_clean_lines.geojson"
# Load clean, and country shapefiles with GeoPandas.
UK_osm_clean_lines = gpd.read_file(path_lin_clean).set_crs(epsg=4326, inplace=True)
#UK_osm_clean_lines["reprojected_length"] = UK_osm_clean_lines.to_crs("EPSG:4326").length
UK_osm_clean_lines["geometry"] = UK_osm_clean_lines["geometry"].apply(make_valid)
path_sub_clean = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/all_clean_substations.geojson"
df_substations_osm_clean = gpd.read_file(path_sub_clean).set_crs(epsg=4326, inplace=True)
df_substations_osm_clean["geometry"] = df_substations_osm_clean["geometry"].apply(
    make_valid
)
# path of the country shapes
path_country_shapes = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/country_shapes.geojson"
UK_country_shape = gpd.read_file(path_country_shapes)

# Calculate voltage levels for substations and lines
voltage_substations = df_substations_osm_clean.voltage.unique()
voltage_substations.sort()
unique_voltages = UK_osm_clean_lines.voltage.unique()
unique_voltages.sort()

unique_voltages = UK_osm_clean_lines.voltage.unique()
unique_voltages.sort()
# Specify colors for voltage levels-Specify color array by voltage level
color_voltages = ["brown", "blue", "yellow", "gray", "pink", "green", "red", "orange",
    "purple", "white", "cyan", "magenta", "lime", "navy", "olive", "teal", "black"]
voltage_to_color = {v: c for (v, c) in zip(voltage_substations, color_voltages)}

#  Plot the voltage levels for substation & lines on the map of UK
UK_shape = UK_country_shape.set_index("name").geometry
# add tolerance to bounds
tol = 0.3
bounds_mod = UK_country_shape.boundary.bounds
bounds_mod["minx"] -= tol  # reduce minx
bounds_mod["miny"] -= tol  # reduce miny
bounds_mod["maxx"] += tol  # increase maxx
bounds_mod["maxy"] += tol  # increase maxy
# reorder bounds to comply with extend function (x0, x1, y0, y1)
extent_list = (
    float(bounds_mod["minx"]),
    float(bounds_mod["maxx"]),
    float(bounds_mod["miny"]),
    float(bounds_mod["maxy"]),
)
# get the structure of the background data to plot
imagery = OSM()
max_width = 25  # max width of the figure
max_height = 25  # max height of the figure
# calculate figure size with appropriate multiplier to adhere to the desired width/height
multiplier = min(
    max_width / (extent_list[1] - extent_list[0]),
    max_height / (extent_list[3] - extent_list[2]),
)
figsize = (
    (extent_list[1] - extent_list[0]) * multiplier,
    (extent_list[3] - extent_list[2]) * multiplier,
)

# create an auxiliary dataframe for the substations with the desired crs and color properties
df_substations_osm_clean_plot = df_substations_osm_clean.to_crs(imagery.crs)
# specify the color of the nodes
df_substations_osm_clean_plot["color"] = df_substations_osm_clean_plot.voltage.apply(
    lambda x: voltage_to_color[x]
)
# create an auxiliary dataframe for the lines with the desired crs and properties
df_lines_osm_clean_plot = UK_osm_clean_lines.to_crs(imagery.crs)
df_lines_osm_clean_plot[
    "centroids"
] = df_lines_osm_clean_plot.geometry.boundary.centroid  # get the centroids of the line
df_lines_osm_clean_plot["color"] = df_lines_osm_clean_plot.voltage.apply(
    lambda x: voltage_to_color[x]
)
### 1.1.5 side by side comparison with local data source
max_width = 15  # max width of the figure
max_height = 15  # max height of the figure
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
img = plt.imread(f'{output_dir}/Technical_Validation_of_Installed_Capacity.png')
fig = plt.figure(figsize=figsize)
ax = fig.add_subplot(1, 2, 1, projection=imagery.crs)  # specify projection
ax.set_extent(extent_list, ccrs.PlateCarree())  # specify the location of the image
ax.add_image(imagery, 7)  # add the background image
# draw the substations
df_substations_osm_clean_plot.plot(color=df_substations_osm_clean_plot.color, ax=ax)
# draw the lines
df_lines_osm_clean_plot.plot(color=df_lines_osm_clean_plot.color, ax=ax)
fig.add_subplot(1, 2, 2)
imgplot = plt.imshow(img)

"""###**Technical Validation of UK's Installed Capacity**

- Comparison Between Conventional and Low-Carbon Generators

1. PyPSA Earth Model Output for 2022

2. IRENA Electricity Installed Capacity for 2022

3. ESO Historic Generation Mix for 2022
"""

year_select = 2021
IRENA_path = "/content/gdrive/MyDrive/Energy_System_RL_Modeling_Data/ELECSTAT-C_20240603-123501.csv" # change path to match downloaded file
df_irena = pd.read_csv(IRENA_path, skiprows=2, encoding="latin-1")
df_irena = df_irena[df_irena.loc[:, "Year"] == year_select]
#df_irena = df_irena.iloc[:, [0, 1, 2, 4]]
df_irena["alpha2"] = df_irena.loc[:, "Country/area"].apply(
    lambda x: x
)
df_irena['alpha2'] = 'GB'
"Loads the PyPSA generators data -Load data from the network and create"
# normalized dataframe"
addelectricity_network_path = '/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec.nc'
pypsa_network = pypsa.Network(addelectricity_network_path)

# statistics of non-storage units
installed_capacity_nostorages = pypsa_network.generators.copy()
# add country column
installed_capacity_nostorages["alpha2"] = installed_capacity_nostorages.bus.map(
    lambda x: pypsa_network.buses.country.loc[x]
)
installed_capacity_nostorages.loc[
    installed_capacity_nostorages["carrier"].isin(["ror"]), "carrier"
] = "hydro"
installed_capacity_nostorages.loc[
    installed_capacity_nostorages["carrier"] == "onwind", "carrier"
] = "onshore wind"
installed_capacity_nostorages.loc[
    installed_capacity_nostorages["carrier"].isin(["offwind-ac", "off-shore-dc"]),
    "carrier",
] = "offshore wind"
installed_capacity_nostorages.loc[
    installed_capacity_nostorages["carrier"].isin(["CCGT", "OCGT"]), "carrier"
] = "gas"
installed_capacity_nostorages.loc[
    installed_capacity_nostorages["carrier"] == "onwind", "carrier"
] = "wind"
installed_capacity_nostorages_select = installed_capacity_nostorages.loc[
    :, ["alpha2", "carrier", "p_nom"]
]

# statistics of storage units
installed_capacity_storages = pypsa_network.storage_units.copy()
# add country column
installed_capacity_storages["alpha2"] = installed_capacity_storages.bus.map(
    lambda x: pypsa_network.buses.country.loc[x]
)
installed_capacity_storages.loc[
    installed_capacity_storages["carrier"] == "PHS", "carrier"
] = "hydro"
installed_capacity_storages_select = installed_capacity_storages.loc[
    :, ["alpha2", "carrier", "p_nom"]
]

installed_capacity_raw = pd.concat(
    [installed_capacity_storages_select, installed_capacity_nostorages_select]
)
installed_capacity = installed_capacity_raw.groupby(["alpha2", "carrier"])[
    "p_nom"
].sum()
installed_capacity.groupby("carrier").sum()

# Load PyPSA powerplant data to crosscheck data from the network
powerplants_data = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/powerplants.csv"
available_generators = pd.read_csv(powerplants_data)
installed_capacity_resources = available_generators.groupby(["Country", "Fueltype"])[
    "Capacity"
].sum()
installed_capacity_resources.groupby(["Fueltype"]).sum()
year_owid = 2022  # option
country_list = installed_capacity_nostorages.alpha2.unique()
# Process IRENA data to match PyPSA standard
# copy IRENA dataset
df = df_irena.copy()
# Process technologies
df.loc[
    df["Technology"].isin(["Solar photovoltaic", "Solar thermal energy"]), "Technology"
] = "solar"
df.loc[df["Technology"].isin(["Onshore wind energy"]), "Technology"] = "onshore wind"
df.loc[df["Technology"].isin(["Offshore wind energy"]), "Technology"] = "offshore wind"
df.loc[
    df["Technology"].isin(
        ["Renewable hydropower", "Mixed Hydro Plants", "Pumped storage"]
    ),
    "Technology",
] = "hydro"
df.loc[
    df["Technology"].isin(["Other non-renewable energy", "Marine energy"]), "Technology"
] = "other"
df.loc[
    df["Technology"].isin(["Liquid biofuels", "Biogas", "Solid biofuels"]), "Technology"
] = "bioenergy"
df.loc[df["Technology"].isin(["Geothermal energy"]), "Technology"] = "geothermal"
df.loc[df["Technology"].isin(["Natural gas"]), "Technology"] = "gas"
df.loc[df["Technology"].isin(["Renewable municipal waste"]), "Technology"] = "waste"
df.loc[df["Technology"].isin(["Coal and peat"]), "Technology"] = "coal"
df.loc[df["Technology"].isin(["Oil", "Fossil fuels n.e.s."]), "Technology"] = "oil"
df = df[df.alpha2.isin(country_list)]
df = df[df['Data Type'] == 'Electricity Installed Capacity (MW)']
df["p_nom"] = pd.to_numeric(
    df["Electricity statistics"], errors="coerce"
)
installed_capacity_irena = (
    df.rename(columns={"Technology": "carrier"})
    .groupby(["alpha2", "carrier"])["p_nom"]
    .sum()
)

# ESO Historic Generation Mix
df_All_2021 = pd.read_csv('/content/gdrive/MyDrive/Energy_System_RL_Modeling_Data/ESO_Historic_Generation_Mix_GB_Demand_System_Prices_2022.csv')
df_All_2021['DATETIME'] = pd.to_datetime(df_All_2021['DATETIME'])
df_All_2021.set_index('DATETIME', inplace=True)
df_All_2021_hourly = df_All_2021.resample('H').mean()
df_All_2021_hourly.reset_index(inplace=True)
# Process ESO GB data to match PyPSA standard
df = df_All_2021_hourly.copy()
# Process technologies
selected_columns = df[['GAS', 'COAL', 'NUCLEAR', 'HYDRO', 'BIOMASS']]
# Step 2: Rename the selected columns
renamed_columns = selected_columns.rename(columns={
    'GAS': 'gas',
    'COAL': 'coal',
    'NUCLEAR': 'nuclear',
    'HYDRO': 'hydro',
    'BIOMASS': 'biomass'
})
# Step 3: Find the maximum values for the renamed columns
max_values = renamed_columns.max()

# Step 4: Create a new DataFrame with the specified structure
technology = ['gas', 'coal', 'nuclear', 'hydro', 'biomass']
p_nom_values = [max_values['gas'], max_values['coal'], max_values['nuclear'], max_values['hydro'], max_values['biomass']]
alpha2_values = ['GB'] * len(technology)
df = pd.DataFrame({
    'Technology': technology,
    'p_nom': p_nom_values,
    'alpha2': alpha2_values
})
installed_capacity_eso = (
    df.rename(columns={"Technology": "carrier"})
    .groupby(["alpha2", "carrier"])["p_nom"]
    .sum()
)
# Merge datasets by carrier
gb_ic = installed_capacity_irena.groupby("carrier").sum()
gb_ic = gb_ic.rename(index={"bioenergy": "Biomass"})
gb_ic.index = gb_ic.index.str.capitalize()
gb_eso = installed_capacity_eso.groupby("carrier").sum()
gb_eso.index = gb_eso.index.str.capitalize()
gb_eso = gb_eso.sort_index()
gb_pypsa = installed_capacity.groupby("carrier").sum()
if "load" in gb_pypsa.index:
    gb_pypsa = gb_pypsa.drop("load")
gb_pypsa.index = gb_pypsa.index.str.capitalize()
# Sorting and dropping
gb_ic = gb_ic.drop("Waste")
gb_ic = gb_ic.drop("Other")
gb_ic = gb_ic.drop("Total non-renewable")
gb_ic = gb_ic.drop("Total renewable")
gb_ic = gb_ic.drop("Geothermal")
gb_ic = gb_ic.drop("Offshore wind")
gb_ic = gb_ic.drop("Onshore wind")
gb_ic = gb_ic.drop("Solar")
gb_ic = gb_ic.drop("Oil")
gb_ic = gb_ic.sort_index()
gb_pypsa = gb_pypsa.drop("Offshore wind")
gb_pypsa = gb_pypsa.drop("Offwind-dc")
gb_pypsa = gb_pypsa.drop("Onshore wind")
gb_pypsa = gb_pypsa.drop("Solar")
gb_pypsa = gb_pypsa.drop("Oil")
gb_pypsa = gb_pypsa.sort_index()
# Plot
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (16, 12)
fig, axs = plt.subplots(1, 1)
plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)

axs.cla()
axs.set_facecolor("white")
axs.spines[['top', 'right']].set_visible(False)
axs.set_ylabel('Capacity [MW]', size=20, fontweight='bold')
axs.set_xlabel('Technology', size=25, fontweight='bold')
#axs[0, 0].set_xlabel('Selected Sub-stations', size=20, fontweight='bold')
bar_width = 0.2
tech = ['Biomass', 'Coal', 'Gas', 'Hydro', 'Nuclear']
r1 = np.arange(len(tech))
r2 = [x + bar_width for x in r1]
r3 = [x + bar_width for x in r2]

#ax = gb_compare.plot.bar(
    #ylabel="Capacity [MW]", xlabel="Technology", figsize=(10, 4)
#).set(xlabel=None)

axs.bar(r1, gb_pypsa, color='b', width=bar_width, edgecolor='grey', label='PyPSA Earth Model Output 2022')
axs.bar(r2, gb_eso, color='r', width=bar_width, edgecolor='grey', label='UK ESO Data 2022')
axs.bar(r3, gb_ic, color='g', width=bar_width, edgecolor='grey', label='IRENA 2021')
legend = axs.legend(loc='best', ncol=1, frameon=True, fontsize='14',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
axs.tick_params(axis='x', rotation=30, labelsize=20)
axs.tick_params(axis='y', rotation=0, labelsize=20)
axs.set_xticks([r + 1.5 * bar_width for r in range(len(tech))])
axs.set_xticklabels(tech, rotation=30)
#axs[1] = plt.gca()
for spine in axs.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs.xaxis.grid(False)
axs.yaxis.grid(False)
axs.set_yscale('log')

# Save the plot to a directory in Google Drive
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Technical_Validation_of_Installed_Capacity.png')
plt.tight_layout()
plt.show()

"""###**Technical Validation of UK's Electricity load Demand**


We compare with Our World in Data -

which is retrieved from their GitHub: https://github.com/owid/energy-data/tree/master

Web interface: https://ourworldindata.org/energy

The data sources include:

- Energy consumption (primary energy, energy mix and energy intensity) sourced from a combination of three sources‚Äîthe BP Statistical Review of World Energy, the EIA and the SHIFT Data Portal.
    
- Electricity generation (electricity generation, and electricity mix) sourced from a combination of three sources‚Äîthe BP Statistical Review of World Energy, the Ember ‚Äì Data Explorer and the Ember European Electricity Review.

- Other variables: collected from a variety of sources (United Nations, World Bank, Gapminder, Maddison Project Database, etc.).


"""

url = "https://nyc3.digitaloceanspaces.com/owid-public/data/energy/owid-energy-data.csv"
df = pd.read_csv(url)
df = df.loc[:, ["iso_code", "country", "year", "electricity_demand"]]
df = df[df["iso_code"].notna()]  # removes antartica
df['iso_code_2'] = df['iso_code'].str[:-1]
electricity_demand_owid = df

# PyPSA network - Requires a solved or unsolved network.
solved_network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec.nc"
pypsa_network = pypsa.Network(solved_network_path)
electricity_demand_pypsa = pypsa_network.loads_t.p_set
current_columns = electricity_demand_pypsa.columns
new_columns = ['GBR_' + str(col) for col in current_columns]
electricity_demand_pypsa.columns = new_columns
electricity_demand_pypsa.columns.name = 'Load'
electricity_demand_pypsa.head(2)

# Reduce "Our World in Data" to contain the same countries as PyPSA
country_in_network = (
    electricity_demand_pypsa.columns.to_frame()["Load"].apply(lambda x: x[0:2]).values
)
electricity_demand_owid_mini = electricity_demand_owid[
    electricity_demand_owid["iso_code_2"].isin(country_in_network)
]
# Create total electric demand in TWh from OWID for year of interest
year_owid = 2025  # option
df = electricity_demand_owid_mini
df = df[df["year"] == year_owid]
electricity_demand_owid_mini = df

# Create total electric demand in TWh from PyPSA for chosen demand year
electricity_demand_pypsa.columns = (
    electricity_demand_pypsa.columns.to_frame()["Load"].apply(lambda x: x[0:2]).values
)
# Align PyPSA dataframe to 'Our World in Data'
df = electricity_demand_pypsa
df = pd.DataFrame(
    (df.sum().T.groupby([df.columns]).sum() / 10**6).round(2)
)  # MWh to TWh
df = df.reset_index()
df = df.rename(columns={0: "electricity_demand", "index": "iso_code_2"})
df["year"] = "2025"
df["iso_code"] = "Great Britain"
map_dic = pd.Series(
    electricity_demand_owid_mini.country.values,
    index=electricity_demand_owid_mini.iso_code_2,
).to_dict()
df["country"] = df["iso_code_2"].map(map_dic)
electricity_demand_pypsa = df
electricity_demand_pypsa.head(2)
# Merge dataframes
h = '2025'
electricity_demand_pypsa["source"] = f"PyPSA {h}"
electricity_demand_owid_mini["source"] = f"Our World in Data {year_owid}"
df_merge = pd.concat([electricity_demand_pypsa, electricity_demand_owid_mini])
GB_total_consumption = (
    df_merge.groupby(by="source").sum().drop(columns="year").reset_index()
)
print(GB_total_consumption.to_markdown())

# Plot
sns.set_theme(style='white')
plt.rcParams["figure.figsize"] = (5, 5)
fig, axs = plt.subplots(1, 1)
plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)
df_2dhist = pd.DataFrame({
    x_label: grp['iso_code'].value_counts()
    for x_label, grp in GB_total_consumption.groupby('source')
})
# Plot heatmap
sns.heatmap(df_2dhist, cmap='viridis', ax=axs, cbar=True)
# Customize the plot
axs.set_facecolor("white")
axs.spines['top'].set_visible(False)
axs.spines['right'].set_visible(False)
axs.set_ylabel('Country', size=20, fontweight='bold')
axs.set_xlabel('Data Source', size=20, fontweight='bold')
for spine in axs.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs.xaxis.grid(False)
axs.yaxis.grid(False)
# Save the plot
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Technical_Validation_of_Installed_Capacity.png', bbox_inches='tight')
plt.tight_layout()
plt.show()

"""###**Technical Validation of the Renewable Potentials in the UK**"""

solar_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/profile_solar.nc"
solar = xr.open_dataset(solar_path)
onwind_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/profile_onwind.nc"
wind = xr.open_dataset(onwind_path)
# Calculate pypsa-earth technical potentials
technical_solar_potential_twh = (
    sum(solar["p_nom_max"] * solar["profile"]).sum() / 10**6
)  # MWh to TWH conversion
technical_wind_potential_twh = (
    sum(wind["p_nom_max"] * wind["profile"]).sum() / 10**6
)  # MWh to TWH conversion
print(
    "Socio-technical solar potential UK with exclusion area - PyPSA 2022:",
    technical_solar_potential_twh.values.round(),
    "TWh",
)
print(
    "Socio-technical wind potential UK with exclusion area - PyPSA 2022:",
    technical_wind_potential_twh.values.round(),
    "TWh",
)

"""###**Visualize the Base Network**"""

network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/base.nc"
n_base = pypsa.Network(network_path)
n_base

"""###**Visualize the Network after adding electrical generators, existing hydro storage, renewable generator profiles and loads units to a base network topology**"""

network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec.nc"
n_elec = pypsa.Network(network_path)
n_elec

# base_network file path
network_path_b = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec.nc"
# path of the country shapes
path_country_shapes = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/country_shapes.geojson"
# path of the off shore shapes
path_off_shore_shapes = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/offshore_shapes.geojson"
# path of the gadm shapes
path_gadm_shapes = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/gadm_shapes.geojson"
countries = gpd.read_file(path_country_shapes)
off_shore = gpd.read_file(path_off_shore_shapes)
gadm = gpd.read_file(path_gadm_shapes)
# base_network PyPSA model
n_b = pypsa.Network(network_path_b)
lines_raw = n_b.lines.copy()
lines_raw["geometry"] = lines_raw["geometry"].map(loads)
lines = gpd.GeoDataFrame(geometry=lines_raw.geometry, crs="epsg:4326")
buses_raw = n_b.buses.copy()
buses_raw["geometry"] = gpd.points_from_xy(buses_raw.lon, buses_raw.lat)
buses = gpd.GeoDataFrame(geometry=buses_raw.geometry, crs="epsg:4326")
# transformer dataframe
patht = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/all_transformers_build_network.csv"
transformer_b = gpd.read_file(
    patht, GEOM_POSSIBLE_NAMES="geometry", KEEP_GEOM_COLUMNS="NO"
).set_crs(epsg=4326, inplace=True)
imagery = OSM()
#ax = fig.add_subplot(1, 2, 1, projection=imagery.crs)  # specify projection
fig, ax = plt.subplots(1, 1, figsize=(15, 10), subplot_kw={'projection': ccrs.PlateCarree()})
ax = countries.plot(ax=ax, color="lightskyblue")
ax.set_extent(extent_list, crs=ccrs.PlateCarree())
ax.add_image(imagery, 7)
#off_shore.plot(ax=ax)
buses.plot(ax=ax, color="black", label="Substations", alpha=0.9,
           markersize=10)
lines.plot(ax=ax, color="blue", label="Transmission Lines", markersize=5, alpha=0.8)
transformer_b.plot(ax=ax, color="red", label="Transformers", markersize=10, alpha=0.6)
#plt.title("Base Network - Great Britain", fontsize=18, fontweight='bold')
legend = plt.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
for text in legend.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
#plt.axis("off")
plt.savefig("Base_Network_GB_2.png", dpi=dpi, bbox_inches="tight")

"""**Visualize the Simplied Network**"""

network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec_s.nc"
n_elec_s = pypsa.Network(network_path)
n_elec_s

# base_network file path
network_path_b = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec_s.nc"
# path of the country shapes
path_country_shapes = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/country_shapes.geojson"
# path of the off shore shapes
path_off_shore_shapes = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/offshore_shapes.geojson"
# path of the gadm shapes
path_gadm_shapes = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/gadm_shapes.geojson"
countries = gpd.read_file(path_country_shapes)
off_shore = gpd.read_file(path_off_shore_shapes)
gadm = gpd.read_file(path_gadm_shapes)
# base_network PyPSA model
#n_b = pypsa.Network(network_path_b)
buses_s = n_elec_s.buses
buses_s["geometry"] = gpd.points_from_xy(buses_s.x, buses_s.y)
buses_s = gpd.GeoDataFrame(buses_s, crs="epsg:4326")
# lines dataframe
lines_s = n_elec_s.lines
lines_s["geometry"] = lines_s.apply(
    lambda x: LineString(
        [buses_s.loc[x["bus0"], "geometry"], buses_s.loc[x["bus1"], "geometry"]]
    ),
    axis=1,
)
lines_s = gpd.GeoDataFrame(lines_s, crs="epsg:4326")
imagery = OSM()
#ax = fig.add_subplot(1, 2, 1, projection=imagery.crs)  # specify projection
fig, ax = plt.subplots(1, 1, figsize=(15, 10), subplot_kw={'projection': ccrs.PlateCarree()})
ax = countries.plot(ax=ax, color="lightskyblue")
ax.set_extent(extent_list, crs=ccrs.PlateCarree())
ax.add_image(imagery, 7)
#off_shore.plot(ax=ax)
buses_s.plot(ax=ax, color="black", label="Substations", alpha=0.9,
           markersize=10)
lines_s.plot(ax=ax, color="blue", label="Transmission Lines", markersize=5, alpha=0.8)
legend = plt.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
for text in legend.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
#plt.axis("off")
plt.savefig("Base_Network_simplified.png", dpi=dpi, bbox_inches="tight")

sns.set_theme(style='whitegrid')
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 10), subplot_kw={'projection': ccrs.PlateCarree()})
plt.subplots_adjust(wspace=0.1, hspace=0.1)
plt.autoscale(tight=True)
ax1.cla()
ax1.set_facecolor("white")
ax1.spines[['top', 'right']].set_visible(False)
ax1 = countries.plot(ax=ax1, color="lightskyblue")
ax1.set_extent(extent_list, crs=ccrs.PlateCarree())
ax1.add_image(imagery, 7)
#off_shore.plot(ax=ax)
buses.plot(ax=ax1, color="black", label="Substations", alpha=0.9,
           markersize=10)
lines.plot(ax=ax1, color="blue", label="Transmission Lines", markersize=5, alpha=0.8)
transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
#ax1.set_title('Base Network', size=20, fontweight='bold')
fig.text(0.28, 0.05, '(a) Base Network', ha='center',
            size=18, fontweight='bold')
legend1 = ax1.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
for text in legend1.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)

ax2.cla()
ax2.set_facecolor("white")
ax2.spines[['top', 'right']].set_visible(False)
ax2 = countries.plot(ax=ax2, color="lightskyblue")
ax2.set_extent(extent_list, crs=ccrs.PlateCarree())
ax2.add_image(imagery, 7)
#off_shore.plot(ax=ax)
buses_s.plot(ax=ax2, color="black", label="Substations", alpha=0.9,
           markersize=10)
lines_s.plot(ax=ax2, color="blue", label="Transmission Lines", markersize=5, alpha=0.8)
#transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
#ax2.set_title('Simplified Base Network', size=20, fontweight='bold')
fig.text(0.74, 0.05, '(b) Simplified Base Network', ha='center',
            size=18, fontweight='bold')
legend2 = ax2.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
for text in legend2.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
#plt.axis("off")
plt.savefig("Base_Network_simplified_suplot.png", dpi=dpi, bbox_inches="tight")

"""###**Visualize the Clustered Network**"""

network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec_s_6.nc"
n_elec_s_6 = pypsa.Network(network_path)
n_elec_s_6

network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec_s_6.nc"
n_elec_s_6 = pypsa.Network(network_path)
n_elec_s_6.loads['x'] = None
n_elec_s_6.loads['y'] = None
for idx in n_elec_s_6.loads.index:
    if idx in n_elec_s_6.buses.index:
        n_elec_s_6.loads.at[idx, 'x'] = n_elec_s_6.buses.at[idx, 'x']
        n_elec_s_6.loads.at[idx, 'y'] = n_elec_s_6.buses.at[idx, 'y']
loads_c = n_elec_s_6.loads
loads_c["geometry"] = gpd.points_from_xy(loads_c.x, loads_c.y)
loads_c = gpd.GeoDataFrame(loads_c, crs="epsg:4326")

buses_c = n_elec_s_6.buses
buses_c["geometry"] = gpd.points_from_xy(buses_c.x, buses_c.y)
buses_c = gpd.GeoDataFrame(buses_c, crs="epsg:4326")
# lines dataframe
lines_c = n_elec_s_6.lines
lines_c["geometry"] = lines_c.apply(
    lambda x: LineString(
        [buses_c.loc[x["bus0"], "geometry"], buses_c.loc[x["bus1"], "geometry"]]
    ),
    axis=1,
)
lines_c = gpd.GeoDataFrame(lines_c, crs="epsg:4326")

sns.set_theme(style='whitegrid')
fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15, 10), subplot_kw={'projection': ccrs.PlateCarree()})
plt.subplots_adjust(wspace=0.05, hspace=0.05)
plt.autoscale(tight=True)
ax1.cla()
ax1.set_facecolor("white")
ax1.spines[['top', 'right']].set_visible(False)
ax1 = countries.plot(ax=ax1, color="lightskyblue")
ax1.set_extent(extent_list, crs=ccrs.PlateCarree())
ax1.add_image(imagery, 7)
#off_shore.plot(ax=ax)
buses.plot(ax=ax1, color="black", label="Substations", alpha=0.9,
           markersize=10)
lines.plot(ax=ax1, color="blue", label="Transmission Lines", markersize=5, alpha=0.8)
transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
#ax1.set_title('Base Network', size=20, fontweight='bold')
fig.text(0.25, 0.07, '(a) Base Network', ha='center',
            size=18, fontweight='bold')
legend1 = ax1.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
for text in legend1.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)

ax2.cla()
ax2.set_facecolor("white")
ax2.spines[['top', 'right']].set_visible(False)
ax2 = countries.plot(ax=ax2, color="lightskyblue")
ax2.set_extent(extent_list, crs=ccrs.PlateCarree())
ax2.add_image(imagery, 7)
#off_shore.plot(ax=ax)
buses_s.plot(ax=ax2, color="black", label="Substations", alpha=0.9,
           markersize=10)
lines_s.plot(ax=ax2, color="blue", label="Transmission Lines", markersize=5, alpha=0.8)
#transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
#ax2.set_title('Simplified Base Network', size=20, fontweight='bold')
fig.text(0.5, 0.07, '(b) Simplified Base Network', ha='center',
            size=18, fontweight='bold')
legend2 = ax2.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
for text in legend2.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)

ax3.cla()
ax3.set_facecolor("white")
ax3.spines[['top', 'right']].set_visible(False)
ax3 = countries.plot(ax=ax3, color="lightskyblue")
ax3.set_extent(extent_list, crs=ccrs.PlateCarree())
ax3.add_image(imagery, 7)
#off_shore.plot(ax=ax)
buses_c.plot(ax=ax3, color="orange", label="Substations", alpha=0.95,
           markersize=30)
loads_c.plot(ax=ax3, color="green", label="Load Centres", alpha=0.5,
           markersize=15)
lines_c.plot(ax=ax3, color="blue", label="Transmission Lines", markersize=5, alpha=0.8)
#transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
#ax3.set_title('Clustered Network', size=20, fontweight='bold')
fig.text(0.75, 0.07, '(c) Clustered Network', ha='center',
            size=18, fontweight='bold')
legend3 = ax3.legend(
    frameon=1, loc="lower center", ncol=1, labelcolor="black", facecolor="white",
    fontsize='10') #fancybox=True, borderpad=1, framealpha=1, shadow=True
for text in legend3.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend3.get_frame().set_edgecolor('black')
legend3.get_frame().set_linewidth(1)
#plt.axis("off")
plt.savefig("Base_Network_simplified_clustered_suplot.png", dpi=dpi, bbox_inches="tight")

"""**Visualize the Network After Adding Storage As Extra Components**"""

network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec_s_6_ec.nc"
n_elec_s_6_ec = pypsa.Network(network_path)
n_elec_s_6_ec

"""**Visualize the All Mix Scenario Network**"""

network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec_s_6_ec_lcopt_Co2L-1H.nc" # change to a suitable path for you
n_elec_s_6_ec_1copt_Co2L_1H = pypsa.Network(network_path)
n_elec_s_6_ec_1copt_Co2L_1H

print(n_elec_s_6_ec_1copt_Co2L_1H.carriers.to_markdown())

network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec_s_6_ec_lcopt_Co2L-1H.nc"
n_elec_s_6_ec = pypsa.Network(network_path)
# Load datarame
n_elec_s_6_ec.loads['x'] = None
n_elec_s_6_ec.loads['y'] = None
for idx in n_elec_s_6_ec.loads.index:
    if idx in n_elec_s_6_ec.buses.index:
        n_elec_s_6_ec.loads.at[idx, 'x'] = n_elec_s_6_ec.buses.at[idx, 'x']
        n_elec_s_6_ec.loads.at[idx, 'y'] = n_elec_s_6_ec.buses.at[idx, 'y']
loads_c_ec = n_elec_s_6_ec.loads
loads_c_ec["geometry"] = gpd.points_from_xy(loads_c_ec.x, loads_c_ec.y)
loads_c_ec = gpd.GeoDataFrame(loads_c_ec, crs="epsg:4326")

# Storage dataframe
n_elec_s_6_ec.storage_units['x'] = None
n_elec_s_6_ec.storage_units['y'] = None
for idx in n_elec_s_6_ec.storage_units.index:
    if idx in n_elec_s_6_ec.buses.index:
        n_elec_s_6_ec.storage_units.at[idx, 'x'] = n_elec_s_6_ec.buses.at[idx, 'x']
        n_elec_s_6_ec.storage_units.at[idx, 'y'] = n_elec_s_6_ec.buses.at[idx, 'y']
storage_units_c_ec = n_elec_s_6_ec.storage_units
storage_units_c_ec["geometry"] = gpd.points_from_xy(storage_units_c_ec.x, storage_units_c_ec.y)
storage_units_c_ec = gpd.GeoDataFrame(storage_units_c_ec, crs="epsg:4326")

buses_c_ec = n_elec_s_6_ec.buses
buses_c_ec["geometry"] = gpd.points_from_xy(buses_c_ec.x, buses_c_ec.y)
buses_c_ec = gpd.GeoDataFrame(buses_c_ec, crs="epsg:4326")

# lines dataframe
lines_c_ec = n_elec_s_6_ec.lines
lines_c_ec["geometry"] = lines_c_ec.apply(
    lambda x: LineString(
        [buses_c_ec.loc[x["bus0"], "geometry"], buses_c_ec.loc[x["bus1"], "geometry"]]
    ),
    axis=1,
)
lines_c_ec = gpd.GeoDataFrame(lines_c_ec, crs="epsg:4326")

# links dataframe
link_c_ec = n_elec_s_6_ec.links
link_c_ec["geometry"] = link_c_ec.apply(
    lambda x: LineString(
        [buses_c_ec.loc[x["bus0"], "geometry"], buses_c_ec.loc[x["bus1"], "geometry"]]
    ),
    axis=1,
)
link_c_ec = gpd.GeoDataFrame(link_c_ec, crs="epsg:4326")

# Generators
network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec_s_6_ec_lcopt_Co2L-1H.nc"
n_elec_s_6_ec_1copt_Co2L_1H = pypsa.Network(network_path)
df_1 = n_elec_s_6_ec.buses[['x', 'y']]
df_1_ = df_1[~df_1.index.str.contains('battery')]
df_1_filtered = df_1_[~df_1_.index.str.contains('H2')]
df_2 = n_elec_s_6_ec_1copt_Co2L_1H.generators[['bus']]
df2 = df_2.join(df_1_filtered, how='left', on='bus')
df2.reset_index(inplace=True)
df2["geometry"] = gpd.points_from_xy(df2.x, df2.y)
gen_c_ec = gpd.GeoDataFrame(df2, crs="epsg:4326")
def jitter_points(geometry, epsilon=0.001):
    jittered_geometry = []
    for point in geometry:
        x_jitter = point.x + np.random.uniform(-epsilon, epsilon)
        y_jitter = point.y + np.random.uniform(-epsilon, epsilon)
        jittered_geometry.append(Point(x_jitter, y_jitter))
    return jittered_geometry
epsilon = 0.5  # Adjust epsilon as needed
gen_c_ec['geometry'] = jitter_points(gen_c_ec['geometry'], epsilon)
num_points = len(gen_c_ec)
colormap = cm.get_cmap('hsv', num_points)
colors_list = [colormap(i) for i in range(num_points)]

sns.set_theme(style='whitegrid')
fig, (ax1, ax2, ax3, ax4, ax5) = plt.subplots(1, 5, figsize=(15, 10), subplot_kw={'projection': ccrs.PlateCarree()})
plt.subplots_adjust(wspace=0.05, hspace=0.05)
plt.autoscale(tight=True)
ax1.cla()
ax1.set_facecolor("white")
ax1.spines[['top', 'right']].set_visible(False)
ax1 = countries.plot(ax=ax1, color="lightskyblue")
ax1.set_extent(extent_list, crs=ccrs.PlateCarree())
ax1.add_image(imagery, 7)
#off_shore.plot(ax=ax)
buses_c_ec.plot(ax=ax1, color="black", label="Substations", alpha=0.9,
           markersize=25)
#lines_c_ec.plot(ax=ax1, color="blue", label="HVAC Transmission Lines", markersize=5, alpha=0.8)
#ax1.set_title('Substation Nodes', size=19, fontweight='bold')
fig.text(0.20, 0.25, '(a) Substation Nodes', ha='center',
            size=11, fontweight='bold')
legend1 = ax1.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
for text in legend1.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)

ax2.cla()
ax2.set_facecolor("white")
ax2.spines[['top', 'right']].set_visible(False)
ax2 = countries.plot(ax=ax2, color="lightskyblue")
ax2.set_extent(extent_list, crs=ccrs.PlateCarree())
ax2.add_image(imagery, 7)
#off_shore.plot(ax=ax)
#buses_c_ec.plot(ax=ax2, color="black", label="Substations", alpha=0.9,
           #markersize=10)
loads_c_ec.plot(ax=ax2, color="navy", label="Load Centres", alpha=0.5,
           markersize=25)
#transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
#ax2.set_title('Electricity Load Centres', size=15, fontweight='bold')
fig.text(0.35, 0.25, '(b) Electricity Load Centres', ha='center',
            size=11, fontweight='bold')
legend2 = ax2.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
for text in legend2.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)

ax3.cla()
ax3.set_facecolor("white")
ax3.spines[['top', 'right']].set_visible(False)
ax3 = countries.plot(ax=ax3, color="lightskyblue")
ax3.set_extent(extent_list, crs=ccrs.PlateCarree())
ax3.add_image(imagery, 7)
#off_shore.plot(ax=ax)
#buses_c_ec.plot(ax=ax3, color="orange", label="Substations", alpha=0.95,
           #markersize=30)
#loads_c_ec.plot(ax=ax3, color="green", label="Load Centres", alpha=0.5,
lines_c_ec.plot(ax=ax3, color="blue", label="HVAC Transmission Lines", markersize=7, alpha=0.8)           #markersize=15)
link_c_ec.plot(ax=ax3, color="teal", label="HVDC Transmission Lines", markersize=7, alpha=0.8)
#transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
#ax3.set_title('Transmission Lines', size=18, fontweight='bold')
fig.text(0.51, 0.25, '(c) Transmission Lines', ha='center',
            size=11, fontweight='bold')
legend3 = ax3.legend(
    frameon=1, loc="lower center", ncol=1, labelcolor="black", facecolor="white",
    fontsize='5') #fancybox=True, borderpad=1, framealpha=1, shadow=True
for text in legend3.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend3.get_frame().set_edgecolor('black')
legend3.get_frame().set_linewidth(1)

ax4.cla()
ax4.set_facecolor("white")
ax4.spines[['top', 'right']].set_visible(False)
ax4 = countries.plot(ax=ax4, color="lightskyblue")
ax4.set_extent(extent_list, crs=ccrs.PlateCarree())
ax4.add_image(imagery, 7)
#off_shore.plot(ax=ax)
#buses_c_ec.plot(ax=ax3, color="orange", label="Substations", alpha=0.95,
           #markersize=30)
#loads_c_ec.plot(ax=ax3, color="green", label="Load Centres", alpha=0.5,
storage_units_c_ec.plot(ax=ax4, color="purple", label="Storage Units", markersize=30, alpha=0.8)           #markersize=15)
#transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
#ax4.set_title('Storage Units', size=20, fontweight='bold')
fig.text(0.67, 0.25, '(d) Storage Units', ha='center',
            size=12, fontweight='bold')
legend4 = ax4.legend(
    frameon=1, loc="lower center", ncol=1, labelcolor="black", facecolor="white",
    fontsize='12') #fancybox=True, borderpad=1, framealpha=1, shadow=True
for text in legend4.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend4.get_frame().set_edgecolor('black')
legend4.get_frame().set_linewidth(1)

ax5.cla()
ax5.set_facecolor("white")
ax5.spines[['top', 'right']].set_visible(False)
ax5 = countries.plot(ax=ax5, color="lightskyblue")
ax5.set_extent(extent_list, crs=ccrs.PlateCarree())
ax5.add_image(imagery, 7)
for idx, row in gen_c_ec.iterrows():
    gen_c_ec.loc[[idx]].plot(ax=ax5, color=colors_list[idx], markersize=30, alpha=0.8)
#gen_c_ec.plot(ax=ax5, color="olive", label="Generator Units", markersize=30, alpha=0.8)           #markersize=15)
#transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
'''legend5 = ax5.legend('Generator Units',
    frameon=1, loc="lower center", labelcolor="black", facecolor="white",
    fontsize='12') #fancybox=True, borderpad=1, framealpha=1, shadow=True
for text in legend5.get_texts():
    text.set_fontsize(12)  # Set font size
    text.set_fontweight("bold")'''
#ax5.set_title('Generator Units', size=20, fontweight='bold')
fig.text(0.82, 0.25, '(e) Generator Units', ha='center',
            size=11, fontweight='bold')
single_handle = Line2D([0], [0], marker='o', color='w', label='Generator Units',
                       markerfacecolor='gray', markersize=10)
legend5 = ax5.legend(handles=[single_handle], frameon=1, loc="lower center", labelcolor="black",
           facecolor="white",fontsize='10')
legend5.get_frame().set_edgecolor('black')
legend5.get_frame().set_linewidth(1)
#plt.axis("off")
plt.savefig("Base_Network_simplified_clustered_suplot_scenario1.png", dpi=dpi, bbox_inches="tight")

"""**Visualize RES Scenario Only Carriers**"""

network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_RES/elec_s_6_ec_lcopt_Co2L-1H.nc" # change to a suitable path for you
n_RES = pypsa.Network(network_path)
print(n_RES.carriers.to_markdown())

n_RES

network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_RES/elec_s_6_ec_lcopt_Co2L-1H.nc" # change to a suitable path for you
n_elec_s_6_ec = pypsa.Network(network_path)
# Load datarame
n_elec_s_6_ec.loads['x'] = None
n_elec_s_6_ec.loads['y'] = None
for idx in n_elec_s_6_ec.loads.index:
    if idx in n_elec_s_6_ec.buses.index:
        n_elec_s_6_ec.loads.at[idx, 'x'] = n_elec_s_6_ec.buses.at[idx, 'x']
        n_elec_s_6_ec.loads.at[idx, 'y'] = n_elec_s_6_ec.buses.at[idx, 'y']
loads_c_ec = n_elec_s_6_ec.loads
loads_c_ec["geometry"] = gpd.points_from_xy(loads_c_ec.x, loads_c_ec.y)
loads_c_ec = gpd.GeoDataFrame(loads_c_ec, crs="epsg:4326")

# Storage dataframe
n_elec_s_6_ec.storage_units['x'] = None
n_elec_s_6_ec.storage_units['y'] = None
for idx in n_elec_s_6_ec.storage_units.index:
    if idx in n_elec_s_6_ec.buses.index:
        n_elec_s_6_ec.storage_units.at[idx, 'x'] = n_elec_s_6_ec.buses.at[idx, 'x']
        n_elec_s_6_ec.storage_units.at[idx, 'y'] = n_elec_s_6_ec.buses.at[idx, 'y']
storage_units_c_ec = n_elec_s_6_ec.storage_units
storage_units_c_ec["geometry"] = gpd.points_from_xy(storage_units_c_ec.x, storage_units_c_ec.y)
storage_units_c_ec = gpd.GeoDataFrame(storage_units_c_ec, crs="epsg:4326")

buses_c_ec = n_elec_s_6_ec.buses
buses_c_ec["geometry"] = gpd.points_from_xy(buses_c_ec.x, buses_c_ec.y)
buses_c_ec = gpd.GeoDataFrame(buses_c_ec, crs="epsg:4326")

# lines dataframe
lines_c_ec = n_elec_s_6_ec.lines
lines_c_ec["geometry"] = lines_c_ec.apply(
    lambda x: LineString(
        [buses_c_ec.loc[x["bus0"], "geometry"], buses_c_ec.loc[x["bus1"], "geometry"]]
    ),
    axis=1,
)
lines_c_ec = gpd.GeoDataFrame(lines_c_ec, crs="epsg:4326")

# links dataframe
link_c_ec = n_elec_s_6_ec.links
link_c_ec["geometry"] = link_c_ec.apply(
    lambda x: LineString(
        [buses_c_ec.loc[x["bus0"], "geometry"], buses_c_ec.loc[x["bus1"], "geometry"]]
    ),
    axis=1,
)
link_c_ec = gpd.GeoDataFrame(link_c_ec, crs="epsg:4326")

# Generators
network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_RES/elec_s_6_ec_lcopt_Co2L-1H.nc" # change to a suitable path for you
n_elec_s_6_ec_1copt_Co2L_1H = pypsa.Network(network_path)
df_1 = n_elec_s_6_ec.buses[['x', 'y']]
df_1_ = df_1[~df_1.index.str.contains('battery')]
df_1_filtered = df_1_[~df_1_.index.str.contains('H2')]
df_2 = n_elec_s_6_ec_1copt_Co2L_1H.generators[['bus']]
df2 = df_2.join(df_1_filtered, how='left', on='bus')
df2.reset_index(inplace=True)
df2["geometry"] = gpd.points_from_xy(df2.x, df2.y)
gen_c_ec = gpd.GeoDataFrame(df2, crs="epsg:4326")
def jitter_points(geometry, epsilon=0.001):
    jittered_geometry = []
    for point in geometry:
        x_jitter = point.x + np.random.uniform(-epsilon, epsilon)
        y_jitter = point.y + np.random.uniform(-epsilon, epsilon)
        jittered_geometry.append(Point(x_jitter, y_jitter))
    return jittered_geometry
epsilon = 0.5  # Adjust epsilon as needed
gen_c_ec['geometry'] = jitter_points(gen_c_ec['geometry'], epsilon)
num_points = len(gen_c_ec)
colormap = cm.get_cmap('hsv', num_points)
colors_list = [colormap(i) for i in range(num_points)]

sns.set_theme(style='whitegrid')
fig, (ax1, ax2, ax3, ax4, ax5) = plt.subplots(1, 5, figsize=(15, 10), subplot_kw={'projection': ccrs.PlateCarree()})
plt.subplots_adjust(wspace=0.05, hspace=0.05)
plt.autoscale(tight=True)
ax1.cla()
ax1.set_facecolor("white")
ax1.spines[['top', 'right']].set_visible(False)
ax1 = countries.plot(ax=ax1, color="lightskyblue")
ax1.set_extent(extent_list, crs=ccrs.PlateCarree())
ax1.add_image(imagery, 7)
#off_shore.plot(ax=ax)
buses_c_ec.plot(ax=ax1, color="black", label="Substations", alpha=0.9,
           markersize=25)
#lines_c_ec.plot(ax=ax1, color="blue", label="HVAC Transmission Lines", markersize=5, alpha=0.8)
#ax1.set_title('Substation Nodes', size=19, fontweight='bold')
fig.text(0.20, 0.25, '(a) Substation Nodes', ha='center',
            size=11, fontweight='bold')
legend1 = ax1.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
for text in legend1.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)

ax2.cla()
ax2.set_facecolor("white")
ax2.spines[['top', 'right']].set_visible(False)
ax2 = countries.plot(ax=ax2, color="lightskyblue")
ax2.set_extent(extent_list, crs=ccrs.PlateCarree())
ax2.add_image(imagery, 7)
#off_shore.plot(ax=ax)
#buses_c_ec.plot(ax=ax2, color="black", label="Substations", alpha=0.9,
           #markersize=10)
loads_c_ec.plot(ax=ax2, color="navy", label="Load Centres", alpha=0.5,
           markersize=25)
#transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
#ax2.set_title('Electricity Load Centres', size=15, fontweight='bold')
fig.text(0.35, 0.25, '(b) Electricity Load Centres', ha='center',
            size=11, fontweight='bold')
legend2 = ax2.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
for text in legend2.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)

ax3.cla()
ax3.set_facecolor("white")
ax3.spines[['top', 'right']].set_visible(False)
ax3 = countries.plot(ax=ax3, color="lightskyblue")
ax3.set_extent(extent_list, crs=ccrs.PlateCarree())
ax3.add_image(imagery, 7)
#off_shore.plot(ax=ax)
#buses_c_ec.plot(ax=ax3, color="orange", label="Substations", alpha=0.95,
           #markersize=30)
#loads_c_ec.plot(ax=ax3, color="green", label="Load Centres", alpha=0.5,
lines_c_ec.plot(ax=ax3, color="blue", label="HVAC Transmission Lines", markersize=7, alpha=0.8)           #markersize=15)
link_c_ec.plot(ax=ax3, color="teal", label="HVDC Transmission Lines", markersize=7, alpha=0.8)
#transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
#ax3.set_title('Transmission Lines', size=18, fontweight='bold')
fig.text(0.51, 0.25, '(c) Transmission Lines', ha='center',
            size=11, fontweight='bold')
legend3 = ax3.legend(
    frameon=1, loc="lower center", ncol=1, labelcolor="black", facecolor="white",
    fontsize='5') #fancybox=True, borderpad=1, framealpha=1, shadow=True
for text in legend3.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend3.get_frame().set_edgecolor('black')
legend3.get_frame().set_linewidth(1)

ax4.cla()
ax4.set_facecolor("white")
ax4.spines[['top', 'right']].set_visible(False)
ax4 = countries.plot(ax=ax4, color="lightskyblue")
ax4.set_extent(extent_list, crs=ccrs.PlateCarree())
ax4.add_image(imagery, 7)
#off_shore.plot(ax=ax)
#buses_c_ec.plot(ax=ax3, color="orange", label="Substations", alpha=0.95,
           #markersize=30)
#loads_c_ec.plot(ax=ax3, color="green", label="Load Centres", alpha=0.5,
storage_units_c_ec.plot(ax=ax4, color="purple", label="Storage Units", markersize=30, alpha=0.8)           #markersize=15)
#transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
#ax4.set_title('Storage Units', size=20, fontweight='bold')
fig.text(0.67, 0.25, '(d) Storage Units', ha='center',
            size=12, fontweight='bold')
legend4 = ax4.legend(
    frameon=1, loc="lower center", ncol=1, labelcolor="black", facecolor="white",
    fontsize='12') #fancybox=True, borderpad=1, framealpha=1, shadow=True
for text in legend4.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend4.get_frame().set_edgecolor('black')
legend4.get_frame().set_linewidth(1)

ax5.cla()
ax5.set_facecolor("white")
ax5.spines[['top', 'right']].set_visible(False)
ax5 = countries.plot(ax=ax5, color="lightskyblue")
ax5.set_extent(extent_list, crs=ccrs.PlateCarree())
ax5.add_image(imagery, 7)
for idx, row in gen_c_ec.iterrows():
    gen_c_ec.loc[[idx]].plot(ax=ax5, color=colors_list[idx], markersize=30, alpha=0.8)
#gen_c_ec.plot(ax=ax5, color="olive", label="Generator Units", markersize=30, alpha=0.8)           #markersize=15)
#transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
'''legend5 = ax5.legend('Generator Units',
    frameon=1, loc="lower center", labelcolor="black", facecolor="white",
    fontsize='12') #fancybox=True, borderpad=1, framealpha=1, shadow=True
for text in legend5.get_texts():
    text.set_fontsize(12)  # Set font size
    text.set_fontweight("bold")'''
#ax5.set_title('Generator Units', size=20, fontweight='bold')
fig.text(0.82, 0.25, '(e) Generator Units', ha='center',
            size=11, fontweight='bold')
single_handle = Line2D([0], [0], marker='o', color='w', label='Generator Units',
                       markerfacecolor='gray', markersize=10)
legend5 = ax5.legend(handles=[single_handle], frameon=1, loc="lower center", labelcolor="black",
           facecolor="white",fontsize='10')
legend5.get_frame().set_edgecolor('black')
legend5.get_frame().set_linewidth(1)
#plt.axis("off")
plt.savefig("Base_Network_simplified_clustered_suplot_scenario2.png", dpi=dpi, bbox_inches="tight")

"""**Visualize RES and Low Carbon Scenario Only Carriers**"""

network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_RES_LC/elec_s_6_ec_lcopt_Co2L-1H.nc" # change to a suitable path for you
n_RES_LC = pypsa.Network(network_path)
print(n_RES_LC.carriers.to_markdown())

n_RES_LC

network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_RES_LC/elec_s_6_ec_lcopt_Co2L-1H.nc" # change to a suitable path for you
n_elec_s_6_ec = pypsa.Network(network_path)
# Load datarame
n_elec_s_6_ec.loads['x'] = None
n_elec_s_6_ec.loads['y'] = None
for idx in n_elec_s_6_ec.loads.index:
    if idx in n_elec_s_6_ec.buses.index:
        n_elec_s_6_ec.loads.at[idx, 'x'] = n_elec_s_6_ec.buses.at[idx, 'x']
        n_elec_s_6_ec.loads.at[idx, 'y'] = n_elec_s_6_ec.buses.at[idx, 'y']
loads_c_ec = n_elec_s_6_ec.loads
loads_c_ec["geometry"] = gpd.points_from_xy(loads_c_ec.x, loads_c_ec.y)
loads_c_ec = gpd.GeoDataFrame(loads_c_ec, crs="epsg:4326")

# Storage dataframe
n_elec_s_6_ec.storage_units['x'] = None
n_elec_s_6_ec.storage_units['y'] = None
for idx in n_elec_s_6_ec.storage_units.index:
    if idx in n_elec_s_6_ec.buses.index:
        n_elec_s_6_ec.storage_units.at[idx, 'x'] = n_elec_s_6_ec.buses.at[idx, 'x']
        n_elec_s_6_ec.storage_units.at[idx, 'y'] = n_elec_s_6_ec.buses.at[idx, 'y']
storage_units_c_ec = n_elec_s_6_ec.storage_units
storage_units_c_ec["geometry"] = gpd.points_from_xy(storage_units_c_ec.x, storage_units_c_ec.y)
storage_units_c_ec = gpd.GeoDataFrame(storage_units_c_ec, crs="epsg:4326")

buses_c_ec = n_elec_s_6_ec.buses
buses_c_ec["geometry"] = gpd.points_from_xy(buses_c_ec.x, buses_c_ec.y)
buses_c_ec = gpd.GeoDataFrame(buses_c_ec, crs="epsg:4326")

# lines dataframe
lines_c_ec = n_elec_s_6_ec.lines
lines_c_ec["geometry"] = lines_c_ec.apply(
    lambda x: LineString(
        [buses_c_ec.loc[x["bus0"], "geometry"], buses_c_ec.loc[x["bus1"], "geometry"]]
    ),
    axis=1,
)
lines_c_ec = gpd.GeoDataFrame(lines_c_ec, crs="epsg:4326")

# links dataframe
link_c_ec = n_elec_s_6_ec.links
link_c_ec["geometry"] = link_c_ec.apply(
    lambda x: LineString(
        [buses_c_ec.loc[x["bus0"], "geometry"], buses_c_ec.loc[x["bus1"], "geometry"]]
    ),
    axis=1,
)
link_c_ec = gpd.GeoDataFrame(link_c_ec, crs="epsg:4326")

# Generators
network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_RES_LC/elec_s_6_ec_lcopt_Co2L-1H.nc" # change to a suitable path for you
n_elec_s_6_ec_1copt_Co2L_1H = pypsa.Network(network_path)
df_1 = n_elec_s_6_ec.buses[['x', 'y']]
df_1_ = df_1[~df_1.index.str.contains('battery')]
df_1_filtered = df_1_[~df_1_.index.str.contains('H2')]
df_2 = n_elec_s_6_ec_1copt_Co2L_1H.generators[['bus']]
df2 = df_2.join(df_1_filtered, how='left', on='bus')
df2.reset_index(inplace=True)
df2["geometry"] = gpd.points_from_xy(df2.x, df2.y)
gen_c_ec = gpd.GeoDataFrame(df2, crs="epsg:4326")
def jitter_points(geometry, epsilon=0.001):
    jittered_geometry = []
    for point in geometry:
        x_jitter = point.x + np.random.uniform(-epsilon, epsilon)
        y_jitter = point.y + np.random.uniform(-epsilon, epsilon)
        jittered_geometry.append(Point(x_jitter, y_jitter))
    return jittered_geometry
epsilon = 0.5  # Adjust epsilon as needed
gen_c_ec['geometry'] = jitter_points(gen_c_ec['geometry'], epsilon)
num_points = len(gen_c_ec)
colormap = cm.get_cmap('hsv', num_points)
colors_list = [colormap(i) for i in range(num_points)]

sns.set_theme(style='whitegrid')
fig, (ax1, ax2, ax3, ax4, ax5) = plt.subplots(1, 5, figsize=(15, 10), subplot_kw={'projection': ccrs.PlateCarree()})
plt.subplots_adjust(wspace=0.05, hspace=0.05)
plt.autoscale(tight=True)
ax1.cla()
ax1.set_facecolor("white")
ax1.spines[['top', 'right']].set_visible(False)
ax1 = countries.plot(ax=ax1, color="lightskyblue")
ax1.set_extent(extent_list, crs=ccrs.PlateCarree())
ax1.add_image(imagery, 7)
#off_shore.plot(ax=ax)
buses_c_ec.plot(ax=ax1, color="black", label="Substations", alpha=0.9,
           markersize=25)
#lines_c_ec.plot(ax=ax1, color="blue", label="HVAC Transmission Lines", markersize=5, alpha=0.8)
#ax1.set_title('Substation Nodes', size=19, fontweight='bold')
fig.text(0.20, 0.25, '(a) Substation Nodes', ha='center',
            size=11, fontweight='bold')
legend1 = ax1.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
for text in legend1.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)

ax2.cla()
ax2.set_facecolor("white")
ax2.spines[['top', 'right']].set_visible(False)
ax2 = countries.plot(ax=ax2, color="lightskyblue")
ax2.set_extent(extent_list, crs=ccrs.PlateCarree())
ax2.add_image(imagery, 7)
#off_shore.plot(ax=ax)
#buses_c_ec.plot(ax=ax2, color="black", label="Substations", alpha=0.9,
           #markersize=10)
loads_c_ec.plot(ax=ax2, color="navy", label="Load Centres", alpha=0.5,
           markersize=25)
#transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
#ax2.set_title('Electricity Load Centres', size=15, fontweight='bold')
fig.text(0.35, 0.25, '(b) Electricity Load Centres', ha='center',
            size=11, fontweight='bold')
legend2 = ax2.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
for text in legend2.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)

ax3.cla()
ax3.set_facecolor("white")
ax3.spines[['top', 'right']].set_visible(False)
ax3 = countries.plot(ax=ax3, color="lightskyblue")
ax3.set_extent(extent_list, crs=ccrs.PlateCarree())
ax3.add_image(imagery, 7)
#off_shore.plot(ax=ax)
#buses_c_ec.plot(ax=ax3, color="orange", label="Substations", alpha=0.95,
           #markersize=30)
#loads_c_ec.plot(ax=ax3, color="green", label="Load Centres", alpha=0.5,
lines_c_ec.plot(ax=ax3, color="blue", label="HVAC Transmission Lines", markersize=7, alpha=0.8)           #markersize=15)
link_c_ec.plot(ax=ax3, color="teal", label="HVDC Transmission Lines", markersize=7, alpha=0.8)
#transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
#ax3.set_title('Transmission Lines', size=18, fontweight='bold')
fig.text(0.51, 0.25, '(c) Transmission Lines', ha='center',
            size=11, fontweight='bold')
legend3 = ax3.legend(
    frameon=1, loc="lower center", ncol=1, labelcolor="black", facecolor="white",
    fontsize='5') #fancybox=True, borderpad=1, framealpha=1, shadow=True
for text in legend3.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend3.get_frame().set_edgecolor('black')
legend3.get_frame().set_linewidth(1)

ax4.cla()
ax4.set_facecolor("white")
ax4.spines[['top', 'right']].set_visible(False)
ax4 = countries.plot(ax=ax4, color="lightskyblue")
ax4.set_extent(extent_list, crs=ccrs.PlateCarree())
ax4.add_image(imagery, 7)
#off_shore.plot(ax=ax)
#buses_c_ec.plot(ax=ax3, color="orange", label="Substations", alpha=0.95,
           #markersize=30)
#loads_c_ec.plot(ax=ax3, color="green", label="Load Centres", alpha=0.5,
storage_units_c_ec.plot(ax=ax4, color="purple", label="Storage Units", markersize=30, alpha=0.8)           #markersize=15)
#transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
#ax4.set_title('Storage Units', size=20, fontweight='bold')
fig.text(0.67, 0.25, '(d) Storage Units', ha='center',
            size=12, fontweight='bold')
legend4 = ax4.legend(
    frameon=1, loc="lower center", ncol=1, labelcolor="black", facecolor="white",
    fontsize='12') #fancybox=True, borderpad=1, framealpha=1, shadow=True
for text in legend4.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend4.get_frame().set_edgecolor('black')
legend4.get_frame().set_linewidth(1)

ax5.cla()
ax5.set_facecolor("white")
ax5.spines[['top', 'right']].set_visible(False)
ax5 = countries.plot(ax=ax5, color="lightskyblue")
ax5.set_extent(extent_list, crs=ccrs.PlateCarree())
ax5.add_image(imagery, 7)
for idx, row in gen_c_ec.iterrows():
    gen_c_ec.loc[[idx]].plot(ax=ax5, color=colors_list[idx], markersize=30, alpha=0.8)
#gen_c_ec.plot(ax=ax5, color="olive", label="Generator Units", markersize=30, alpha=0.8)           #markersize=15)
#transformer_b.plot(ax=ax1, color="red", label="Transformers", markersize=10, alpha=0.6)
'''legend5 = ax5.legend('Generator Units',
    frameon=1, loc="lower center", labelcolor="black", facecolor="white",
    fontsize='12') #fancybox=True, borderpad=1, framealpha=1, shadow=True
for text in legend5.get_texts():
    text.set_fontsize(12)  # Set font size
    text.set_fontweight("bold")'''
#ax5.set_title('Generator Units', size=20, fontweight='bold')
fig.text(0.82, 0.25, '(e) Generator Units', ha='center',
            size=11, fontweight='bold')
single_handle = Line2D([0], [0], marker='o', color='w', label='Generator Units',
                       markerfacecolor='gray', markersize=10)
legend5 = ax5.legend(handles=[single_handle], frameon=1, loc="lower center", labelcolor="black",
           facecolor="white",fontsize='10')
legend5.get_frame().set_edgecolor('black')
legend5.get_frame().set_linewidth(1)
#plt.axis("off")
plt.savefig("Base_Network_simplified_clustered_suplot_scenario3.png", dpi=dpi, bbox_inches="tight")

"""###**Obtain the Power Curve of the Wind Power Turbines**"""

sns.set_theme(style='whitegrid')
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
plt.subplots_adjust(wspace=0.2, hspace=0.2)
plt.autoscale(tight=True)
ax1.cla()
ax1.set_facecolor("white")
ax1.spines[['top', 'right']].set_visible(False)
ax1.set_xlabel('Wind Velocity [m/s]', size=15, fontweight='bold')
ax1.set_ylabel('Generated Power [MW]', size=15, fontweight='bold')
#ax1.set_title('(a) Onshore Wind Turbine Power Curve', size=14, fontweight='bold')
# Onshore Wind Power Turbine
# Wind velocities in m/s
V = [0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 25, 25]
# Generated power in MW
POW = [0.000, 0.000, 0.005, 0.150, 0.300, 0.525, 0.905, 1.375, 1.950, 2.580, 2.960, 3.050, 3.060, 3.060, 0.000]
ax1.plot(V, POW, marker='o', linestyle='-', color='navy', markersize=10,
         label='Vestas V112 Turbine Power Curve')
ax1.tick_params(axis='x', rotation=30, labelsize=20)
ax1.tick_params(axis='y', rotation=0, labelsize=20)
for spine in ax1.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax1.xaxis.grid(False)
ax1.yaxis.grid(False)

# Offshore Wind Turbine Power
ax2.cla()
ax2.set_facecolor("white")
ax2.spines[['top', 'right']].set_visible(False)
ax2.set_xlabel('Wind Velocity [m/s]', size=15, fontweight='bold')
ax2.set_ylabel('Generated Power [MW]', size=15, fontweight='bold')
#ax2.set_title('(b) Offshore Wind Turbine Power Curve', size=14, fontweight='bold')
# Wind velocities in m/s
V = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 25]
# Generated power in MW
POW = [0.0, 0.864, 1.488, 2.728, 4.584, 7.057, 10.146, 13.852, 18.0, 18.0, 18.0, 18.0, 18.0, 18.0, 18.0, 18.0, 18.0, 18.0, 18.0, 18.0, 18.0, 18.0, 18.0, 0.0]
ax2.plot(V, POW, marker='o', linestyle='-', color='purple', markersize=10,
         label='NREL Reference Turbine Power Curve')
ax2.tick_params(axis='x', rotation=30, labelsize=20)
ax2.tick_params(axis='y', rotation=0, labelsize=20)
for spine in ax2.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax2.xaxis.grid(False)
ax2.yaxis.grid(False)
legend1 = ax1.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
for text in legend1.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
legend2 = ax2.legend(
    frameon=1, loc="lower center", labelcolor="black", facecolor="white"
)
for text in legend2.get_texts():
    text.set_fontsize(10)  # Set font size
    text.set_fontweight("bold")
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
#plt.axis("off")
# Adding Titles Below the Plots
plt.figtext(0.28, -0.12, '(a) Onshore Wind Turbine Power Curve', ha='center',
            size=14, fontweight='bold')
plt.figtext(0.73, -0.12, '(b) Offshore Wind Turbine Power Curve', ha='center',
            size=14, fontweight='bold')
plt.savefig("Wind_Turbine_Power_Curves_suplot.png", dpi=dpi, bbox_inches="tight")
plt.show()

"""**Analyse the Network Input Data Further Including the Data of RES Only and RES and Low Carbon Carriers Scenarios**"""

# 2025 - ALL
network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec_s_6_ec_lcopt_Co2L-1H.nc"
n_elec_s_6_ec_1copt_Co2L_1H = pypsa.Network(network_path)
#n_elec_s_6_ec_1copt_Co2L_1H.generators_t.p_max_pu.sum().rename("en_pu").head(50)
# Load
df_2025_loadmax = n_elec_s_6_ec_1copt_Co2L_1H.loads_t.p_set.max()
df_2025_loadmax = df_2025_loadmax.reset_index()
df_2025_loadmax.columns = ['bus', 'Max_Load_2025']
# RES and Conventional Generators
df_2025_res = n_elec_s_6_ec_1copt_Co2L_1H.generators[['p_nom_max', 'capital_cost', 'marginal_cost',
                                        'bus', 'carrier']]
df_2025_con = n_elec_s_6_ec_1copt_Co2L_1H.generators[['p_nom', 'capital_cost', 'marginal_cost',
                                        'bus', 'carrier']]
selected_carriers_res = ['offwind-ac', 'offwind-dc', 'onwind', 'solar']
selected_carriers_con_gen = ['CCGT', 'biomass', 'coal', 'nuclear', 'oil', 'ror']
df_2025_RES_Gen = df_2025_res[df_2025_res['carrier'].isin(selected_carriers_res)]
df_2025_RES_Gen = df_2025_RES_Gen.replace([np.inf, -np.inf], np.nan)
df_2025_RES_Gen = df_2025_RES_Gen.fillna(0)
df_2025_Con_Gen = df_2025_con[df_2025_con['carrier'].isin(selected_carriers_con_gen)]
df_2025_Con_Gen = df_2025_Con_Gen.replace([np.inf, -np.inf], np.nan)
df_2025_Con_Gen = df_2025_Con_Gen.fillna(0)
df_2025_RES_Gen_bus = df_2025_RES_Gen.groupby(['bus']).sum().reset_index()
col_names = df_2025_RES_Gen_bus.columns
new_col_names = [col_names[0]] + [f"{col}_2025" for col in col_names[1:]]
df_2025_RES_Gen_bus.columns = new_col_names
df_2025_Con_Gen_bus = df_2025_Con_Gen.groupby(['bus']).sum().reset_index()
col_names = df_2025_Con_Gen_bus.columns
new_col_names = [col_names[0]] + [f"{col}_2025" for col in col_names[1:]]
df_2025_Con_Gen_bus.columns = new_col_names
merged_df1_2 = pd.merge(df_2025_RES_Gen_bus, df_2025_Con_Gen_bus, on='bus', suffixes=('_RESGen', '_ConGen'))
final_df_2025 = pd.merge(merged_df1_2, df_2025_loadmax, on='bus')

# RES ONLY
# 2025
network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_RES/elec_s_6_ec_lcopt_Co2L-1H.nc"
n_elec_s_6_ec_1copt_Co2L_1H = pypsa.Network(network_path)
#n_elec_s_6_ec_1copt_Co2L_1H.generators_t.p_max_pu.sum().rename("en_pu").head(50)
# Load
df_2025_loadmax = n_elec_s_6_ec_1copt_Co2L_1H.loads_t.p_set.max()
df_2025_loadmax = df_2025_loadmax.reset_index()
df_2025_loadmax.columns = ['bus', 'Max_Load_2025']
# RES and Conventional Generators
df_2025_res = n_elec_s_6_ec_1copt_Co2L_1H.generators[['p_nom_max', 'capital_cost', 'marginal_cost',
                                        'bus', 'carrier']]
df_2025_con = n_elec_s_6_ec_1copt_Co2L_1H.generators[['p_nom', 'capital_cost', 'marginal_cost',
                                        'bus', 'carrier']]
selected_carriers_res = ['offwind-ac', 'offwind-dc', 'onwind', 'solar']
selected_carriers_con_gen = ['CCGT', 'biomass', 'coal', 'nuclear', 'oil', 'ror']
df_2025_RES_Gen = df_2025_res[df_2025_res['carrier'].isin(selected_carriers_res)]
df_2025_RES_Gen = df_2025_RES_Gen.replace([np.inf, -np.inf], np.nan)
df_2025_RES_Gen = df_2025_RES_Gen.fillna(0)
df_2025_Con_Gen = df_2025_con[df_2025_con['carrier'].isin(selected_carriers_con_gen)]
df_2025_Con_Gen = df_2025_Con_Gen.replace([np.inf, -np.inf], np.nan)
df_2025_Con_Gen = df_2025_Con_Gen.fillna(0)
df_2025_RES_Gen_bus = df_2025_RES_Gen.groupby(['bus']).sum().reset_index()
col_names = df_2025_RES_Gen_bus.columns
new_col_names = [col_names[0]] + [f"{col}_2025" for col in col_names[1:]]
df_2025_RES_Gen_bus.columns = new_col_names
df_2025_Con_Gen_bus = df_2025_Con_Gen.groupby(['bus']).sum().reset_index()
col_names = df_2025_Con_Gen_bus.columns
new_col_names = [col_names[0]] + [f"{col}_2025" for col in col_names[1:]]
df_2025_Con_Gen_bus.columns = new_col_names
merged_df1_2 = pd.merge(df_2025_RES_Gen_bus, df_2025_Con_Gen_bus, on='bus', suffixes=('_RESGen', '_ConGen'))
final_df_2025_RES = pd.merge(merged_df1_2, df_2025_loadmax, on='bus')

# RES AND LOC CARBON CARRIERS ONLY SCENARIO
# 2025
network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_RES_LC/elec_s_6_ec_lcopt_Co2L-1H.nc"
n_elec_s_6_ec_1copt_Co2L_1H = pypsa.Network(network_path)
#n_elec_s_6_ec_1copt_Co2L_1H.generators_t.p_max_pu.sum().rename("en_pu").head(50)
# Load
df_2025_loadmax = n_elec_s_6_ec_1copt_Co2L_1H.loads_t.p_set.max()
df_2025_loadmax = df_2025_loadmax.reset_index()
df_2025_loadmax.columns = ['bus', 'Max_Load_2025']
# RES and Conventional Generators
df_2025_res = n_elec_s_6_ec_1copt_Co2L_1H.generators[['p_nom_max', 'capital_cost', 'marginal_cost',
                                        'bus', 'carrier']]
df_2025_con = n_elec_s_6_ec_1copt_Co2L_1H.generators[['p_nom', 'capital_cost', 'marginal_cost',
                                        'bus', 'carrier']]
selected_carriers_res = ['offwind-ac', 'offwind-dc', 'onwind', 'solar']
selected_carriers_con_gen = ['CCGT', 'biomass', 'coal', 'nuclear', 'oil', 'ror']
df_2025_RES_Gen = df_2025_res[df_2025_res['carrier'].isin(selected_carriers_res)]
df_2025_RES_Gen = df_2025_RES_Gen.replace([np.inf, -np.inf], np.nan)
df_2025_RES_Gen = df_2025_RES_Gen.fillna(0)
df_2025_Con_Gen = df_2025_con[df_2025_con['carrier'].isin(selected_carriers_con_gen)]
df_2025_Con_Gen = df_2025_Con_Gen.replace([np.inf, -np.inf], np.nan)
df_2025_Con_Gen = df_2025_Con_Gen.fillna(0)
df_2025_RES_Gen_bus = df_2025_RES_Gen.groupby(['bus']).sum().reset_index()
col_names = df_2025_RES_Gen_bus.columns
new_col_names = [col_names[0]] + [f"{col}_2025" for col in col_names[1:]]
df_2025_RES_Gen_bus.columns = new_col_names
df_2025_Con_Gen_bus = df_2025_Con_Gen.groupby(['bus']).sum().reset_index()
col_names = df_2025_Con_Gen_bus.columns
new_col_names = [col_names[0]] + [f"{col}_2025" for col in col_names[1:]]
df_2025_Con_Gen_bus.columns = new_col_names
merged_df1_2 = pd.merge(df_2025_RES_Gen_bus, df_2025_Con_Gen_bus, on='bus', suffixes=('_RESGen', '_ConGen'))
final_df_2025_RES_LC = pd.merge(merged_df1_2, df_2025_loadmax, on='bus')

"""**Visualize the Max Installed Capacity and Load For all Scenarios in a Subplot**"""

sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (14, 6)
fig, (ax1, ax2, ax3) = plt.subplots(1, 3)
plt.subplots_adjust(wspace=0.5, hspace=0.1)
plt.autoscale(tight=True)

# Plot ALL Scenario Data in ax[1]
ax1.cla()
ax1.set_facecolor("white")
ax1.spines[['top', 'right']].set_visible(False)
ax1.set_ylabel('[MW]', size=15, fontweight='bold')
ax1.set_xlabel('Sub-stations', size=20, fontweight='bold')
bar_width = 0.2
r1 = np.arange(len(final_df_2025.bus))
r2 = [x + bar_width for x in r1]
r3 = [x + bar_width for x in r2]
labels = ['Station 1', 'Station 2', 'Station 3', 'Station 4', 'Station 5', 'Station 6',
          'Station 7', 'Station 8', 'Station 9', 'Station 10', 'Station 11', 'Station 12']
labels_series = pd.Series(labels)
ax1.bar(r1, final_df_2025.p_nom_max_2025.values, color='b',
              width=bar_width, edgecolor='grey', label='Max Capacity of RES Generators')
ax1.bar(r2, final_df_2025.Max_Load_2025.values, color='r', width=bar_width,
              edgecolor='grey', label='Max Load')
ax1.bar(r3, final_df_2025.p_nom_2025.values, color='g', width=bar_width,
              edgecolor='grey', label='Max Capacity of Other Generators')
legend1 = ax1.legend(loc='best', ncol=1, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
#ax1.set_title('Some Features of the All Mix Scenario', size=20, fontweight='bold')
fig.text(0.22, -0.01, '(a) All Mix Scenario', ha='center',
            size=14, fontweight='bold')
#axs[0, 0].tick_params(axis='x', rotation=30, labelsize=20)
ax1.tick_params(axis='y', rotation=0, labelsize=20)
ax1.set_xticks([r + 1.5 * bar_width for r in range(len(final_df_2025.bus))])
ax1.set_xticklabels(labels_series, rotation=90)
#axs[1] = plt.gca()
for spine in ax1.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax1.xaxis.grid(True)
ax1.yaxis.grid(True)
ax1.set_yscale('log')

# Plot RES ONLY SCENARIO Data in ax[2]
ax2.cla()
ax2.set_facecolor("white")
ax2.spines[['top', 'right']].set_visible(False)
ax2.set_ylabel('[MW]', size=15, fontweight='bold')
ax2.set_xlabel('Sub-stations', size=20, fontweight='bold')
bar_width = 0.2
r1 = np.arange(len(final_df_2025_RES.bus))
r2 = [x + bar_width for x in r1]
r3 = [x + bar_width for x in r2]
labels = ['Station 1', 'Station 2', 'Station 3', 'Station 4', 'Station 5']
labels_series = pd.Series(labels)
ax2.bar(r1, final_df_2025_RES.p_nom_max_2025.values, color='b',
              width=bar_width, edgecolor='grey', label='Max Installed Capacity of RES')
ax2.bar(r2, final_df_2025_RES.Max_Load_2025.values, color='r', width=bar_width,
              edgecolor='grey', label='Max Load')
legend2 = ax2.legend(loc='best', ncol=1, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
#ax2.set_title('Some Features of the RES only Mix Scenario', size=20, fontweight='bold')
fig.text(0.51, -0.01, '(b) RES only Mix Scenario', ha='center',
            size=14, fontweight='bold')
#ax2.tick_params(axis='x', rotation=30, labelsize=20)
ax2.tick_params(axis='y', rotation=0, labelsize=20)
ax2.set_xticks([r + 1.5 * bar_width for r in range(len(final_df_2025_RES.bus))])
ax2.set_xticklabels(labels_series, rotation=90)
#axs[1] = plt.gca()
for spine in ax2.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax2.xaxis.grid(True)
ax2.yaxis.grid(True)
ax2.set_yscale('log')

# Plot RES AND LOW CARBON CARRIERS SCENARIO Data in ax[3]
ax3.cla()
ax3.set_facecolor("white")
ax3.spines[['top', 'right']].set_visible(False)
ax3.set_ylabel('[MW]', size=15, fontweight='bold')
ax3.set_xlabel('Substation', size=20, fontweight='bold')
bar_width = 0.2
r1 = np.arange(len(final_df_2025_RES_LC.bus))
r2 = [x + bar_width for x in r1]
r3 = [x + bar_width for x in r2]
labels = ['Station 1', 'Station 2', 'Station 3', 'Station 4', 'Station 5', 'Station 6',
          'Station 7', 'Station 8', 'Station 9', 'Station 10', 'Station 11', 'Station 12']
labels_series = pd.Series(labels)
ax3.bar(r1, final_df_2025_RES_LC.p_nom_max_2025.values, color='b',
              width=bar_width, edgecolor='grey', label='Max Installed Capacity of RES')
ax3.bar(r2, final_df_2025_RES_LC.Max_Load_2025.values, color='r', width=bar_width,
              edgecolor='grey', label='Max Load')
ax3.bar(r3, final_df_2025_RES_LC.p_nom_2025.values, color='g', width=bar_width,
              edgecolor='grey', label='Max Capacity of Low Carbon Generators')
legend3 = ax3.legend(loc='best', ncol=1, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend3.get_frame().set_edgecolor('black')
legend3.get_frame().set_linewidth(1)
#ax3.set_title('RES and Low Carbon Mix Scenario', size=20, fontweight='bold')
fig.text(0.83, -0.01, '(c) RES and Low Carbon Mix Scenario', ha='center',
            size=12, fontweight='bold')
#ax3.tick_params(axis='x', rotation=30, labelsize=20)
ax3.tick_params(axis='y', rotation=0, labelsize=20)
ax3.set_xticks([r + 1.5 * bar_width for r in range(len(final_df_2025_RES_LC.bus))])
ax3.set_xticklabels(labels_series, rotation=90)
#axs[1] = plt.gca()
for spine in ax3.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax3.xaxis.grid(True)
ax3.yaxis.grid(True)
ax3.set_yscale('log')
#axs[-1, -1].axis('off')

# Save the plot to a directory in Google Drive
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Prepared_Network_Input_Features.png')
plt.tight_layout()
plt.show()

"""**Visualize the Capital and Marginal Costs of RES and Conventional Generators**"""

sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (14, 6)
fig, (ax1, ax2, ax3) = plt.subplots(1, 3)
plt.subplots_adjust(wspace=0.5, hspace=0.1)
plt.autoscale(tight=True)

# Plot ALL Scenario Data in ax[1]
ax1.cla()
ax1.set_facecolor("white")
ax1.spines[['top', 'right']].set_visible(False)
ax1.set_ylabel('¬£', size=15, fontweight='bold')
ax1.set_xlabel('Sub-stations', size=20, fontweight='bold')
bar_width = 0.2
r1 = np.arange(len(final_df_2025.bus))
r2 = [x + bar_width for x in r1]
r3 = [x + bar_width for x in r2]
r4 = [x + bar_width for x in r3]
labels = ['Station 1', 'Station 2', 'Station 3', 'Station 4', 'Station 5', 'Station 6',
          'Station 7', 'Station 8', 'Station 9', 'Station 10', 'Station 11', 'Station 12']
labels_series = pd.Series(labels)
ax1.bar(r1, final_df_2025.capital_cost_2025_RESGen.values, color='g',
              width=bar_width, edgecolor='grey', label='Capital Cost of RES Generators')
ax1.bar(r2, final_df_2025.capital_cost_2025_ConGen.values, color='y', width=bar_width,
              edgecolor='grey', label='Capital Cost of Other Generators')
ax1.bar(r3, final_df_2025.marginal_cost_2025_RESGen.values, color='orange', width=bar_width,
              edgecolor='grey', label='Marginal Cost of RES Generators')
ax1.bar(r4, final_df_2025.marginal_cost_2025_ConGen.values, color='maroon', width=bar_width,
              edgecolor='grey', label='Marginal Cost of Other Generators')
legend1 = ax1.legend(loc='best', ncol=1, frameon=True, fontsize='8',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
#ax1.set_title('Some Features of the All Mix Scenario', size=20, fontweight='bold')
fig.text(0.22, -0.01, '(a) All Mix Scenario', ha='center',
            size=14, fontweight='bold')
#axs[0, 0].tick_params(axis='x', rotation=30, labelsize=20)
ax1.tick_params(axis='y', rotation=0, labelsize=20)
ax1.set_xticks([r + 1.5 * bar_width for r in range(len(final_df_2025.bus))])
ax1.set_xticklabels(labels_series, rotation=90)
#axs[1] = plt.gca()
for spine in ax1.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax1.xaxis.grid(True)
ax1.yaxis.grid(True)
ax1.set_yscale('log')

# Plot RES ONLY SCENARIO Data in ax[2]
ax2.cla()
ax2.set_facecolor("white")
ax2.spines[['top', 'right']].set_visible(False)
ax2.set_ylabel('¬£', size=15, fontweight='bold')
ax2.set_xlabel('Sub-stations', size=20, fontweight='bold')
bar_width = 0.2
r1 = np.arange(len(final_df_2025_RES.bus))
r2 = [x + bar_width for x in r1]
r3 = [x + bar_width for x in r2]
r4 = [x + bar_width for x in r3]
labels = ['Station 1', 'Station 2', 'Station 3', 'Station 4', 'Station 5']
labels_series = pd.Series(labels)
ax2.bar(r1, final_df_2025_RES.capital_cost_2025_RESGen.values, color='g',
              width=bar_width, edgecolor='grey', label='Capital Cost of RES Generators')
ax2.bar(r2, final_df_2025_RES.capital_cost_2025_ConGen.values, color='y', width=bar_width,
              edgecolor='grey', label='Capital Cost of Other Generators')
ax2.bar(r3, final_df_2025_RES.marginal_cost_2025_RESGen.values, color='orange', width=bar_width,
              edgecolor='grey', label='Marginal Cost of RES Generators')
ax2.bar(r4, final_df_2025_RES.marginal_cost_2025_ConGen.values, color='maroon', width=bar_width,
              edgecolor='grey', label='Marginal Cost of Other Generators')
legend2 = ax2.legend(loc='best', ncol=1, frameon=True, fontsize='8',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
#ax2.set_title('Some Features of the RES only Mix Scenario', size=20, fontweight='bold')
fig.text(0.51, -0.01, '(b) RES only Mix Scenario', ha='center',
            size=14, fontweight='bold')
#ax2.tick_params(axis='x', rotation=30, labelsize=20)
ax2.tick_params(axis='y', rotation=0, labelsize=20)
ax2.set_xticks([r + 1.5 * bar_width for r in range(len(final_df_2025_RES.bus))])
ax2.set_xticklabels(labels_series, rotation=90)
#axs[1] = plt.gca()
for spine in ax2.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax2.xaxis.grid(True)
ax2.yaxis.grid(True)
ax2.set_yscale('log')

# Plot RES AND LOW CARBON CARRIERS SCENARIO Data in ax[3]
ax3.cla()
ax3.set_facecolor("white")
ax3.spines[['top', 'right']].set_visible(False)
ax3.set_ylabel('¬£', size=15, fontweight='bold')
ax3.set_xlabel('Substation', size=20, fontweight='bold')
bar_width = 0.2
r1 = np.arange(len(final_df_2025_RES_LC.bus))
r2 = [x + bar_width for x in r1]
r3 = [x + bar_width for x in r2]
r4 = [x + bar_width for x in r3]
labels = ['Station 1', 'Station 2', 'Station 3', 'Station 4', 'Station 5', 'Station 6',
          'Station 7', 'Station 8', 'Station 9', 'Station 10', 'Station 11', 'Station 12']
labels_series = pd.Series(labels)
ax3.bar(r1, final_df_2025_RES_LC.capital_cost_2025_RESGen.values, color='g',
              width=bar_width, edgecolor='grey', label='Capital Cost of RES Generators')
ax3.bar(r2, final_df_2025_RES_LC.capital_cost_2025_ConGen.values, color='y', width=bar_width,
              edgecolor='grey', label='Capital Cost of RES and Low Carbon Generators')
ax3.bar(r3, final_df_2025_RES_LC.marginal_cost_2025_RESGen.values, color='orange', width=bar_width,
              edgecolor='grey', label='Marginal Cost of RES Generators')
ax3.bar(r4, final_df_2025_RES_LC.marginal_cost_2025_ConGen.values, color='maroon', width=bar_width,
              edgecolor='grey', label='Marginal Cost of RES and Low Carbon Generators')
legend3 = ax3.legend(loc='best', ncol=1, frameon=True, fontsize='8',
        fancybox=True, framealpha=1, shadow=True, borderpad=1, labelspacing=0.2)
legend3.get_frame().set_edgecolor('black')
legend3.get_frame().set_linewidth(1)
#ax3.set_title('RES and Low Carbon Mix Scenario', size=20, fontweight='bold')
fig.text(0.83, -0.01, '(c) RES and Low Carbon Mix Scenario', ha='center',
            size=12, fontweight='bold')
#ax3.tick_params(axis='x', rotation=30, labelsize=20)
ax3.tick_params(axis='y', rotation=0, labelsize=20)
ax3.set_xticks([r + 1.5 * bar_width for r in range(len(final_df_2025_RES_LC.bus))])
ax3.set_xticklabels(labels_series, rotation=90)
#axs[1] = plt.gca()
for spine in ax3.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax3.xaxis.grid(True)
ax3.yaxis.grid(True)
ax3.set_yscale('log')
#axs[-1, -1].axis('off')
# Save the plot to a directory in Google Drive
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Prepared_Network_Input_Features2.png')
plt.tight_layout()
plt.show()

#n_elec_s_6_ec_1copt_Co2L_1H.generators_t.p_max_pu.sum().rename("en_pu").head(50)

"""###**Using the Electricity System Operator (ESO) ETYS 2023 Future Energy System (FES) Data**

The Electricity Ten Year Statement (ETYS) outlines ESO of the National Electricity Transmission System (NETS) over the next ten to twenty years.

The ETYS is the Electricity System Operator‚Äôs (ESO) view of future transmission requirements, and the capability of Great Britain‚Äôs National Electricity Transmission System (NETS) based on their latest Future Energy Scenarios (FES).

The ETYS 2023 enables them to understand what investment and development is required to maintain a safe and reliable operational network, while enabling us to achieve our zero-carbon ambition.

The analysis this year continues to show growing system needs driven primarily by low carbon and renewable generation. This will drive requirements for new network capability as we continue to move towards the 2035 government target of 100% zero carbon electricity system and beyond.

The NETS is otherwise known as the Electricity Transmission network which spans across Great Britain.

The network comprises a mixture of overhead cables,underground cabling and subsea cables ‚Äì the size of these assets varies from of 400kV, 275kV and 132kV assets. These are all linked together via substations across the country that then connect separately owned generators,interconnectors, large demands, and distribution systems.

To identify the future transmission requirements of the GB NETS there are several inputs that are fed into the planning process and at various stages. Amongst whom is the FES Data used to Determine Demand and Generation.

FES are a credible range of scenarios for how energy will be produced and consumed up to 2050.

These scenarios form the foundation of the studies and analysis, and they are used to determine the peak demand and generation capacity regionally.

In this study, we focused on the **"Leading the Way"** scenario up to 2050.

We obtain the Total Demand starting from the Base Year of 2022, 2025, 2030, 2035, 2040, 2045, and 2050.

We considered GB System Peak Demand (Winter), System Minimum (AM) (Wummer) Demand, and System Minimum (PM) (Summer) Demand.

- Winter peak is the highest peak demand in GB, Total demand is the net demand plus distributed generation demand.

###**Base Demand Time series- Year (2022) the Active Power Load Demand For all Generators - Scenario 1**


The Total Demand covers the Residential, Electric Vehicles, Commercial, Industrial, Heat Pumps, District Heat, Transmission Direct Connects, and Electrolysers demand in GB

**Visualize the 2022 Total Load Demand Time Series by ESO Historical Demand**
"""

from matplotlib.lines import Line2D
import matplotlib.pyplot as plt
plt.rc('text', usetex=False)
#sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (16, 12)
fig, axs = plt.subplots(1, 1)
plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)

df_All_2021 = pd.read_csv('/content/gdrive/MyDrive/Energy_System_RL_Modeling_Data/ESO_Historic_Generation_Mix_GB_Demand_System_Prices_2022.csv')
df_All_2021['DATETIME'] = pd.to_datetime(df_All_2021['DATETIME'])
df_All_2021.set_index('DATETIME', inplace=True)
df_All_2021_hourly = df_All_2021.resample('H').mean()
df_All_2021_hourly.reset_index(inplace=True)
load_line = Line2D([0], [0], color='green', linestyle='-', linewidth=2, marker='s')

axs.cla()
axs.set_facecolor("white")
axs.spines[['top', 'right']].set_visible(False)
axs.set_ylabel('[MW]', size=30, fontweight='bold')
axs.set_xlabel('Time [h]', size=28, fontweight='bold')

axs.plot(df_All_2021_hourly[['ND']].values, color='b')
legend_labels = ['Load Demand']
legend = axs.legend(legend_labels, loc='best', ncol=1, frameon=True, fontsize='18',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
axs.tick_params(axis='x', rotation=30, labelsize=20)
axs.tick_params(axis='y', rotation=0, labelsize=20)
#axs[1] = plt.gca()
for spine in axs.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs.xaxis.grid(False)
axs.yaxis.grid(False)
#axs.set_yscale('log')
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Load_Demand_Time_Series_2022.png')
plt.tight_layout()
plt.show()

from matplotlib.lines import Line2D
import matplotlib.pyplot as plt
import pandas as pd

# Set plot style
plt.rc('text', usetex=False)
plt.rcParams["figure.figsize"] = (16, 12)

# Load and preprocess data
df_All_2021 = pd.read_csv('/content/gdrive/MyDrive/Energy_System_RL_Modeling_Data/ESO_Historic_Generation_Mix_GB_Demand_System_Prices_2022.csv')
df_All_2021['DATETIME'] = pd.to_datetime(df_All_2021['DATETIME'])
df_All_2021.set_index('DATETIME', inplace=True)
df_All_2021_hourly = df_All_2021.resample('H').mean()
df_All_2021_hourly.reset_index(inplace=True)

# Define the start and end dates of the seasons (updated to 2022)
seasonal_markers = [
    ("Winter", "2022-01-01", "2022-03-20", "lightblue"),
    ("Spring", "2022-03-21", "2022-06-20", "lightgreen"),
    ("Summer", "2022-06-21", "2022-09-20", "lightyellow"),
    ("Autumn", "2022-09-21", "2022-12-20", "lightcoral"),
    ("Winter (end)", "2022-12-21", "2022-12-31", "lightblue")
]

# Initialize the plot
fig, axs = plt.subplots()
axs.set_facecolor("white")
axs.spines[['top', 'right']].set_visible(False)
axs.set_ylabel('[MW]', size=30, fontweight='bold')
axs.set_xlabel('Time', size=28, fontweight='bold')

# Plot the load demand time series
axs.plot(df_All_2021_hourly['DATETIME'], df_All_2021_hourly['ND'], color='b', label='Load Demand')

# Add seasonal shading without adding labels to avoid duplicate legend entries
for _, start_date, end_date, color in seasonal_markers:
    start = pd.to_datetime(start_date)
    end = pd.to_datetime(end_date)
    axs.axvspan(start, end, color=color, alpha=0.3)

# Create a separate legend for the seasons
season_legend_handles = [
    Line2D([0], [0], color='lightblue', lw=10, alpha=0.5, label='Winter'),
    Line2D([0], [0], color='lightgreen', lw=10, alpha=0.5, label='Spring'),
    Line2D([0], [0], color='lightyellow', lw=10, alpha=0.5, label='Summer'),
    Line2D([0], [0], color='lightcoral', lw=10, alpha=0.5, label='Autumn')
]

# Add the legends for both the line plot and the seasons
axs.legend(
    handles=[Line2D([0], [0], color='b', lw=2, label='Load Demand')] + season_legend_handles,
    loc='best', fontsize=18, frameon=True, fancybox=True
)

# Adjust ticks and grid
axs.tick_params(axis='x', rotation=30, labelsize=20)
axs.tick_params(axis='y', labelsize=20)
for spine in axs.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs.xaxis.grid(False)
axs.yaxis.grid(False)

# Save and show the plot
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.tight_layout()
plt.savefig(f'{output_dir}/Load_Demand_Time_Series_2022_with_Seasons.png')
plt.show()

"""**Visualize ESO ETYS Total Load Demand (Leading the Way) Scenarios from 2022 up to 2025**"""

assumptions = pd.DataFrame(
    columns=["Winter Peak Total Demand", "Summer AM Minimum Demand", "Summer PM Minimum Demand"],
    index=["2022", "2025"],
)
assumptions.at["2022", "Winter Peak Total Demand"] = 58443.3
assumptions.at["2022", "Summer AM Minimum Demand"] = 20162.5
assumptions.at["2022", "Summer PM Minimum Demand"] = 33134

assumptions.at["2025", "Winter Peak Total Demand"] = 55624
assumptions.at["2025", "Summer AM Minimum Demand"] = 21616.9
assumptions.at["2025", "Summer PM Minimum Demand"] = 36920.8

# Plotting all plants in one grouped bar plot
from matplotlib.lines import Line2D
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (16, 12)
fig, axs = plt.subplots(1, 1)
plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)
axs.cla()
axs.set_facecolor("white")
axs.spines[['top', 'right']].set_visible(False)
axs.set_ylabel('[MW]', size=35, fontweight='bold')
axs.set_xlabel('Scenario Year', size=28, fontweight='bold')
bar_width = 0.2
year = ['2022', '2025']
r1 = np.arange(len(year))
r2 = [x + bar_width for x in r1]
r3 = [x + bar_width for x in r2]
axs.bar(r1, assumptions['Winter Peak Total Demand'].values, width=bar_width,
        color='b', edgecolor='grey', label='Winter Peak Demand')
axs.bar(r2, assumptions['Summer AM Minimum Demand'].values, width=bar_width,
        color='r', edgecolor='grey', label='Summer AM Min Demand')
axs.bar(r3, assumptions['Summer PM Minimum Demand'].values, width=bar_width,
        color='g', edgecolor='grey', label='Summer PM Min Demand')
legend = axs.legend(loc='best', ncol=1, frameon=True, fontsize='16',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
axs.tick_params(axis='x', rotation=30, labelsize=20)
axs.tick_params(axis='y', rotation=0, labelsize=20)
#axs[1] = plt.gca()
for spine in axs.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs.xaxis.grid(False)
axs.yaxis.grid(False)
#axs.set_yscale('log')
axs.set_xticks([r + 1.5 * bar_width for r in range(len(year))])
axs.set_xticklabels(year, rotation=30)
# Save the plot to a directory
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(
    f'{output_dir}/ESO_ETYS_Total_Load_Demand_Scenarios_2025.png')
# Show the plot
plt.tight_layout()
plt.show()

"""**Obtain the Scaling Factor to Extrapolate the Base Year (2022) Load Demand Time Series to Other Future Scenarios**"""

print('===================================================')
max_demand_2022 = df_All_2021_hourly['ND'].max()
print('Maximum Load Demand - 2022 is: {:.2f}'.format(max_demand_2022))
print('===================================================')
max_demand_2025 = 55624
scaling_factor_2025 = max_demand_2022 / max_demand_2025
print('Maximum Load Demand - 2025 is: {}, Scaling Factor is: {}'.format(
    max_demand_2025, scaling_factor_2025))
print('===================================================')
max_demand_2030 = 62753
scaling_factor_2030 = max_demand_2022 / max_demand_2030
print('Maximum Load Demand - 2030 is: {}, Scaling Factor is: {}'.format(
    max_demand_2030, scaling_factor_2030))
print('===================================================')
max_demand_2035 = 79558
scaling_factor_2035 = max_demand_2022 / max_demand_2035
print('Maximum Load Demand - 2035 is: {}, Scaling Factor is: {}'.format(
    max_demand_2035, scaling_factor_2035))
print('===================================================')
max_demand_2040 = 91172
scaling_factor_2040 = max_demand_2022 / max_demand_2040
print('Maximum Load Demand - 2040 is: {}, Scaling Factor is: {}'.format(
    max_demand_2040, scaling_factor_2040))
print('===================================================')
max_demand_2045 = 94354
scaling_factor_2045 = max_demand_2022 / max_demand_2045
print('Maximum Load Demand - 2045 is: {}, Scaling Factor is: {}'.format(
    max_demand_2045, scaling_factor_2045))
print('===================================================')
max_demand_2050 = 93277
scaling_factor_2050 = max_demand_2022 / max_demand_2050
print('Maximum Load Demand - 2050 is: {}, Scaling Factor is: {}'.format(
    max_demand_2050, scaling_factor_2050))
print('===================================================')

"""**Visualize the 2025 Total Load Demand Time Series - Projected**"""

demand_2025 = df_All_2021_hourly[['ND']] / scaling_factor_2025
df_length = len(demand_2025)
demand_2025['Datetime'] = pd.date_range(start="2025-01-01", periods=df_length, freq="H")
demand_2025["region_code"] = "GB"
demand_2025["region_name"] = "United Kingdom"
csv_file_name = "Europe_2025.csv"
with open(csv_file_name, mode='w', newline='') as file:
    writer = csv.DictWriter(file, fieldnames=["region_code", "time", "region_name", "Electricity demand"], delimiter=';')
    writer.writeheader()
    for _, row in demand_2025.iterrows():
        writer.writerow({
            "region_code": row["region_code"],
            "time": row["Datetime"].strftime("%Y-%m-%d %H:%M:%S"),
            "region_name": row["region_name"],
            "Electricity demand": row["ND"]
        })
print(f"CSV file '{csv_file_name}' created successfully.")
df = pd.read_csv('Europe_2025.csv', delimiter=';')
ds = xr.Dataset(
    {
        'Electricity demand': (['region_code', 'time'], df['Electricity demand'].values.reshape((1, -1))),
    },
    coords={
        'time': pd.to_datetime(df['time']),
        'region_code': df['region_code'].unique(),
        'region_name': df['region_name'].unique(),
    },
)
ds.to_netcdf('/content/gdrive/MyDrive/Energy_System_Modelling_GB/Europe_2025.nc')

"""**Visualize the 2030 Total Load Demand Time Series - Projected**"""

demand_2030 = df_All_2021_hourly[['ND']] / scaling_factor_2030
df_length = len(demand_2030)
demand_2030['Datetime'] = pd.date_range(start="2030-01-01", periods=df_length, freq="H")
demand_2030["region_code"] = "GB"
demand_2030["region_name"] = "United Kingdom"
csv_file_name = "Europe_2030.csv"
with open(csv_file_name, mode='w', newline='') as file:
    writer = csv.DictWriter(file, fieldnames=["region_code", "time", "region_name", "Electricity demand"], delimiter=';')
    writer.writeheader()
    for _, row in demand_2030.iterrows():
        writer.writerow({
            "region_code": row["region_code"],
            "time": row["Datetime"].strftime("%Y-%m-%d %H:%M:%S"),
            "region_name": row["region_name"],
            "Electricity demand": row["ND"]
        })
print(f"CSV file '{csv_file_name}' created successfully.")
df = pd.read_csv('Europe_2030.csv', delimiter=';')
ds = xr.Dataset(
    {
        'Electricity demand': (['region_code', 'time'], df['Electricity demand'].values.reshape((1, -1))),
    },
    coords={
        'time': pd.to_datetime(df['time']),
        'region_code': df['region_code'].unique(),
        'region_name': df['region_name'].unique(),
    },
)
ds.to_netcdf('/content/gdrive/MyDrive/Energy_System_Modelling_GB/Europe_2030.nc')

"""**Visualize the 2035 Total Load Demand Time Series - Projected**"""

demand_2035 = df_All_2021_hourly[['ND']] / scaling_factor_2035
df_length = len(demand_2035)
demand_2035['Datetime'] = pd.date_range(start="2035-01-01", periods=df_length, freq="H")
demand_2035["region_code"] = "GB"
demand_2035["region_name"] = "United Kingdom"
csv_file_name = "Europe_2035.csv"
with open(csv_file_name, mode='w', newline='') as file:
    writer = csv.DictWriter(file, fieldnames=["region_code", "time", "region_name", "Electricity demand"], delimiter=';')
    writer.writeheader()
    for _, row in demand_2035.iterrows():
        writer.writerow({
            "region_code": row["region_code"],
            "time": row["Datetime"].strftime("%Y-%m-%d %H:%M:%S"),
            "region_name": row["region_name"],
            "Electricity demand": row["ND"]
        })
print(f"CSV file '{csv_file_name}' created successfully.")
df = pd.read_csv('Europe_2035.csv', delimiter=';')
ds = xr.Dataset(
    {
        'Electricity demand': (['region_code', 'time'], df['Electricity demand'].values.reshape((1, -1))),
    },
    coords={
        'time': pd.to_datetime(df['time']),
        'region_code': df['region_code'].unique(),
        'region_name': df['region_name'].unique(),
    },
)
ds.to_netcdf('/content/gdrive/MyDrive/Energy_System_Modelling_GB/Europe_2035.nc')

"""**Visualize the 2040 Total Load Demand Time Series - Projected**"""

demand_2040 = df_All_2021_hourly[['ND']] / scaling_factor_2040
df_length = len(demand_2040)
demand_2040['Datetime'] = pd.date_range(start="2040-01-01", periods=df_length, freq="H")
demand_2040["region_code"] = "GB"
demand_2040["region_name"] = "United Kingdom"
csv_file_name = "Europe_2040.csv"
with open(csv_file_name, mode='w', newline='') as file:
    writer = csv.DictWriter(file, fieldnames=["region_code", "time", "region_name", "Electricity demand"], delimiter=';')
    writer.writeheader()
    for _, row in demand_2040.iterrows():
        writer.writerow({
            "region_code": row["region_code"],
            "time": row["Datetime"].strftime("%Y-%m-%d %H:%M:%S"),
            "region_name": row["region_name"],
            "Electricity demand": row["ND"]
        })
print(f"CSV file '{csv_file_name}' created successfully.")
df = pd.read_csv('Europe_2040.csv', delimiter=';')
ds = xr.Dataset(
    {
        'Electricity demand': (['region_code', 'time'], df['Electricity demand'].values.reshape((1, -1))),
    },
    coords={
        'time': pd.to_datetime(df['time']),
        'region_code': df['region_code'].unique(),
        'region_name': df['region_name'].unique(),
    },
)
ds.to_netcdf('/content/gdrive/MyDrive/Energy_System_Modelling_GB/Europe_2040.nc')

"""**Visualize the 2045 Total Load Demand Time Series - Projected**"""

demand_2045 = df_All_2021_hourly[['ND']] / scaling_factor_2045
df_length = len(demand_2045)
demand_2045['Datetime'] = pd.date_range(start="2045-01-01", periods=df_length, freq="H")
demand_2045["region_code"] = "GB"
demand_2045["region_name"] = "United Kingdom"
csv_file_name = "Europe_2045.csv"
with open(csv_file_name, mode='w', newline='') as file:
    writer = csv.DictWriter(file, fieldnames=["region_code", "time", "region_name", "Electricity demand"], delimiter=';')
    writer.writeheader()
    for _, row in demand_2045.iterrows():
        writer.writerow({
            "region_code": row["region_code"],
            "time": row["Datetime"].strftime("%Y-%m-%d %H:%M:%S"),
            "region_name": row["region_name"],
            "Electricity demand": row["ND"]
        })
print(f"CSV file '{csv_file_name}' created successfully.")
df = pd.read_csv('Europe_2045.csv', delimiter=';')
ds = xr.Dataset(
    {
        'Electricity demand': (['region_code', 'time'], df['Electricity demand'].values.reshape((1, -1))),
    },
    coords={
        'time': pd.to_datetime(df['time']),
        'region_code': df['region_code'].unique(),
        'region_name': df['region_name'].unique(),
    },
)
ds.to_netcdf('/content/gdrive/MyDrive/Energy_System_Modelling_GB/Europe_2045.nc')

"""**2050**"""

demand_2050 = df_All_2021_hourly[['ND']] / scaling_factor_2050
df_length = len(demand_2050)
demand_2050['Datetime'] = pd.date_range(start="2050-01-01", periods=df_length, freq="H")
demand_2050["region_code"] = "GB"
demand_2050["region_name"] = "United Kingdom"
csv_file_name = "Europe_2050.csv"
with open(csv_file_name, mode='w', newline='') as file:
    writer = csv.DictWriter(file, fieldnames=["region_code", "time", "region_name", "Electricity demand"], delimiter=';')
    writer.writeheader()
    for _, row in demand_2050.iterrows():
        writer.writerow({
            "region_code": row["region_code"],
            "time": row["Datetime"].strftime("%Y-%m-%d %H:%M:%S"),
            "region_name": row["region_name"],
            "Electricity demand": row["ND"]
        })
print(f"CSV file '{csv_file_name}' created successfully.")
df = pd.read_csv('Europe_2050.csv', delimiter=';')
ds = xr.Dataset(
    {
        'Electricity demand': (['region_code', 'time'], df['Electricity demand'].values.reshape((1, -1))),
    },
    coords={
        'time': pd.to_datetime(df['time']),
        'region_code': df['region_code'].unique(),
        'region_name': df['region_name'].unique(),
    },
)
ds.to_netcdf('/content/gdrive/MyDrive/Energy_System_Modelling_GB/Europe_2050.nc')

"""###**Access the Demand Timeseries**"""

demand_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/Europe_2025.nc"
demand_2025 = xr.open_dataset(demand_path)
'''demand_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/Europe_2030.nc"
demand_2030 = xr.open_dataset(demand_path)
demand_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/Europe_2035.nc"
demand_2035 = xr.open_dataset(demand_path)
demand_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/Europe_2040.nc"
demand_2040 = xr.open_dataset(demand_path)
demand_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/Europe_2045.nc"
demand_2045 = xr.open_dataset(demand_path)
demand_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/Europe_2050.nc"
demand_2050 = xr.open_dataset(demand_path)'''

"""###**Create The Electricity Demand Profile**

**Using 2025 Load Demand Scenario**
"""

start_date = "2022-01-01"
end_date = "2023-01-01"
scale = 1
out_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/demand_profiles_2025.csv"
def normed(s):
    return s / s.sum()
load_paths = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/Europe_2025.nc"
def shapes_to_shapes(orig, dest):
    orig_prepped = list(map(prep, orig))
    transfer = sparse.lil_matrix((len(dest), len(orig)), dtype=float)
    for i, j in product(range(len(dest)), range(len(orig))):
        if orig_prepped[j].intersects(dest[i]):
            area = orig[j].intersection(dest[i]).area
            transfer[i, j] = area / dest[i].area
    return transfer
network_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec.nc"
n_elec = pypsa.Network(network_path)
substation_lv_i = n_elec.buses.index[n_elec.buses["substation_lv"]]
regions = '/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/regions_onshore.geojson'
admin_shapes = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/gadm_shapes.geojson"
regions = gpd.read_file(regions).set_index("name").reindex(substation_lv_i)
load_paths = load_paths
gegis_load = xr.open_mfdataset(load_paths, combine="nested")
gegis_load["Electricity demand"] *= scale
shapes = gpd.read_file(admin_shapes).set_index("GADM_ID")
shapes["geometry"] = shapes["geometry"].apply(lambda x: make_valid(x))
#l = gegis_load.loc[gegis_load.region_code == cntry]["Electricity demand"]
l = gegis_load.sel(region_code='GB')["Electricity demand"]
shapes_cntry = shapes.loc[shapes.country == 'GB']
country = 'GB'
group = regions.geometry[regions.country == country]
transfer = shapes_to_shapes(group, shapes_cntry.geometry).T.tocsr()
gdp_n = pd.Series(
    transfer.dot(shapes_cntry["gdp"].fillna(1.0).values), index=group.index
)
pop_n = pd.Series(
    transfer.dot(shapes_cntry["pop"].fillna(1.0).values), index=group.index
)
factors = normed(0.6 * normed(gdp_n) + 0.4 * normed(pop_n))
RES = pd.DataFrame(factors.values * l.values[:, np.newaxis],
                   index=pd.date_range(start=start_date, end=end_date, freq='H', inclusive ='left'),
                   columns=factors.index,
                   )
existing_df = pd.DataFrame()  # Initialize a new DataFrame if none exists
demand_profiles = pd.concat([existing_df, RES], axis=0)
demand_profiles.index.name = 'time'
demand_profiles.to_csv(out_path, header=True)

"""###**Modifying Cost Assumptions**

The database of cost assumptions retrieved from the repository PyPSA/technology-data is modified manually.

The Energy System Technology Data compiles assumptions on energy system technologies (such as costs, efficiencies, lifetimes, etc.) for chosen years (e.g. [2020, 2030, 2050]) from a variety of sources into CSV files to be read by energy system modelling software.

It is maintained by the Photovoltaic Solar Energy group at the Department of Engineering at Aarhus University and the Department of Digital Transformation in Energy Systems at the Technische Universit√§t Berlin.

Copyright 2019-2020 Marta Victoria (Aarhus University), Kun Zhu (Aarhus University), Elisabeth Zeyen (TUB), Tom Brown (TUB).

- We convert the EUR to ¬£ (Pounds) using 1 EUR to 0.85 ¬£ as at 11/02/2024


"""

# 2025
df_cost_2025 = pd.read_csv('/content/gdrive/MyDrive/Energy_System_Modelling_GB/costs_2025 (1).csv')
df_cost_2025['unit'] = df_cost_2025['unit'].str.replace('EUR/', '¬£/')
gbp_rows = df_cost_2025[df_cost_2025['unit'].str.startswith('¬£/')]
gbp_rows['value'] *= 0.85
df_cost_2025.update(gbp_rows)
out_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/cost_2025.csv"
df_cost_2025.to_csv(out_path, header=True)
# 2030
df_cost_2030 = pd.read_csv('/content/gdrive/MyDrive/Energy_System_Modelling_GB/costs_2030 (1).csv')
df_cost_2030['unit'] = df_cost_2030['unit'].str.replace('EUR/', '¬£/')
gbp_rows = df_cost_2030[df_cost_2030['unit'].str.startswith('¬£/')]
gbp_rows['value'] *= 0.85
df_cost_2030.update(gbp_rows)
out_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/cost_2030.csv"
df_cost_2030.to_csv(out_path, header=True)
# 2035
df_cost_2035 = pd.read_csv('/content/gdrive/MyDrive/Energy_System_Modelling_GB/costs_2035 (1).csv')
df_cost_2035['unit'] = df_cost_2035['unit'].str.replace('EUR/', '¬£/')
gbp_rows = df_cost_2035[df_cost_2035['unit'].str.startswith('¬£/')]
gbp_rows['value'] *= 0.85
df_cost_2035.update(gbp_rows)
out_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/cost_2035.csv"
df_cost_2035.to_csv(out_path, header=True)
# 2040
df_cost_2040 = pd.read_csv('/content/gdrive/MyDrive/Energy_System_Modelling_GB/costs_2040 (1).csv')
df_cost_2040['unit'] = df_cost_2040['unit'].str.replace('EUR/', '¬£/')
gbp_rows = df_cost_2040[df_cost_2040['unit'].str.startswith('¬£/')]
gbp_rows['value'] *= 0.85
df_cost_2040.update(gbp_rows)
out_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/cost_2040.csv"
df_cost_2040.to_csv(out_path, header=True)
# 2045
df_cost_2045 = pd.read_csv('/content/gdrive/MyDrive/Energy_System_Modelling_GB/costs_2045 (1).csv')
df_cost_2045['unit'] = df_cost_2045['unit'].str.replace('EUR/', '¬£/')
gbp_rows = df_cost_2045[df_cost_2045['unit'].str.startswith('¬£/')]
gbp_rows['value'] *= 0.85
df_cost_2045.update(gbp_rows)
out_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/cost_2045.csv"
df_cost_2045.to_csv(out_path, header=True)
# 2050
df_cost_2050 = pd.read_csv('/content/gdrive/MyDrive/Energy_System_Modelling_GB/costs_2050 (1).csv')
df_cost_2050['unit'] = df_cost_2050['unit'].str.replace('EUR/', '¬£/')
gbp_rows = df_cost_2050[df_cost_2050['unit'].str.startswith('¬£/')]
gbp_rows['value'] *= 0.85
df_cost_2050.update(gbp_rows)
out_path = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/cost_2050.csv"
df_cost_2050.to_csv(out_path, header=True)

"""#**Analyse the solved networks deterministically**

##**Scenario 1 : All Mix - Conventional and Renewable Generators**
"""

network = pypsa.Network("/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/elec_s_6_ec_lcopt_Co2L-1H.nc")
n = network
n

"""**Average Marginal Electricity Price**"""

avg_marg_price_2025_All_Mix = (n.buses_t.marginal_price.mean(axis=0).mean() * 0.84)
print('=====================')
print(avg_marg_price_2025_All_Mix) # convert to pounds
print('=====================')

"""**Visualize the Hourly Average Marginal Price of Electricity (¬£/MWh)**"""

matplotlib.rc('text', usetex=False)
mean_marginal_price_All_Mix = (n.buses_t.marginal_price.mean(axis=1) * 0.84)
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (12, 8)
fig, axs = plt.subplots(1, 1)
plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)
axs.cla()
axs.set_facecolor("white")
axs.spines[['top', 'right']].set_visible(False)
axs.set_ylabel('[¬£/MWh]', size=18, fontweight='bold')
axs.set_xlabel('Time [h]', size=18, fontweight='bold')
axs.plot(mean_marginal_price_All_Mix.resample('H').mean(), color = plt.cm.tab10(3),
         linewidth = 2.0, linestyle='dashed', drawstyle = 'steps-mid')
legend_labels = ['Average Marginal Price of Electricity']
legend = axs.legend(legend_labels, loc='best', ncol=1, frameon=True, fontsize='14',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
axs.tick_params(axis='x', rotation=30, labelsize=15)
axs.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in axs.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs.xaxis.grid(False)
axs.yaxis.grid(False)
axs.xaxis.set_major_formatter(mdates.DateFormatter('%b'))
#axs.set_yscale('log')
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Average_Marginal_Price_Time_Series_2022.png')
plt.tight_layout()
plt.show()

"""**Total Annual System Costs**"""

print('===========================================')
tot_annual_sys_cost_2025_All_Mix = (n.objective / 1e9 * 0.84) # Billion Pounds per annum = n.objective / 1e9 # Billion Euro per annum
print(f'total annual system cost is:', tot_annual_sys_cost_2025_All_Mix)
total_load = n.loads_t.p.sum().sum()
print('===========================================')
print(f' total load is:', total_load)
print('==========================================')

"""**CO2 Emissions and Price**"""

print('=========================================================')
co2_emi = ((n.generators_t.p.multiply(
    n.snapshot_weightings, axis=0)).sum(
    ) / n.generators.efficiency * n.generators.carrier.map(n.carriers.co2_emissions)
    ).sum()
print(f"CO‚ÇÇ Emissions: {int(np.round(co2_emi*0.84 / 1e6))} MtCO‚ÇÇ / annum")
print('==========================================================')
print(f"CO‚ÇÇ Emissions Price: {int(np.round(n.global_constraints.mu *0.84))} ¬£ /tCO‚ÇÇe / annum")
print('==========================================================')

"""**Visualize Energy Storage Outputs Over time**"""

sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (12, 8)
fig, (axs1, axs2) = plt.subplots(2, 1)
#plt.subplots_adjust(wspace=0.2, hspace=0.8)
plt.autoscale(tight=True)
axs1.cla()
axs1.set_facecolor("white")
axs1.spines[['top', 'right']].set_visible(False)
axs1.set_ylabel('[MWh]', size=15, fontweight='bold')
#axs1.set_xlabel('Time [h]', size=15, fontweight='bold')
n.storage_units_t.state_of_charge.mean(axis=1).resample('W').mean().plot.area(ax=axs1, color = plt.cm.tab10(5),
         label = 'State of Charge', xlabel='')
axs2.cla()
axs2.set_facecolor("white")
axs2.spines[['top', 'right']].set_visible(False)
axs2.set_ylabel('[MWh]', size=15, fontweight='bold')
axs2.set_xlabel('Time [h]', size=15, fontweight='bold')
n.storage_units_t.p_dispatch.mean(axis=1).resample('W').mean().plot.area(ax=axs2, color = plt.cm.tab10(3),
         label = 'Power Dispatch', xlabel='')
n.storage_units_t.p_store.mean(axis=1).resample('W').mean().plot.area(ax=axs2, color = plt.cm.tab10(2),
         label = 'Power Charging', xlabel='')
legend1 = axs1.legend(loc='best', ncol=1, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
legend2 = axs2.legend(loc='best', ncol=1, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
#axs1.set_xlabel('Time [h]', size=15, fontweight='bold')
#axs1.tick_params('axis='x', rotation=30, labelsize=10')
axs1.tick_params(axis='y', rotation=0, labelsize=10)
#axs[1] = plt.gca()
for spine in axs1.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs1.xaxis.grid(False)
axs1.yaxis.grid(False)
axs1.xaxis.set_major_formatter(mdates.DateFormatter('%b'))
axs2.set_xlabel('Time [h]', size=15, fontweight='bold')
axs2.tick_params(axis='x', rotation=30, labelsize=10)
axs2.tick_params(axis='y', rotation=0, labelsize=10)
#axs[1] = plt.gca()
for spine in axs2.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs2.xaxis.grid(False)
axs2.yaxis.grid(False)
axs2.xaxis.set_major_formatter(mdates.DateFormatter('%b'))
fig.text(0.5, 0.52, '(a) Energy Storage Units State of Charge', ha='center',
            size=14, fontweight='bold')
fig.text(0.5, -0.01, '(b) Battery Charge and Discharge', ha='center',
            size=14, fontweight='bold')
#axs.set_yscale('log')
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Storage_Units_Outputs_Time_Series_2022.png')
plt.tight_layout()
plt.subplots_adjust(wspace=0.2, hspace=0.5)
plt.show()

"""###**Network Statistics**

It is possible to get direct analysis values of the network and plot them, including Capacity Factor, Capital Expenditure, Curtailment, Installed Capacity, Operational Expenditure, Optimal Capacity, Revenue, Supply and Withdrawal
"""

stat_All_Mix = n.statistics()
print(stat_All_Mix.to_markdown())
# Note: the "load" in the generators represents the Demand Side Response
# to match the power demand with the supply.

"""**Obtain the Optimized Average System Cost Per Unit of Generated Energy in ¬£/MWh**"""

selected_categories = n.statistics().index.get_level_values(1)
df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
#df['Avg_Sys_Cost'] = ((df['Capital Expenditure'] + df['Operational Expenditure']) / total_load)*0.84
df['Tot_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure'])*0.84
Gen_Elec = df['Supply'].sum()
df['Avg_Sys_Cost'] = df['Tot_Sys_Cost'] / Gen_Elec
df_ = (df.groupby(level=1).sum()).fillna(0)
avg_total_sys_cost_allmix = df_['Avg_Sys_Cost'].sum()
print(f'Average Total Systen Cost in ¬£/MWh is:', avg_total_sys_cost_allmix)
avg_sys_cost_tech_allmix = df_[['Avg_Sys_Cost']]
print(
    f'Average Systen Cost in ¬£/MWh For Each Technology is', avg_sys_cost_tech_allmix.to_markdown())

"""**Obtain the Optimized Annual Energy Generation in % of the Annual Energy Demand**"""

selected_categories = ['Battery Storage', 'Biomass', 'Coal', 'Combined-Cycle Gas',
                      'Hydrogen Storage', 'Nuclear', 'Offshore Wind (AC)',
                      'Offshore Wind (DC)', 'Oil', 'Onshore Wind', 'Run of River', 'Solar']
df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
total_load = n.loads_t.p.sum().sum()
Annual_gen = df['Supply']
df['Annual Gen % of Load'] = (Annual_gen / total_load) * 100
df_ = (df.groupby(level=1).sum()).fillna(0)
Total_energy_allmix = df_['Annual Gen % of Load'].sum()
print(f'Total Energy is:', Total_energy_allmix)
print(df_[['Annual Gen % of Load']].to_markdown())

"""**Validate Results By Comparing With The UK Energy Projections for the Year 2025**"""



"""###**Plot the Dispatch of the Different Carriers and Electricity Prices**"""

from pypsa.statistics import get_bus_and_carrier
from snakemake.utils import update_config
from entsoe import EntsoePandasClient
from entsoe.exceptions import NoMatchingDataError

'''carrier_grouper = {
    "Waste": "Biomass",
    "Hydro Pumped Storage": "Hydro",
    "Hydro Water Reservoir": "Hydro",
    "Hydro Run-of-river and poundage": "Run of River",
    "Fossil Coal-derived gas": "Gas",
    "Fossil Gas": "Gas",
    "Fossil Oil": "Oil",
    "Fossil Oil shale": "Oil",
    "Fossil Brown coal/Lignite": "Lignite",
    "Fossil Peat": "Lignite",
    "Fossil Hard coal": "Coal",
    "Wind Onshore": "Onshore Wind",
    "Wind Offshore": "Offshore Wind",
    "Other renewable": "Other",
    "Marine": "Other",
}
api_key = "4f5f60b8-7902-41d2-829c-e975148e4f13"
client = EntsoePandasClient(api_key=api_key)
start = pd.Timestamp('20210101', tz='Europe/Brussels')
end = pd.Timestamp('20220101', tz='Europe/Brussels')
country_code = 'GB'
generation = []
unavailable_countries = []
gen = client.query_generation(country_code, start=start, end=end, nett=True)
gen = gen.tz_localize(None).resample("1h").mean()
gen = gen.loc[start.tz_localize(None) : end.tz_localize(None)]
gen = gen.rename(columns=carrier_grouper).T.groupby(level=0).sum().T
generation.append(gen)
generation = pd.concat(generation, axis=1)'''
#generation.to_csv('/content/gdrive/MyDrive/Energy_System_Modelling_GB/entsoe.csv')

sns.set_theme("paper", style="whitegrid")
carrier_groups = {
    "Offshore Wind (AC)": "Offshore Wind",
    "Offshore Wind (DC)": "Offshore Wind",
    "Open-Cycle Gas": "Gas",
    "Combined-Cycle Gas": "Gas",
    "Reservoir & Dam": "Hydro",
    "Pumped Hydro Storage": "Hydro",
}
n.loads.carrier = "load"
colors = n.carriers.set_index("nice_name").color.where(
    lambda s: s != "", "lightgrey")
colors["Offshore Wind"] = colors["Offshore Wind (AC)"]
colors["Gas"] = colors["Combined-Cycle Gas"]
colors["Hydro"] = colors["Reservoir & Dam"]
colors["load"] = "teal"
colors["Other"] = "lightgray"
# Dispatch
optimized = n.statistics.dispatch(groupby=get_bus_and_carrier, aggregate_time=False).T
optimized = optimized[["Generator", "StorageUnit"]].droplevel(0, axis=1)
optimized = optimized.rename(columns=n.buses.country, level=0)
optimized = optimized.rename(columns=carrier_groups, level=1)
optimized = optimized.groupby(axis=1, level=[0, 1]).sum()
data_dispatch = pd.concat([optimized], keys=["Optimized"], axis=1)
data_dispatch.columns.names = ["Kind", "Country", "Carrier"]
data_dispatch = data_dispatch.mul(n.snapshot_weightings.generators, axis=0)
# Dispatch
optimized = n.statistics.dispatch(groupby=get_bus_and_carrier, aggregate_time=False).T
optimized = optimized[["Generator", "StorageUnit"]].droplevel(0, axis=1)
optimized = optimized.rename(columns=n.buses.country, level=0)
optimized = optimized.rename(columns=carrier_groups, level=1)
optimized = optimized.groupby(axis=1, level=[0, 1]).sum()
data_dispatch = pd.concat([optimized], keys=["Optimized"], axis=1)
data_dispatch.columns.names = ["Kind", "Country", "Carrier"]
data_dispatch = data_dispatch.mul(n.snapshot_weightings.generators, axis=0)
# Electricity Price
optimized = n.buses_t.marginal_price.groupby(n.buses.country, axis=1).mean()
data = pd.concat([optimized], keys=["Optimized"], axis=1)
data.columns.names = ["Kind", "Country"]
df_price = data.groupby(level="Kind", axis=1).mean()
# seasonal operation
sns.set_theme(style='whitegrid')
fig, axes = plt.subplots(1, 1, figsize=(12, 6))
plt.subplots_adjust(wspace=0.3, hspace=0.3)
plt.autoscale(tight=True)
axes.cla()
axes.set_facecolor("white")
axes.spines[['top', 'right']].set_visible(False)
axes.set_xlabel('Time (h)', size=30, fontweight='bold')
axes.set_ylabel('Production [GW]', size=20, fontweight='bold')
df = (data_dispatch.groupby(
    level=["Kind", "Carrier"], axis=1).sum().resample("1W").mean().clip(lower=0))
df = df / 1e3 # GW
order = (
    (df["Optimized"].diff().abs().sum() / df["Optimized"].sum()).sort_values().index)
c = colors[order]
optimized_dispatch = df["Optimized"].reindex(order, axis=1, level=1)
kwargs = dict(color=c, legend=False)
optimized_dispatch.plot.area(ax=axes, **kwargs, title="", xlabel='')
axes.tick_params(axis='x', rotation=30, labelsize=20)
axes.tick_params(axis='y', rotation=0, labelsize=20)
for spine in axes.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axes.xaxis.grid(False)
axes.yaxis.grid(False)
axes.set_xlabel('Time (h)', size=20, fontweight='bold')
#axes.xaxis.set_major_formatter(mdates.DateFormatter('%b'))
'''axes[1].cla()
axes[1].set_facecolor("white")
axes[1].spines[['top', 'right']].set_visible(False)
axes[1].set_xlabel('Time (h)', size=25, fontweight='bold')
axes[1].set_ylabel('Price [¬£/MWh]', size=22, fontweight='bold')
df_price.plot(ax=axes[1], alpha=0.8, color = plt.cm.tab10(3), linewidth = '2.8', legend=False,
              xlabel = 'Time [h]', linestyle='dashed', drawstyle = 'steps-mid')
axes[1].tick_params(axis='x', rotation=30, labelsize=20)
axes[1].tick_params(axis='y', rotation=0, labelsize=20)
for spine in axes[1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axes[1].xaxis.grid(False)
axes[1].yaxis.grid(False)
axes[1].xaxis.set_major_formatter(mdates.DateFormatter('%b'))'''

h, l = axes.get_legend_handles_labels()
legend1 = fig.legend(
    h[::-1],
    l[::-1],
    loc="center left",
    bbox_to_anchor=(0.93, 0.5),
    title="Generators and Storage Units",
    title_fontsize=15,
    fontsize=14, frameon=True, framealpha=1, borderpad=1,
    ncol=1, labelcolor="black", facecolor="white",
    #frameon=False,
    labelspacing=1,
)
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
'''h1, l1 = axes[1].get_legend_handles_labels()
legend2 = fig.legend(h1[::-1], l1[::-1], loc="upper left",
           bbox_to_anchor=(0.93, 0.4),
           labelspacing=2.5,
           title="Average Electricity Price",
           title_fontsize=15,
           fontsize=14, frameon=True, framealpha=1, borderpad=1,
           ncol=1, labelcolor="black", facecolor="white")
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
fig.text(0.5, 0.0, '(a) Dispatch Units Outputs', ha='center',
            size=20, fontweight='bold')
fig.text(0.5, -0.05, '(b) Average Marginal Electricty Price', ha='center',
            size=20, fontweight='bold')'''
fig.savefig("UK-2025-total_dispatch_carrier_operation_price.pdf", bbox_inches="tight")

"""###**Extract and Make Results Summaries**"""

import cartopy.crs as ccrs
path_country_shapes = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/country_shapes.geojson"
countries = gpd.read_file(path_country_shapes)
def make_handler_map_to_scale_circles_as_in(ax, dont_resize_actively=False):
    fig = ax.get_figure()
    def axes2pt():
        return np.diff(ax.transData.transform([(0, 0), (1, 1)]), axis=0)[0] * (
            100.0 / fig.dpi)
    ellipses = []
    if not dont_resize_actively:
        def update_width_height(event):
            dist = axes2pt()
            for e, radius in ellipses:
                e.width, e.height = 2.0 * radius * dist
        fig.canvas.mpl_connect("resize_event", update_width_height)
        ax.callbacks.connect("xlim_changed", update_width_height)
        ax.callbacks.connect("ylim_changed", update_width_height)
    def legend_circle_handler(
        legend, orig_handle, xdescent, ydescent, width, height, fontsize
    ):
        w, h = 2.0 * orig_handle.get_radius() * axes2pt()
        e = Ellipse(
            xy=(0.5 * width - 0.5 * xdescent, 0.5 * height - 0.5 * ydescent),
            width=w, height=w)
        ellipses.append((e, orig_handle.get_radius()))
        return e
    return {Circle: HandlerPatch(patch_func=legend_circle_handler)}

def make_legend_circles_for(sizes, scale=1.0, **kw):
    return [Circle((0, 0), radius=(s / scale) ** 0.3, **kw) for s in sizes]
plt.style.use(['classic', 'seaborn-white',
 {'axes.grid': False, 'grid.linestyle': '--', 'grid.color': u'0.6',
  'hatch.color': 'white', 'patch.linewidth': 0.5, 'font.size': 12,
  'legend.fontsize': 'medium', 'lines.linewidth': 1.5, 'pdf.fonttype': 42}])

map_boundaries = [-10, 49, 2, 60]
line_colors = {'cur': "purple",
               'exp': to_rgba("red", 0.7)}
ac_color = "gray"
dc_color = "m"
#bus_colors = n.carriers.index
tech_colors = {"onwind": "xkcd:azure", "Hydro": "g", "ror": "maroon",
               "solar": "y", "biomass": "orange", "transmission lines": "k", "H2": "m",
               "hydrogen storage": "turquoise", "Battery": "slategray",
               "battery": "teal", "nuclear": "r", "coal": "#CC4E5C",
               "lignite": "grey",  "CCGT": "lightblue", "coal": "darkred",
               "offwind-ac": "seagreen", "oil": "pink", "Pumped storage": "navy",
               "offwind-dc": "purple", "AC load": "b", "Li ion load": "brown",
               "Li ion": "violet", "geothermal": "turquoise", "OCGT":"navy",
               "PHS":"slategray"}
bus_factor = 1.0e5 #1.0e4
bus_factor_gen = 1e4
branch_factor = 5e3 #5e2
branch_factor_line = 5e2
fields = ["bus", "carrier", "p_nom"]
pie_components = pd.concat(
    [n.generators.loc[n.generators.carrier != "load", fields],
     n.storage_units[fields]])
#bus_sizes = pie_components.groupby(["bus", "carrier"]).p_nom.sum() / bus_factor

bus_sizes = (pd.concat((
    n.generators.query('carrier != "load"').groupby(
        ['bus', 'carrier']).p_nom_opt.sum(), n.storage_units.groupby(
            ['bus', 'carrier']).p_nom_opt.sum()))) / bus_factor

line_widths_exp = pd.concat(dict(Line=n.lines.s_nom_opt, Link=n.links.p_nom_opt))
line_widths_cur = pd.concat(dict(Line=n.lines.s_nom_min, Link=n.links.p_nom_min))
line_colors_with_alpha = ((
    line_widths_cur / pd.concat(dict(
        Line=n.lines.s_nom, Link=n.links.p_nom)) > 1e-3).map(
            {True: line_colors['cur'], False: to_rgba(line_colors['cur'], 0.)}))
def clip(df, thres=500):
    return df.where(df > thres, other=0.0)
#line_widths = clip(n.lines.s_nom_opt - n.lines.s_nom) / branch_factor
#link_widths = clip(n.links.p_nom_opt - n.links.p_nom) / branch_factor
line_widths = n.lines.s_nom_opt / branch_factor
link_widths = n.links.p_nom_opt / branch_factor
line_widths_opt = n.lines.s_nom_opt / branch_factor

sns.set_theme(style='whitegrid')
fig, ax = plt.subplots(figsize=(7, 7), subplot_kw={"projection":ccrs.PlateCarree()})
plt.subplots_adjust(wspace=0.05, hspace=0.05)
plt.autoscale(tight=True)
ax = countries.plot(ax=ax, color="snow") #lightskyblue
plt.rcParams['text.usetex'] = False
n.plot(margin=0.4, ax=ax, bus_sizes=bus_sizes, bus_colors=tech_colors,
       #line_widths=line_widths_opt,
       line_colors=ac_color, link_colors=dc_color,
       line_widths=line_widths, link_widths=link_widths)
n.plot(margin=0.4, ax=ax, bus_sizes=0, bus_colors=tech_colors,
       line_widths=line_widths,
       link_widths=link_widths)
ax.set_aspect('equal')
ax.axis('off')
x1, y1, x2, y2 = map_boundaries
ax.set_xlim(x1, x2)
ax.set_ylim(y1, y2)
handles = []
labels = []
for s in (1, 2.5, 5):
    handles.append(
        plt.Line2D([0], [0], color="rosybrown", linewidth=s * 1e3 / branch_factor_line))
    labels.append(f"{s} GW")
handles1 = []
labels1 = []
for s in (1, 2.5, 5):
    handles1.append(
        plt.Line2D(
            [0], [0], color="darkseagreen", linewidth=s * 1e3 / branch_factor_line))
    labels1.append(f"{s} GW")

nice_names = {
    "lines": "Transmission lines",
    "AC line": "AC lines",
    "AC-AC": "DC lines",
    "ror": "Run of river"
}
techs =  (bus_sizes.index.levels[1])
handles2 = []
labels2 = []
for t in techs:
    handles2.append(plt.Line2D([0], [0], color=tech_colors[t], marker='o', markersize=8, linewidth=0))
    labels2.append(nice_names.get(t, t))

circles = [50, 25, 10]
handles3 = make_legend_circles_for(circles, scale=bus_factor_gen, facecolor="navy")
labels3 = [f"{float(s/1e2)} GW" for s in circles]
legend = ax.legend(handles, labels, loc="upper left", bbox_to_anchor=(-0.02, 0.43),
                   frameon=True, labelspacing=0.5, handletextpad=1.0, ncol=1,
                   title="HVAC Line Capacity", title_fontsize=8, fontsize=6,
                   framealpha=1, borderpad=1,
                   labelcolor="black", facecolor="white")
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
legend1 = fig.legend(handles1, labels1, loc="upper left", bbox_to_anchor=(0.11, 0.35),
               frameon=True, labelspacing=0.5, handletextpad=1.0, ncol=1,
               title="HVDC Link Capacity", title_fontsize=8, fontsize=6,
                     framealpha=1, borderpad=1,
                     labelcolor="black", facecolor="white")
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
legend2 = fig.legend(handles2, labels2, loc="upper center", bbox_to_anchor=(0.6, 0.22),
          handletextpad=0.0,
          columnspacing=0.3,
          ncol=4, frameon=True,
          title="Technology",
          title_fontsize=10, framealpha=1, borderpad=1,
          fontsize=8,
          labelcolor="black", facecolor="white")
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
legend3 = fig.legend(handles3, labels3, loc="upper left",
          #frameon=1,
          bbox_to_anchor=(0.1, 0.78), #(0.82, 0.0)
          labelspacing=1.5,
          title="Generation",
          title_fontsize=10,
          fontsize=8, frameon=True, framealpha=1, borderpad=1,
          ncol=1, labelcolor="black", facecolor="white",
          handler_map=make_handler_map_to_scale_circles_as_in(ax, True))
legend3.get_frame().set_edgecolor('black')
legend3.get_frame().set_linewidth(1)
fig.text(0.37, 0.05, "CO$_2$ Emissions: {} MtCO$_2$ / Annum".format(
    int(np.round(co2_emi/1e6))))

## Add Total Energy Production
def aggregate_p(n):
    return pd.concat([
        n.generators_t.p.sum().groupby(n.generators.carrier).sum(),
        n.storage_units_t.p.sum().groupby(n.storage_units.carrier).sum(),
        n.stores_t.p.sum().groupby(n.stores.carrier).sum(),
        -n.loads_t.p.sum().groupby(n.loads.carrier).sum()
    ])
nice_names_n = {
    "offwind": "offshore\nwind",
    "onwind": "onshore\nwind",
    "H2": "Hydrogen\nstorage",
    "lines": "transmission\nlines",
    "ror": "run of river"
}
ax1 = ax = fig.add_axes([0.73, 0.48, 0.3, 0.3])
ax.set_title('Energy per technology', fontdict=dict(fontsize="medium"))
#e_primary = aggregate_p(n).drop('load', errors='ignore').loc[lambda s: s>0]
e_primary = pd.concat((
    n.generators.query('carrier != "load"').groupby(
        ['carrier']).p_nom_opt.sum(), n.storage_units.groupby(
            ['carrier']).p_nom_opt.sum()))
patches, texts, autotexts = ax.pie(e_primary,
       startangle=90,
       labels = e_primary.rename(nice_names_n).index,
      autopct='%.0f%%',
      shadow=False,
          colors = [tech_colors[tech] for tech in e_primary.index])
t3, t4 = [], []
for t1, t2, i in zip(texts, autotexts, e_primary.index):
    if e_primary.at[i] < 0.05 * e_primary.sum():
        t1.remove()
        t2.remove()
        t3.append(t1)
        t4.append(t2)
    elif i == 'Coal':
        t2.set_color('gray')
print(t3)
print(t4)
## Add average system cost bar plot
ax2 = ax = fig.add_axes([1.2, 0.20, 0.15, 0.33])
total_load = n.loads_t.p.sum().sum()
selected_categories = ['Battery Storage', 'Biomass', 'Coal', 'Combined-Cycle Gas',
                      'Hydrogen Storage', 'Nuclear', 'Offshore Wind (AC)',
                      'Offshore Wind (DC)', 'Oil', 'Onshore Wind', 'Run of River', 'Solar']
df = n.statistics()[['Capital Expenditure', 'Operational Expenditure', 'Supply']].loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
#df['Avg_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure']) / total_load
Gen_Elec = df['Supply'].sum()
df['Avg_Sys_Cost'] = ((df['Capital Expenditure'] + df['Operational Expenditure'])*0.84) / Gen_Elec
df_avg_sys_cost_All_Mix = (df.groupby(level=1).sum()).fillna(0)
selected_categories = n.statistics().index.get_level_values(1)
df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
#df['Avg_Sys_Cost'] = ((df['Capital Expenditure'] + df['Operational Expenditure']) / total_load)*0.84
df['Tot_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure'])*0.84
Gen_Elec = df['Supply'].sum()
df['Avg_Sys_Cost'] = df['Tot_Sys_Cost'] / Gen_Elec
df_ = (df.groupby(level=1).sum()).fillna(0)
selected_categories_ = ['Battery Storage', 'Biomass', 'Coal', 'Combined-Cycle Gas',
                      'Hydrogen Storage', 'Nuclear', 'Offshore Wind (AC)',
                      'Offshore Wind (DC)', 'Oil', 'Onshore Wind', 'Run of River', 'Solar']
df2 = df_.loc[selected_categories_]
color = ['teal', 'orange', '#CC4E5C', 'lightblue', 'turquoise', 'r', 'seagreen',
         'purple', 'pink', 'xkcd:azure', 'maroon', 'y']
ax.cla()
ax.set_facecolor("white")
ax.spines[['top', 'right']].set_visible(False)
#ax.set_ylabel('Dispatch Units', size=12, fontweight='bold')
ax.set_xlabel('Average System Cost [¬£/MWh]', size=6, fontweight='bold')
bars = ax.barh(range(len(df2)),
               df2['Avg_Sys_Cost'], color=color, edgecolor='grey')
for i, (idx, row) in enumerate(df2.iterrows()):
    ax.text(row['Avg_Sys_Cost'], i, '{:.2f}'.format(row['Avg_Sys_Cost']), va='center', fontsize=10)
ax.set_yticks(range(len(df2)))
ax.set_yticklabels(df2.index)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
ax.tick_params(axis='x', rotation=0, labelsize=6)
ax.tick_params(axis='y', rotation=0, labelsize=6)
#axs[1] = plt.gca()
for spine in ax.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax.xaxis.grid(False)
ax.yaxis.grid(False)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
for spine in ax.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax.xaxis.grid(False)
ax.yaxis.grid(False)
fig.text(0.87, 0.08, "Total System Cost:\n{:.3f} Billion ¬£ Per Annum".format(
    np.round(tot_annual_sys_cost_2025_All_Mix, 3)))
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/scenario_1_results.png')
plt.show()



"""##**Analyse the solved networks**

##**Scenario 2 : RES Only - Renewable Generators**
"""

network = pypsa.Network("/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_RES/elec_s_6_ec_lcopt_Co2L-1H.nc")
n = network
n

"""**Average Marginal Electricity Price**"""

avg_marg_price_2025_RES = (n.buses_t.marginal_price.mean(axis=0).mean()*0.84)
print('=====================')
print(avg_marg_price_2025_RES)
print('=====================')

"""**Visualize the Hourly Average Marginal Price of Electricity (¬£/MWh)**"""

mean_marginal_price_RES = (n.buses_t.marginal_price.mean(axis=1)*0.84)
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (12, 8)
fig, axs = plt.subplots(1, 1)
plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)
axs.cla()
axs.set_facecolor("white")
axs.spines[['top', 'right']].set_visible(False)
axs.set_ylabel('[¬£/MWh]', size=18, fontweight='bold')
axs.set_xlabel('Time [h]', size=18, fontweight='bold')
axs.plot(mean_marginal_price_RES.resample('H').mean(), color = plt.cm.tab10(3),
         linewidth = 2.0, linestyle='dashed', drawstyle = 'steps-mid')
legend_labels = ['Average Marginal Price of Electricity']
legend = axs.legend(legend_labels, loc='best', ncol=1, frameon=True, fontsize='14',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
axs.tick_params(axis='x', rotation=30, labelsize=15)
axs.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in axs.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs.xaxis.grid(False)
axs.yaxis.grid(False)
axs.xaxis.set_major_formatter(mdates.DateFormatter('%b'))
#axs.set_yscale('log')
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Average_Marginal_Price_Time_Series_2022.png')
plt.tight_layout()
plt.show()

"""**Total Annual System Costs**"""

print('=====================')
tot_annual_sys_cost_2025_RES = (n.objective / 1e9 * 0.84) # Billion Euro per annum = n.objective / 1e9 # Billion Euro per annum
print(tot_annual_sys_cost_2025_RES)
print('=====================')

"""**CO2 Emissions and Price**"""

print('=========================================================')
co2_emi = ((n.generators_t.p.multiply(
    n.snapshot_weightings, axis=0)).sum(
    ) / n.generators.efficiency * n.generators.carrier.map(n.carriers.co2_emissions)
    ).sum()
print(f"CO‚ÇÇ Emissions: {int(np.round(co2_emi / 1e6))} MtCO‚ÇÇ / annum")
print('==========================================================')
print(f"CO‚ÇÇ Emissions Price: {int(np.round(n.global_constraints.mu))} ¬£ /tCO‚ÇÇe / annum")
print('==========================================================')

"""**Visualize Energy Storage Outputs Over time**"""

sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (12, 8)
fig, (axs1, axs2) = plt.subplots(2, 1)
#plt.subplots_adjust(wspace=0.2, hspace=0.8)
plt.autoscale(tight=True)
axs1.cla()
axs1.set_facecolor("white")
axs1.spines[['top', 'right']].set_visible(False)
axs1.set_ylabel('[MWh]', size=15, fontweight='bold')
#axs1.set_xlabel('Time [h]', size=15, fontweight='bold')
n.storage_units_t.state_of_charge.mean(axis=1).resample('W').mean().plot.area(ax=axs1, color = plt.cm.tab10(5),
         label = 'State of Charge', xlabel='')
axs2.cla()
axs2.set_facecolor("white")
axs2.spines[['top', 'right']].set_visible(False)
axs2.set_ylabel('[MWh]', size=15, fontweight='bold')
axs2.set_xlabel('Time [h]', size=15, fontweight='bold')
n.storage_units_t.p_dispatch.mean(axis=1).resample('W').mean().plot.area(ax=axs2, color = plt.cm.tab10(3),
         label = 'Power Dispatch', xlabel='')
n.storage_units_t.p_store.mean(axis=1).resample('W').mean().plot.area(ax=axs2, color = plt.cm.tab10(2),
         label = 'Power Charging', xlabel='')
legend1 = axs1.legend(loc='best', ncol=1, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
legend2 = axs2.legend(loc='best', ncol=1, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
#axs1.set_xlabel('Time [h]', size=15, fontweight='bold')
#axs1.tick_params('axis='x', rotation=30, labelsize=10')
axs1.tick_params(axis='y', rotation=0, labelsize=10)
#axs[1] = plt.gca()
for spine in axs1.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs1.xaxis.grid(False)
axs1.yaxis.grid(False)
axs2.set_xlabel('Time [h]', size=15, fontweight='bold')
axs2.tick_params(axis='x', rotation=30, labelsize=10)
axs2.tick_params(axis='y', rotation=0, labelsize=10)
#axs[1] = plt.gca()
for spine in axs2.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs2.xaxis.grid(False)
axs2.yaxis.grid(False)
fig.text(0.5, 0.52, '(a) Energy Storage Units State of Charge', ha='center',
            size=14, fontweight='bold')
fig.text(0.5, -0.01, '(b) Battery Charge and Discharge', ha='center',
            size=14, fontweight='bold')
#axs.set_yscale('log')
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Storage_Units_Outputs_Time_Series_2022.png')
plt.tight_layout()
plt.subplots_adjust(wspace=0.2, hspace=0.5)
plt.show()

"""###**Network Statistics**

It is possible to get direct analysis values of the network and plot them, including Capacity Factor, Capital Expenditure, Curtailment, Installed Capacity, Operational Expenditure, Optimal Capacity, Revenue, Supply and Withdrawal
"""

stat_RES = n.statistics()
print(n.statistics().to_markdown())
# Note: the "load" in the generators represents the Demand Side Response
# to match the power demand with the supply.

"""**Obtain the Optimized Average System Cost Per Unit of Generated Energy in ¬£/MWh**"""

selected_categories = n.statistics().index.get_level_values(1)
df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
#df['Avg_Sys_Cost'] = ((df['Capital Expenditure'] + df['Operational Expenditure']) / total_load)*0.84
df['Tot_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure'])*0.84
Gen_Elec = df['Supply'].sum()
df['Avg_Sys_Cost'] = df['Tot_Sys_Cost'] / Gen_Elec
df_ = (df.groupby(level=1).sum()).fillna(0)
avg_total_sys_cost_RES = df_['Avg_Sys_Cost'].sum()
print(f'Average Total Systen Cost in ¬£/MWh is:', avg_total_sys_cost_RES)
avg_sys_cost_tech_RES = df_[['Avg_Sys_Cost']]
print(
    f'Average Systen Cost in ¬£/MWh For Each Technology is', avg_sys_cost_tech_RES.to_markdown())

"""**Obtain the Optimized Annual Energy Generation in % of the Annual Energy Demand**"""

selected_categories = ['Battery Storage', 'Biomass', 'Coal', 'Combined-Cycle Gas',
                      'Hydrogen Storage', 'Nuclear', 'Offshore Wind (AC)',
                      'Offshore Wind (DC)', 'Oil', 'Onshore Wind', 'Run of River', 'Solar']
df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
total_load = n.loads_t.p.sum().sum()
Annual_gen = df['Supply']
df['Annual Gen % of Load'] = (Annual_gen / total_load) * 100
df_ = (df.groupby(level=1).sum()).fillna(0)
Total_energy_RES = df_['Annual Gen % of Load'].sum()
print(f'Total Energy is:', Total_energy_RES)
print(df_[['Annual Gen % of Load']].to_markdown())

"""**Validate Results By Comparing With The UK Energy Projections for the Year 2025**

###**Plot the Dispatch of the Different Carriers and Electricity Prices**
"""

from pypsa.statistics import get_bus_and_carrier
from snakemake.utils import update_config
from entsoe import EntsoePandasClient
from entsoe.exceptions import NoMatchingDataError

'''carrier_grouper = {
    "Waste": "Biomass",
    "Hydro Pumped Storage": "Hydro",
    "Hydro Water Reservoir": "Hydro",
    "Hydro Run-of-river and poundage": "Run of River",
    "Fossil Coal-derived gas": "Gas",
    "Fossil Gas": "Gas",
    "Fossil Oil": "Oil",
    "Fossil Oil shale": "Oil",
    "Fossil Brown coal/Lignite": "Lignite",
    "Fossil Peat": "Lignite",
    "Fossil Hard coal": "Coal",
    "Wind Onshore": "Onshore Wind",
    "Wind Offshore": "Offshore Wind",
    "Other renewable": "Other",
    "Marine": "Other",
}
api_key = "4f5f60b8-7902-41d2-829c-e975148e4f13"
client = EntsoePandasClient(api_key=api_key)
start = pd.Timestamp('20210101', tz='Europe/Brussels')
end = pd.Timestamp('20220101', tz='Europe/Brussels')
country_code = 'GB'
generation = []
unavailable_countries = []
gen = client.query_generation(country_code, start=start, end=end, nett=True)
gen = gen.tz_localize(None).resample("1h").mean()
gen = gen.loc[start.tz_localize(None) : end.tz_localize(None)]
gen = gen.rename(columns=carrier_grouper).T.groupby(level=0).sum().T
generation.append(gen)
generation = pd.concat(generation, axis=1)'''
#generation.to_csv('/content/gdrive/MyDrive/Energy_System_Modelling_GB/entsoe.csv')

sns.set_theme("paper", style="whitegrid")
carrier_groups = {
    "Offshore Wind (AC)": "Offshore Wind",
    "Offshore Wind (DC)": "Offshore Wind",
    "Open-Cycle Gas": "Gas",
    "Combined-Cycle Gas": "Gas",
    "Reservoir & Dam": "Hydro",
    "Pumped Hydro Storage": "Hydro",
}
n.loads.carrier = "load"
colors = n.carriers.set_index("nice_name").color.where(
    lambda s: s != "", "lightgrey")
colors["Offshore Wind"] = colors["Offshore Wind (AC)"]
#colors["Gas"] = colors["Combined-Cycle Gas"]
colors["Hydro"] = colors["Reservoir & Dam"]
colors["load"] = "teal"
colors["Other"] = "lightgray"
# Dispatch
optimized = n.statistics.dispatch(groupby=get_bus_and_carrier, aggregate_time=False).T
optimized = optimized[["Generator", "StorageUnit"]].droplevel(0, axis=1)
optimized = optimized.rename(columns=n.buses.country, level=0)
optimized = optimized.rename(columns=carrier_groups, level=1)
optimized = optimized.groupby(axis=1, level=[0, 1]).sum()
data_dispatch = pd.concat([optimized], keys=["Optimized"], axis=1)
data_dispatch.columns.names = ["Kind", "Country", "Carrier"]
data_dispatch = data_dispatch.mul(n.snapshot_weightings.generators, axis=0)
# Dispatch
optimized = n.statistics.dispatch(groupby=get_bus_and_carrier, aggregate_time=False).T
optimized = optimized[["Generator", "StorageUnit"]].droplevel(0, axis=1)
optimized = optimized.rename(columns=n.buses.country, level=0)
optimized = optimized.rename(columns=carrier_groups, level=1)
optimized = optimized.groupby(axis=1, level=[0, 1]).sum()
data_dispatch = pd.concat([optimized], keys=["Optimized"], axis=1)
data_dispatch.columns.names = ["Kind", "Country", "Carrier"]
data_dispatch = data_dispatch.mul(n.snapshot_weightings.generators, axis=0)
# Electricity Price
optimized = n.buses_t.marginal_price.groupby(n.buses.country, axis=1).mean()
data = pd.concat([optimized], keys=["Optimized"], axis=1)
data.columns.names = ["Kind", "Country"]
df_price = data.groupby(level="Kind", axis=1).mean()
# seasonal operation
sns.set_theme(style='whitegrid')
fig, axes = plt.subplots(1, 1, figsize=(12, 6))
plt.subplots_adjust(wspace=0.3, hspace=0.3)
plt.autoscale(tight=True)
axes.cla()
axes.set_facecolor("white")
axes.spines[['top', 'right']].set_visible(False)
axes.set_xlabel('Time (h)', size=20, fontweight='bold')
axes.set_ylabel('Production [GW]', size=20, fontweight='bold')
df = (data_dispatch.groupby(
    level=["Kind", "Carrier"], axis=1).sum().resample("1W").mean().clip(lower=0))
df = df / 1e3 # GW
order = (
    (df["Optimized"].diff().abs().sum() / df["Optimized"].sum()).sort_values().index)
c = colors[order]
optimized_dispatch = df["Optimized"].reindex(order, axis=1, level=1)
kwargs = dict(color=c, legend=False)
optimized_dispatch.plot.area(ax=axes, **kwargs, title="", xlabel='')
axes.tick_params(axis='x', rotation=30, labelsize=20)
axes.tick_params(axis='y', rotation=0, labelsize=20)
for spine in axes.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axes.xaxis.grid(False)
axes.yaxis.grid(False)
axes.set_xlabel('Time (h)', size=20, fontweight='bold')
#axes.xaxis.set_major_formatter(mdates.DateFormatter('%b'))
'''axes[1].cla()
axes[1].set_facecolor("white")
axes[1].spines[['top', 'right']].set_visible(False)
axes[1].set_xlabel('Time (h)', size=25, fontweight='bold')
axes[1].set_ylabel('Price [¬£/MWh]', size=22, fontweight='bold')
df_price.plot(ax=axes[1], alpha=0.8, color = plt.cm.tab10(3), linewidth = '2.8', legend=False,
              xlabel = 'Time [h]', linestyle='dashed', drawstyle = 'steps-mid')
axes[1].tick_params(axis='x', rotation=30, labelsize=20)
axes[1].tick_params(axis='y', rotation=0, labelsize=20)
for spine in axes[1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axes[1].xaxis.grid(False)
axes[1].yaxis.grid(False)
axes[1].xaxis.set_major_formatter(mdates.DateFormatter('%b'))'''
h, l = axes.get_legend_handles_labels()
legend1 = fig.legend(
    h[::-1],
    l[::-1],
    loc="center left",
    bbox_to_anchor=(0.93, 0.5),
    title="Generators and Storage Units",
    title_fontsize=15,
    fontsize=14, frameon=True, framealpha=1, borderpad=1,
    ncol=1, labelcolor="black", facecolor="white",
    #frameon=False,
    labelspacing=1,
)
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
'''h1, l1 = axes[1].get_legend_handles_labels()
legend2 = fig.legend(h1[::-1], l1[::-1], loc="upper left",
           bbox_to_anchor=(0.93, 0.4),
           labelspacing=2.5,
           title="Average Electricity Price",
           title_fontsize=15,
           fontsize=14, frameon=True, framealpha=1, borderpad=1,
           ncol=1, labelcolor="black", facecolor="white")
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
fig.text(0.5, 0.0, '(a) Dispatch Units Outputs', ha='center',
            size=20, fontweight='bold')
fig.text(0.5, -0.05, '(b) Average Marginal Electricty Price', ha='center',
            size=20, fontweight='bold')'''
fig.savefig("UK-2025-total_dispatch_carrier_operation_price.pdf", bbox_inches="tight")

"""###**Extract and Make Results Summaries**"""

import cartopy.crs as ccrs
path_country_shapes = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/country_shapes.geojson"
countries = gpd.read_file(path_country_shapes)
def make_handler_map_to_scale_circles_as_in(ax, dont_resize_actively=False):
    fig = ax.get_figure()
    def axes2pt():
        return np.diff(ax.transData.transform([(0, 0), (1, 1)]), axis=0)[0] * (
            100.0 / fig.dpi)
    ellipses = []
    if not dont_resize_actively:
        def update_width_height(event):
            dist = axes2pt()
            for e, radius in ellipses:
                e.width, e.height = 2.0 * radius * dist
        fig.canvas.mpl_connect("resize_event", update_width_height)
        ax.callbacks.connect("xlim_changed", update_width_height)
        ax.callbacks.connect("ylim_changed", update_width_height)
    def legend_circle_handler(
        legend, orig_handle, xdescent, ydescent, width, height, fontsize
    ):
        w, h = 2.0 * orig_handle.get_radius() * axes2pt()
        e = Ellipse(
            xy=(0.5 * width - 0.5 * xdescent, 0.5 * height - 0.5 * ydescent),
            width=w, height=w)
        ellipses.append((e, orig_handle.get_radius()))
        return e
    return {Circle: HandlerPatch(patch_func=legend_circle_handler)}

def make_legend_circles_for(sizes, scale=1.0, **kw):
    return [Circle((0, 0), radius=(s / scale) ** 0.3, **kw) for s in sizes]
plt.style.use(['classic', 'seaborn-white',
 {'axes.grid': False, 'grid.linestyle': '--', 'grid.color': u'0.6',
  'hatch.color': 'white', 'patch.linewidth': 0.5, 'font.size': 12,
  'legend.fontsize': 'medium', 'lines.linewidth': 1.5, 'pdf.fonttype': 42}])

map_boundaries = [-10, 49, 2, 60]
line_colors = {'cur': "purple",
               'exp': to_rgba("red", 0.7)}
ac_color = "gray"
dc_color = "m"
#bus_colors = n.carriers.index
tech_colors = {"onwind": "xkcd:azure", "Hydro": "g", "ror": "maroon",
               "solar": "y", "biomass": "orange", "transmission lines": "k", "H2": "m",
               "hydrogen storage": "turquoise", "Battery": "slategray",
               "battery": "teal", "nuclear": "r", "coal": "#CC4E5C",
               "lignite": "grey",  "CCGT": "lightblue", "coal": "darkred",
               "offwind-ac": "seagreen", "oil": "pink", "Pumped storage": "navy",
               "offwind-dc": "purple", "AC load": "b", "Li ion load": "brown",
               "Li ion": "violet", "geothermal": "turquoise", "OCGT":"navy",
               "PHS":"slategray"}
bus_factor = 1.0e5 #1.0e4
bus_factor_gen = 1e4
branch_factor = 5e3 #5e2
branch_factor_line = 5e2
fields = ["bus", "carrier", "p_nom"]
pie_components = pd.concat(
    [n.generators.loc[n.generators.carrier != "load", fields],
     n.storage_units[fields]])
#bus_sizes = pie_components.groupby(["bus", "carrier"]).p_nom.sum() / bus_factor

bus_sizes = (pd.concat((
    n.generators.query('carrier != "load"').groupby(
        ['bus', 'carrier']).p_nom_opt.sum(), n.storage_units.groupby(
            ['bus', 'carrier']).p_nom_opt.sum()))) / bus_factor

line_widths_exp = pd.concat(dict(Line=n.lines.s_nom_opt, Link=n.links.p_nom_opt))
line_widths_cur = pd.concat(dict(Line=n.lines.s_nom_min, Link=n.links.p_nom_min))
line_colors_with_alpha = ((
    line_widths_cur / pd.concat(dict(
        Line=n.lines.s_nom, Link=n.links.p_nom)) > 1e-3).map(
            {True: line_colors['cur'], False: to_rgba(line_colors['cur'], 0.)}))
def clip(df, thres=500):
    return df.where(df > thres, other=0.0)
#line_widths = clip(n.lines.s_nom_opt - n.lines.s_nom) / branch_factor
#link_widths = clip(n.links.p_nom_opt - n.links.p_nom) / branch_factor
line_widths = n.lines.s_nom_opt / branch_factor
link_widths = n.links.p_nom_opt / branch_factor
line_widths_opt = n.lines.s_nom_opt / branch_factor

sns.set_theme(style='whitegrid')
fig, ax = plt.subplots(figsize=(7, 7), subplot_kw={"projection":ccrs.PlateCarree()})
plt.subplots_adjust(wspace=0.05, hspace=0.05)
plt.autoscale(tight=True)
ax = countries.plot(ax=ax, color="snow") #lightskyblue
plt.rcParams['text.usetex'] = False
n.plot(margin=0.4, ax=ax, bus_sizes=bus_sizes, bus_colors=tech_colors,
       #line_widths=line_widths_opt,
       line_colors=ac_color, link_colors=dc_color,
       line_widths=line_widths, link_widths=link_widths)
n.plot(margin=0.4, ax=ax, bus_sizes=0, bus_colors=tech_colors,
       line_widths=line_widths,
       link_widths=link_widths)
ax.set_aspect('equal')
ax.axis('off')
x1, y1, x2, y2 = map_boundaries
ax.set_xlim(x1, x2)
ax.set_ylim(y1, y2)
handles = []
labels = []
for s in (1, 2.5, 5):
    handles.append(
        plt.Line2D([0], [0], color="rosybrown", linewidth=s * 1e3 / branch_factor_line))
    labels.append(f"{s} GW")
handles1 = []
labels1 = []
for s in (1, 2.5, 5):
    handles1.append(
        plt.Line2D(
            [0], [0], color="darkseagreen", linewidth=s * 1e3 / branch_factor_line))
    labels1.append(f"{s} GW")

nice_names = {
    "lines": "Transmission lines",
    "AC line": "AC lines",
    "AC-AC": "DC lines",
    "ror": "Run of river"
}
techs =  (bus_sizes.index.levels[1])
handles2 = []
labels2 = []
for t in techs:
    handles2.append(plt.Line2D([0], [0], color=tech_colors[t], marker='o', markersize=8, linewidth=0))
    labels2.append(nice_names.get(t, t))

circles = [50, 25, 10]
handles3 = make_legend_circles_for(circles, scale=bus_factor_gen, facecolor="navy")
labels3 = [f"{float(s/1e2)} GW" for s in circles]
legend = ax.legend(handles, labels, loc="upper left", bbox_to_anchor=(-0.02, 0.43),
                   frameon=True, labelspacing=0.5, handletextpad=1.0, ncol=1,
                   title="HVAC Line Capacity", title_fontsize=8, fontsize=6,
                   framealpha=1, borderpad=1,
                   labelcolor="black", facecolor="white")
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
legend1 = fig.legend(handles1, labels1, loc="upper left", bbox_to_anchor=(0.11, 0.35),
               frameon=True, labelspacing=0.5, handletextpad=1.0, ncol=1,
               title="HVDC Link Capacity", title_fontsize=8, fontsize=6,
                     framealpha=1, borderpad=1,
                     labelcolor="black", facecolor="white")
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
legend2 = fig.legend(handles2, labels2, loc="upper center", bbox_to_anchor=(0.6, 0.22),
          handletextpad=0.0,
          columnspacing=0.3,
          ncol=4, frameon=True,
          title="Technology",
          title_fontsize=10, framealpha=1, borderpad=1,
          fontsize=8,
          labelcolor="black", facecolor="white")
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
legend3 = fig.legend(handles3, labels3, loc="upper left",
          #frameon=1,
          bbox_to_anchor=(0.1, 0.78), #(0.82, 0.0)
          labelspacing=1.5,
          title="Generation",
          title_fontsize=10,
          fontsize=8, frameon=True, framealpha=1, borderpad=1,
          ncol=1, labelcolor="black", facecolor="white",
          handler_map=make_handler_map_to_scale_circles_as_in(ax, True))
legend3.get_frame().set_edgecolor('black')
legend3.get_frame().set_linewidth(1)
fig.text(0.37, 0.05, "CO$_2$ Emissions: {} MtCO$_2$ / Annum".format(
    int(np.round(co2_emi/1e6))))

## Add Total Energy Production
def aggregate_p(n):
    return pd.concat([
        n.generators_t.p.sum().groupby(n.generators.carrier).sum(),
        n.storage_units_t.p.sum().groupby(n.storage_units.carrier).sum(),
        n.stores_t.p.sum().groupby(n.stores.carrier).sum(),
        -n.loads_t.p.sum().groupby(n.loads.carrier).sum()
    ])
nice_names_n = {
    "offwind": "offshore\nwind",
    "onwind": "onshore\nwind",
    "H2": "Hydrogen\nstorage",
    "lines": "transmission\nlines",
    "ror": "run of river"
}
ax1 = ax = fig.add_axes([0.73, 0.48, 0.3, 0.3])
ax.set_title('Energy per technology', fontdict=dict(fontsize="medium"))
#e_primary = aggregate_p(n).drop('load', errors='ignore').loc[lambda s: s>0]
e_primary = pd.concat((
    n.generators.query('carrier != "load"').groupby(
        ['carrier']).p_nom_opt.sum(), n.storage_units.groupby(
            ['carrier']).p_nom_opt.sum()))
patches, texts, autotexts = ax.pie(e_primary,
       startangle=90,
       labels = e_primary.rename(nice_names_n).index,
      autopct='%.0f%%',
      shadow=False,
          colors = [tech_colors[tech] for tech in e_primary.index])
t3, t4 = [], []
for t1, t2, i in zip(texts, autotexts, e_primary.index):
    if e_primary.at[i] < 0.05 * e_primary.sum():
        t1.remove()
        t2.remove()
        t3.append(t1)
        t4.append(t2)
    elif i == 'Coal':
        t2.set_color('gray')
print(t3)
print(t4)
## Add average system cost bar plot
ax2 = ax = fig.add_axes([1.0, 0.20, 0.15, 0.33])
total_load = n.loads_t.p.sum().sum()
selected_categories = ['Battery Storage', 'Biomass', 'Coal', 'Combined-Cycle Gas',
                      'Hydrogen Storage', 'Nuclear', 'Offshore Wind (AC)',
                      'Offshore Wind (DC)', 'Oil', 'Onshore Wind', 'Run of River', 'Solar']
df = n.statistics()[['Capital Expenditure', 'Operational Expenditure', 'Supply']].loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
#df['Avg_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure']) / total_load
Gen_Elec = df['Supply'].sum()
df['Avg_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure']) / Gen_Elec
df_avg_sys_cost_RES = (df.groupby(level=1).sum()*0.84)
selected_categories = n.statistics().index.get_level_values(1)
df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
#df['Avg_Sys_Cost'] = ((df['Capital Expenditure'] + df['Operational Expenditure']) / total_load)*0.84
df['Tot_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure'])*0.84
Gen_Elec = df['Supply'].sum()
df['Avg_Sys_Cost'] = df['Tot_Sys_Cost'] / Gen_Elec
df_ = (df.groupby(level=1).sum()).fillna(0)
selected_categories_ = ['Battery Storage',
                      'Hydrogen Storage', 'Offshore Wind (AC)',
                      'Offshore Wind (DC)', 'Onshore Wind', 'Run of River', 'Solar']
df2 = df_.loc[selected_categories_]
color = ['teal', 'turquoise', 'seagreen', 'purple', "xkcd:azure", 'maroon', 'y']
ax.cla()
ax.set_facecolor("white")
ax.spines[['top', 'right']].set_visible(False)
#ax.set_ylabel('Dispatch Units', size=12, fontweight='bold')
ax.set_xlabel('Average System Cost [¬£/MWh]', size=6, fontweight='bold')
bars = ax.barh(range(len(df2)), df2['Avg_Sys_Cost'], color=color, edgecolor='grey')
for i, (idx, row) in enumerate(df2.iterrows()):
    ax.text(row['Avg_Sys_Cost'], i, '{:.2f}'.format(row['Avg_Sys_Cost']), va='center', fontsize=10)
ax.set_yticks(range(len(df2)))
ax.set_yticklabels(df2.index)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
ax.tick_params(axis='x', rotation=0, labelsize=6)
ax.tick_params(axis='y', rotation=0, labelsize=6)
#axs[1] = plt.gca()
for spine in ax.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax.xaxis.grid(False)
ax.yaxis.grid(False)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
for spine in ax.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax.xaxis.grid(False)
ax.yaxis.grid(False)
fig.text(0.87, 0.08, "Total System Cost:\n{:.3f} Billion ¬£ Per Annum".format(
    np.round(tot_annual_sys_cost_2025_RES, 3)))
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/scenario_2_results.png')
plt.show()

"""##**Scenario 3 : RES and Low Carbon Generators Only**"""

network = pypsa.Network("/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_RES_LC/elec_s_6_ec_lcopt_Co2L-1H.nc")
n = network
n

"""**Average Marginal Electricity Price**"""

avg_marg_price_2025_RES_LC = (n.buses_t.marginal_price.mean(axis=0).mean()*0.84)
print('=====================')
print(avg_marg_price_2025_RES_LC)
print('=====================')

"""**Visualize the Hourly Average Marginal Price of Electricity (¬£/MWh)**"""

mean_marginal_price_RES_LC = (n.buses_t.marginal_price.mean(axis=1)*0.84)
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (12, 8)
fig, axs = plt.subplots(1, 1)
plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)
axs.cla()
axs.set_facecolor("white")
axs.spines[['top', 'right']].set_visible(False)
axs.set_ylabel('[¬£/MWh]', size=18, fontweight='bold')
axs.set_xlabel('Time [h]', size=18, fontweight='bold')
axs.plot(mean_marginal_price_RES_LC.resample('H').mean(), color = plt.cm.tab10(3),
         linewidth = 2.0, linestyle='dashed', drawstyle = 'steps-mid')
legend_labels = ['Average Marginal Price of Electricity']
legend = axs.legend(legend_labels, loc='best', ncol=1, frameon=True, fontsize='14',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
axs.tick_params(axis='x', rotation=30, labelsize=15)
axs.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in axs.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs.xaxis.grid(False)
axs.yaxis.grid(False)
axs.xaxis.set_major_formatter(mdates.DateFormatter('%b'))
#axs.set_yscale('log')
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Average_Marginal_Price_Time_Series_2022.png')
plt.tight_layout()
plt.show()

"""**Total Annual System Costs**"""

print('=====================')
tot_annual_sys_cost_2025_RES_LC = (n.objective / 1e9 * 0.84) # Billion Euro per annum = n.objective / 1e9 # Billion Euro per annum
print(tot_annual_sys_cost_2025_RES_LC)
print('=====================')

"""**CO2 Emissions and Price**"""

print('=========================================================')
co2_emi = ((n.generators_t.p.multiply(
    n.snapshot_weightings, axis=0)).sum(
    ) / n.generators.efficiency * n.generators.carrier.map(n.carriers.co2_emissions)
    ).sum()
print(f"CO‚ÇÇ Emissions: {int(np.round(co2_emi / 1e6))} MtCO‚ÇÇ / annum")
print('==========================================================')
print(f"CO‚ÇÇ Emissions Price: {int(np.round(n.global_constraints.mu))} ¬£ /tCO‚ÇÇe / annum")
print('==========================================================')

"""**Visualize Energy Storage Outputs Over time**"""

sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (12, 8)
fig, (axs1, axs2) = plt.subplots(2, 1)
#plt.subplots_adjust(wspace=0.2, hspace=0.8)
plt.autoscale(tight=True)
axs1.cla()
axs1.set_facecolor("white")
axs1.spines[['top', 'right']].set_visible(False)
axs1.set_ylabel('[MWh]', size=15, fontweight='bold')
#axs1.set_xlabel('Time [h]', size=15, fontweight='bold')
n.storage_units_t.state_of_charge.mean(axis=1).resample('W').mean().plot.area(ax=axs1, color = plt.cm.tab10(5),
         label = 'State of Charge', xlabel='')
axs2.cla()
axs2.set_facecolor("white")
axs2.spines[['top', 'right']].set_visible(False)
axs2.set_ylabel('[MWh]', size=15, fontweight='bold')
axs2.set_xlabel('Time [h]', size=15, fontweight='bold')
n.storage_units_t.p_dispatch.mean(axis=1).resample('W').mean().plot.area(ax=axs2, color = plt.cm.tab10(3),
         label = 'Power Dispatch', xlabel='')
n.storage_units_t.p_store.mean(axis=1).resample('W').mean().plot.area(ax=axs2, color = plt.cm.tab10(2),
         label = 'Power Charging', xlabel='')
legend1 = axs1.legend(loc='best', ncol=1, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
legend2 = axs2.legend(loc='best', ncol=1, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
#axs1.set_xlabel('Time [h]', size=15, fontweight='bold')
#axs1.tick_params('axis='x', rotation=30, labelsize=10')
axs1.tick_params(axis='y', rotation=0, labelsize=10)
#axs[1] = plt.gca()
for spine in axs1.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs1.xaxis.grid(False)
axs1.yaxis.grid(False)
#axs1.xaxis.set_major_formatter(mdates.DateFormatter('%b'))
axs2.set_xlabel('Time [h]', size=15, fontweight='bold')
axs2.tick_params(axis='x', rotation=30, labelsize=10)
axs2.tick_params(axis='y', rotation=0, labelsize=10)
#axs[1] = plt.gca()
for spine in axs2.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs2.xaxis.grid(False)
axs2.yaxis.grid(False)
#axs2.xaxis.set_major_formatter(mdates.DateFormatter('%b'))
fig.text(0.5, 0.52, '(a) Energy Storage Units State of Charge', ha='center',
            size=14, fontweight='bold')
fig.text(0.5, -0.01, '(b) Battery Charge and Discharge', ha='center',
            size=14, fontweight='bold')
#axs.set_yscale('log')
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Storage_Units_Outputs_Time_Series_2022.png')
plt.tight_layout()
plt.subplots_adjust(wspace=0.2, hspace=0.5)
plt.show()

"""###**Network Statistics**

It is possible to get direct analysis values of the network and plot them, including Capacity Factor, Capital Expenditure, Curtailment, Installed Capacity, Operational Expenditure, Optimal Capacity, Revenue, Supply and Withdrawal
"""

stat_RES_LC = n.statistics()
print(n.statistics().to_markdown())
# Note: the "load" in the generators represents the Demand Side Response
# to match the power demand with the supply.

"""**Obtain the Optimized Average System Cost Per Unit of Generated Energy in ¬£/MWh**"""

selected_categories = n.statistics().index.get_level_values(1)
df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
#df['Avg_Sys_Cost'] = ((df['Capital Expenditure'] + df['Operational Expenditure']) / total_load)*0.84
df['Tot_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure'])*0.84
Gen_Elec = df['Supply'].sum()
df['Avg_Sys_Cost'] = df['Tot_Sys_Cost'] / Gen_Elec
df_ = (df.groupby(level=1).sum()).fillna(0)
avg_total_sys_cost_RES_LC = df_['Avg_Sys_Cost'].sum()
print(f'Average Total Systen Cost in ¬£/MWh is:', avg_total_sys_cost_RES_LC)
avg_sys_cost_tech_RES_LC = df_[['Avg_Sys_Cost']]
print(
    f'Average Systen Cost in ¬£/MWh For Each Technology is', avg_sys_cost_tech_RES_LC.to_markdown())

"""**Obtain the Optimized Annual Energy Generation in % of the Annual Energy Demand**"""

selected_categories = ['Battery Storage', 'Biomass', 'Coal', 'Combined-Cycle Gas',
                      'Hydrogen Storage', 'Nuclear', 'Offshore Wind (AC)',
                      'Offshore Wind (DC)', 'Oil', 'Onshore Wind', 'Run of River', 'Solar']
df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
total_load = n.loads_t.p.sum().sum()
Annual_gen = df['Supply']
df['Annual Gen % of Load'] = (Annual_gen / total_load) * 100
df_ = (df.groupby(level=1).sum()).fillna(0)
Total_energy_RES_LC = df_['Annual Gen % of Load'].sum()
print(f'Total Energy is:', Total_energy_RES_LC)
print(df_[['Annual Gen % of Load']].to_markdown())

"""**Validate Results By Comparing With The UK Energy Projections for the Year 2025**

###**Plot the Dispatch of the Different Carriers and Electricity Prices**
"""

'''carrier_grouper = {
    "Waste": "Biomass",
    "Hydro Pumped Storage": "Hydro",
    "Hydro Water Reservoir": "Hydro",
    "Hydro Run-of-river and poundage": "Run of River",
    "Fossil Coal-derived gas": "Gas",
    "Fossil Gas": "Gas",
    "Fossil Oil": "Oil",
    "Fossil Oil shale": "Oil",
    "Fossil Brown coal/Lignite": "Lignite",
    "Fossil Peat": "Lignite",
    "Fossil Hard coal": "Coal",
    "Wind Onshore": "Onshore Wind",
    "Wind Offshore": "Offshore Wind",
    "Other renewable": "Other",
    "Marine": "Other",
}
api_key = "4f5f60b8-7902-41d2-829c-e975148e4f13"
client = EntsoePandasClient(api_key=api_key)
start = pd.Timestamp('20210101', tz='Europe/Brussels')
end = pd.Timestamp('20220101', tz='Europe/Brussels')
country_code = 'GB'
generation = []
unavailable_countries = []
gen = client.query_generation(country_code, start=start, end=end, nett=True)
gen = gen.tz_localize(None).resample("1h").mean()
gen = gen.loc[start.tz_localize(None) : end.tz_localize(None)]
gen = gen.rename(columns=carrier_grouper).T.groupby(level=0).sum().T
generation.append(gen)
generation = pd.concat(generation, axis=1)'''
#generation.to_csv('/content/gdrive/MyDrive/Energy_System_Modelling_GB/entsoe.csv')

sns.set_theme("paper", style="whitegrid")
carrier_groups = {
    "Offshore Wind (AC)": "Offshore Wind",
    "Offshore Wind (DC)": "Offshore Wind",
    "Open-Cycle Gas": "Gas",
    "Combined-Cycle Gas": "Gas",
    "Reservoir & Dam": "Hydro",
    "Pumped Hydro Storage": "Hydro",
}
n.loads.carrier = "load"
colors = n.carriers.set_index("nice_name").color.where(
    lambda s: s != "", "lightgrey")
colors["Offshore Wind"] = colors["Offshore Wind (AC)"]
#colors["Gas"] = colors["Combined-Cycle Gas"]
colors["Hydro"] = colors["Reservoir & Dam"]
colors["load"] = "teal"
colors["Other"] = "lightgray"
# Dispatch
optimized = n.statistics.dispatch(groupby=get_bus_and_carrier, aggregate_time=False).T
optimized = optimized[["Generator", "StorageUnit"]].droplevel(0, axis=1)
optimized = optimized.rename(columns=n.buses.country, level=0)
optimized = optimized.rename(columns=carrier_groups, level=1)
optimized = optimized.groupby(axis=1, level=[0, 1]).sum()
data_dispatch = pd.concat([optimized], keys=["Optimized"], axis=1)
data_dispatch.columns.names = ["Kind", "Country", "Carrier"]
data_dispatch = data_dispatch.mul(n.snapshot_weightings.generators, axis=0)
# Dispatch
optimized = n.statistics.dispatch(groupby=get_bus_and_carrier, aggregate_time=False).T
optimized = optimized[["Generator", "StorageUnit"]].droplevel(0, axis=1)
optimized = optimized.rename(columns=n.buses.country, level=0)
optimized = optimized.rename(columns=carrier_groups, level=1)
optimized = optimized.groupby(axis=1, level=[0, 1]).sum()
data_dispatch = pd.concat([optimized], keys=["Optimized"], axis=1)
data_dispatch.columns.names = ["Kind", "Country", "Carrier"]
data_dispatch = data_dispatch.mul(n.snapshot_weightings.generators, axis=0)
# Electricity Price
optimized = n.buses_t.marginal_price.groupby(n.buses.country, axis=1).mean()
data = pd.concat([optimized], keys=["Optimized"], axis=1)
data.columns.names = ["Kind", "Country"]
df_price = data.groupby(level="Kind", axis=1).mean()
# seasonal operation
sns.set_theme(style='whitegrid')
fig, axes = plt.subplots(1, 1, figsize=(12, 6))
plt.subplots_adjust(wspace=0.3, hspace=0.3)
plt.autoscale(tight=True)
axes.cla()
axes.set_facecolor("white")
axes.spines[['top', 'right']].set_visible(False)
axes.set_xlabel('Time (h)', size=20, fontweight='bold')
axes.set_ylabel('Production [GW]', size=20, fontweight='bold')
df = (data_dispatch.groupby(
    level=["Kind", "Carrier"], axis=1).sum().resample("1W").mean().clip(lower=0))
df = df / 1e3 # GW
order = (
    (df["Optimized"].diff().abs().sum() / df["Optimized"].sum()).sort_values().index)
c = colors[order]
optimized_dispatch = df["Optimized"].reindex(order, axis=1, level=1)
kwargs = dict(color=c, legend=False)
optimized_dispatch.plot.area(ax=axes, **kwargs, title="", xlabel='')
axes.tick_params(axis='x', rotation=30, labelsize=20)
axes.tick_params(axis='y', rotation=0, labelsize=20)
for spine in axes.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axes.xaxis.grid(False)
axes.yaxis.grid(False)
#axes.xaxis.set_major_formatter(mdates.DateFormatter('%b'))
axes.set_xlabel('Time (h)', size=20, fontweight='bold')
'''axes[1].cla()
axes[1].set_facecolor("white")
axes[1].spines[['top', 'right']].set_visible(False)
axes[1].set_xlabel('Time (h)', size=25, fontweight='bold')
axes[1].set_ylabel('Price [¬£/MWh]', size=22, fontweight='bold')
df_price.plot(ax=axes[1], alpha=0.8, color = plt.cm.tab10(3), linewidth = '2.8', legend=False,
              xlabel = 'Time [h]', linestyle='dashed', drawstyle = 'steps-mid')
axes[1].tick_params(axis='x', rotation=30, labelsize=20)
axes[1].tick_params(axis='y', rotation=0, labelsize=20)
for spine in axes[1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axes[1].xaxis.grid(False)
axes[1].yaxis.grid(False)
axes[1].xaxis.set_major_formatter(mdates.DateFormatter('%b'))'''

h, l = axes.get_legend_handles_labels()
legend1 = fig.legend(
    h[::-1],
    l[::-1],
    loc="center left",
    bbox_to_anchor=(0.93, 0.5),
    title="Generators and Storage Units",
    title_fontsize=15,
    fontsize=14, frameon=True, framealpha=1, borderpad=1,
    ncol=1, labelcolor="black", facecolor="white",
    #frameon=False,
    labelspacing=1,
)
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
'''h1, l1 = axes[1].get_legend_handles_labels()
legend2 = fig.legend(h1[::-1], l1[::-1], loc="upper left",
           bbox_to_anchor=(0.93, 0.4),
           labelspacing=2.5,
           title="Average Electricity Price",
           title_fontsize=15,
           fontsize=14, frameon=True, framealpha=1, borderpad=1,
           ncol=1, labelcolor="black", facecolor="white")
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
fig.text(0.5, -0.05, '(a) Dispatch Units Outputs', ha='center',
            size=20, fontweight='bold')
fig.text(0.5, -0.05, '(b) Average Marginal Electricty Price', ha='center',
            size=20, fontweight='bold')'''
fig.savefig("UK-2025-total_dispatch_carrier_operation_price.pdf", bbox_inches="tight")

"""###**Extract and Make Results Summaries**"""

import cartopy.crs as ccrs
path_country_shapes = "/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025/country_shapes.geojson"
countries = gpd.read_file(path_country_shapes)
def make_handler_map_to_scale_circles_as_in(ax, dont_resize_actively=False):
    fig = ax.get_figure()
    def axes2pt():
        return np.diff(ax.transData.transform([(0, 0), (1, 1)]), axis=0)[0] * (
            100.0 / fig.dpi)
    ellipses = []
    if not dont_resize_actively:
        def update_width_height(event):
            dist = axes2pt()
            for e, radius in ellipses:
                e.width, e.height = 2.0 * radius * dist
        fig.canvas.mpl_connect("resize_event", update_width_height)
        ax.callbacks.connect("xlim_changed", update_width_height)
        ax.callbacks.connect("ylim_changed", update_width_height)
    def legend_circle_handler(
        legend, orig_handle, xdescent, ydescent, width, height, fontsize
    ):
        w, h = 2.0 * orig_handle.get_radius() * axes2pt()
        e = Ellipse(
            xy=(0.5 * width - 0.5 * xdescent, 0.5 * height - 0.5 * ydescent),
            width=w, height=w)
        ellipses.append((e, orig_handle.get_radius()))
        return e
    return {Circle: HandlerPatch(patch_func=legend_circle_handler)}

def make_legend_circles_for(sizes, scale=1.0, **kw):
    return [Circle((0, 0), radius=(s / scale) ** 0.3, **kw) for s in sizes]
plt.style.use(['classic', 'seaborn-white',
 {'axes.grid': False, 'grid.linestyle': '--', 'grid.color': u'0.6',
  'hatch.color': 'white', 'patch.linewidth': 0.5, 'font.size': 12,
  'legend.fontsize': 'medium', 'lines.linewidth': 1.5, 'pdf.fonttype': 42}])

map_boundaries = [-10, 49, 2, 60]
line_colors = {'cur': "purple",
               'exp': to_rgba("red", 0.7)}
ac_color = "gray"
dc_color = "m"
#bus_colors = n.carriers.index
tech_colors = {"onwind": "xkcd:azure", "Hydro": "g", "ror": "maroon",
               "solar": "y", "biomass": "orange", "transmission lines": "k", "H2": "m",
               "hydrogen storage": "turquoise", "Battery": "slategray",
               "battery": "teal", "nuclear": "r", "coal": "#CC4E5C",
               "lignite": "grey",  "CCGT": "lightblue", "coal": "darkred",
               "offwind-ac": "seagreen", "oil": "pink", "Pumped storage": "navy",
               "offwind-dc": "purple", "AC load": "b", "Li ion load": "brown",
               "Li ion": "violet", "geothermal": "turquoise", "OCGT":"navy",
               "PHS":"slategray"}
bus_factor = 1.0e5 #1.0e4
bus_factor_gen = 1e4
branch_factor = 5e3 #5e2
branch_factor_line = 5e2
fields = ["bus", "carrier", "p_nom"]
pie_components = pd.concat(
    [n.generators.loc[n.generators.carrier != "load", fields],
     n.storage_units[fields]])
#bus_sizes = pie_components.groupby(["bus", "carrier"]).p_nom.sum() / bus_factor

bus_sizes = (pd.concat((
    n.generators.query('carrier != "load"').groupby(
        ['bus', 'carrier']).p_nom_opt.sum(), n.storage_units.groupby(
            ['bus', 'carrier']).p_nom_opt.sum()))) / bus_factor

line_widths_exp = pd.concat(dict(Line=n.lines.s_nom_opt, Link=n.links.p_nom_opt))
line_widths_cur = pd.concat(dict(Line=n.lines.s_nom_min, Link=n.links.p_nom_min))
line_colors_with_alpha = ((
    line_widths_cur / pd.concat(dict(
        Line=n.lines.s_nom, Link=n.links.p_nom)) > 1e-3).map(
            {True: line_colors['cur'], False: to_rgba(line_colors['cur'], 0.)}))
def clip(df, thres=500):
    return df.where(df > thres, other=0.0)
#line_widths = clip(n.lines.s_nom_opt - n.lines.s_nom) / branch_factor
#link_widths = clip(n.links.p_nom_opt - n.links.p_nom) / branch_factor
line_widths = n.lines.s_nom_opt / branch_factor
link_widths = n.links.p_nom_opt / branch_factor
line_widths_opt = n.lines.s_nom_opt / branch_factor

sns.set_theme(style='whitegrid')
fig, ax = plt.subplots(figsize=(7, 7), subplot_kw={"projection":ccrs.PlateCarree()})
plt.subplots_adjust(wspace=0.05, hspace=0.05)
plt.autoscale(tight=True)
ax = countries.plot(ax=ax, color="snow") #lightskyblue
plt.rcParams['text.usetex'] = False
n.plot(margin=0.4, ax=ax, bus_sizes=bus_sizes, bus_colors=tech_colors,
       #line_widths=line_widths_opt,
       line_colors=ac_color, link_colors=dc_color,
       line_widths=line_widths, link_widths=link_widths)
n.plot(margin=0.4, ax=ax, bus_sizes=0, bus_colors=tech_colors,
       line_widths=line_widths,
       link_widths=link_widths)
ax.set_aspect('equal')
ax.axis('off')
x1, y1, x2, y2 = map_boundaries
ax.set_xlim(x1, x2)
ax.set_ylim(y1, y2)
handles = []
labels = []
for s in (1, 2.5, 5):
    handles.append(
        plt.Line2D([0], [0], color="rosybrown", linewidth=s * 1e3 / branch_factor_line))
    labels.append(f"{s} GW")
handles1 = []
labels1 = []
for s in (1, 2.5, 5):
    handles1.append(
        plt.Line2D(
            [0], [0], color="darkseagreen", linewidth=s * 1e3 / branch_factor_line))
    labels1.append(f"{s} GW")

nice_names = {
    "lines": "Transmission lines",
    "AC line": "AC lines",
    "AC-AC": "DC lines",
    "ror": "Run of river"
}
techs =  (bus_sizes.index.levels[1])
handles2 = []
labels2 = []
for t in techs:
    handles2.append(plt.Line2D([0], [0], color=tech_colors[t], marker='o', markersize=8, linewidth=0))
    labels2.append(nice_names.get(t, t))

circles = [50, 25, 10]
handles3 = make_legend_circles_for(circles, scale=bus_factor_gen, facecolor="navy")
labels3 = [f"{float(s/1e2)} GW" for s in circles]
legend = ax.legend(handles, labels, loc="upper left", bbox_to_anchor=(-0.02, 0.43),
                   frameon=True, labelspacing=0.5, handletextpad=1.0, ncol=1,
                   title="HVAC Line Capacity", title_fontsize=8, fontsize=6,
                   framealpha=1, borderpad=1,
                   labelcolor="black", facecolor="white")
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
legend1 = fig.legend(handles1, labels1, loc="upper left", bbox_to_anchor=(0.11, 0.35),
               frameon=True, labelspacing=0.5, handletextpad=1.0, ncol=1,
               title="HVDC Link Capacity", title_fontsize=8, fontsize=6,
                     framealpha=1, borderpad=1,
                     labelcolor="black", facecolor="white")
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
legend2 = fig.legend(handles2, labels2, loc="upper center", bbox_to_anchor=(0.6, 0.22),
          handletextpad=0.0,
          columnspacing=0.3,
          ncol=4, frameon=True,
          title="Technology",
          title_fontsize=10, framealpha=1, borderpad=1,
          fontsize=8,
          labelcolor="black", facecolor="white")
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
legend3 = fig.legend(handles3, labels3, loc="upper left",
          #frameon=1,
          bbox_to_anchor=(0.1, 0.78), #(0.82, 0.0)
          labelspacing=1.5,
          title="Generation",
          title_fontsize=10,
          fontsize=8, frameon=True, framealpha=1, borderpad=1,
          ncol=1, labelcolor="black", facecolor="white",
          handler_map=make_handler_map_to_scale_circles_as_in(ax, True))
legend3.get_frame().set_edgecolor('black')
legend3.get_frame().set_linewidth(1)
fig.text(0.37, 0.05, "CO$_2$ Emissions: {} MtCO$_2$ / Annum".format(
    int(np.round(co2_emi/1e6))))

## Add Total Energy Production
def aggregate_p(n):
    return pd.concat([
        n.generators_t.p.sum().groupby(n.generators.carrier).sum(),
        n.storage_units_t.p.sum().groupby(n.storage_units.carrier).sum(),
        n.stores_t.p.sum().groupby(n.stores.carrier).sum(),
        -n.loads_t.p.sum().groupby(n.loads.carrier).sum()
    ])
nice_names_n = {
    "offwind": "offshore\nwind",
    "onwind": "onshore\nwind",
    "H2": "Hydrogen\nstorage",
    "lines": "transmission\nlines",
    "ror": "run of river"
}
ax1 = ax = fig.add_axes([0.73, 0.48, 0.3, 0.3])
ax.set_title('Energy per technology', fontdict=dict(fontsize="medium"))
#e_primary = aggregate_p(n).drop('load', errors='ignore').loc[lambda s: s>0]
e_primary = pd.concat((
    n.generators.query('carrier != "load"').groupby(
        ['carrier']).p_nom_opt.sum(), n.storage_units.groupby(
            ['carrier']).p_nom_opt.sum()))
patches, texts, autotexts = ax.pie(e_primary,
       startangle=90,
       labels = e_primary.rename(nice_names_n).index,
      autopct='%.0f%%',
      shadow=False,
          colors = [tech_colors[tech] for tech in e_primary.index])
t3, t4 = [], []
for t1, t2, i in zip(texts, autotexts, e_primary.index):
    if e_primary.at[i] < 0.05 * e_primary.sum():
        t1.remove()
        t2.remove()
        t3.append(t1)
        t4.append(t2)
    elif i == 'Coal':
        t2.set_color('gray')
print(t3)
print(t4)
## Add average system cost bar plot
ax2 = ax = fig.add_axes([1.0, 0.20, 0.15, 0.33])
total_load = n.loads_t.p.sum().sum()
selected_categories = ['Battery Storage', 'Biomass', 'Coal', 'Combined-Cycle Gas',
                      'Hydrogen Storage', 'Nuclear', 'Offshore Wind (AC)',
                      'Offshore Wind (DC)', 'Oil', 'Onshore Wind', 'Run of River', 'Solar']
df = n.statistics()[['Capital Expenditure', 'Operational Expenditure', 'Supply']].loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
#df['Avg_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure']) / total_load
Gen_Elec = df['Supply'].sum()
df['Avg_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure']) / Gen_Elec
df_avg_sys_cost_RES_LC = (df.groupby(level=1).sum()*0.84)
selected_categories = n.statistics().index.get_level_values(1)
df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
#df['Avg_Sys_Cost'] = ((df['Capital Expenditure'] + df['Operational Expenditure']) / total_load)*0.84
df['Tot_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure'])*0.84
Gen_Elec = df['Supply'].sum()
df['Avg_Sys_Cost'] = df['Tot_Sys_Cost'] / Gen_Elec
df_ = (df.groupby(level=1).sum()).fillna(0)
selected_categories_ = ['Battery Storage', 'Biomass',
                      'Hydrogen Storage', 'Nuclear', 'Offshore Wind (AC)',
                      'Offshore Wind (DC)', 'Onshore Wind', 'Run of River', 'Solar']
df2 = df_.loc[selected_categories_]
color = ['teal', 'orange', 'turquoise', "r", 'seagreen', 'purple', "xkcd:azure", 'maroon', 'y']
ax.cla()
ax.set_facecolor("white")
ax.spines[['top', 'right']].set_visible(False)
#ax.set_ylabel('Dispatch Units', size=12, fontweight='bold')
ax.set_xlabel('Average System Cost [¬£/MWh]', size=6, fontweight='bold')
bars = ax.barh(range(len(df2)), df2['Avg_Sys_Cost'], color=color, edgecolor='grey')
for i, (idx, row) in enumerate(df2.iterrows()):
    ax.text(row['Avg_Sys_Cost'], i, '{:.2f}'.format(row['Avg_Sys_Cost']), va='center', fontsize=10)
ax.set_yticks(range(len(df2)))
ax.set_yticklabels(df2.index)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
ax.tick_params(axis='x', rotation=0, labelsize=6)
ax.tick_params(axis='y', rotation=0, labelsize=6)
#axs[1] = plt.gca()
for spine in ax.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax.xaxis.grid(False)
ax.yaxis.grid(False)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
for spine in ax.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax.xaxis.grid(False)
ax.yaxis.grid(False)
fig.text(0.87, 0.08, "Total System Cost:\n{:.3f} Billion ¬£ Per Annum".format(
    np.round(tot_annual_sys_cost_2025_RES_LC, 3)))
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/scenario_3_results.png')
plt.show()

"""#**Analyse the solved networks stochastically**

##**Scenario 1 : All Mix - Conventional and Renewable Generators**
"""

seed = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
dfs_marg_price = []
dfs_marg_price2 = []
dfs_tot_sys_cost = []
dfs_soc = []
dfs_sto_disp = []
dfs_sto_charg = []
dfs_stat_disp = []
dfs_stat_avg_tot_cost = []
for s in seed:
    path = f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_monte/elec_s_6_ec_lcopt_Co2L-1H_m{s}.nc"
    n = pypsa.Network(path)
    # Marginal Price
    df = (n.buses_t.marginal_price*0.84)
    dfs_marg_price.append(df)
    df = (n.buses_t.marginal_price.mean(axis=1) * 0.84)
    dfs_marg_price2.append(df)
    # Total System Cost
    df = (n.objective*0.84)
    dfs_tot_sys_cost.append(df)
    # SOC
    df = n.storage_units_t.state_of_charge
    dfs_soc.append(df)
    # Power Dispatch
    df = n.storage_units_t.p_dispatch
    dfs_sto_disp.append(df)
    # Power Charging
    df = n.storage_units_t.p_store
    dfs_sto_charg.append(df)
    # Dispatch
    df_ = n.statistics.dispatch(groupby=get_bus_and_carrier, aggregate_time=False).T
    df = df_[["Generator", "StorageUnit"]].droplevel(0, axis=1)
    dfs_stat_disp.append(df)
    # Average System Cost
    total_load = n.loads_t.p.sum().sum()
    selected_categories = ['Battery Storage', 'Biomass', 'Coal', 'Combined-Cycle Gas',
                           'Hydrogen Storage', 'Nuclear', 'Offshore Wind (AC)',
                           'Offshore Wind (DC)', 'Oil', 'Onshore Wind', 'Run of River', 'Solar']
    df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
    df['Avg_Sys_Cost'] = ((df['Capital Expenditure'] + df['Operational Expenditure']) / total_load)*0.84
    df['Tot_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure'])*0.84
    df['Gen_Elec'] = df['Supply'] / (1 + 0.07)
    df['LCOE'] = (df['Tot_Sys_Cost'] / (1 + 0.07)) / df['Gen_Elec']
    df_ = (df.groupby(level=1).sum()).fillna(0)
    dfs_stat_avg_tot_cost.append(df_)

concatenated_df = pd.concat(dfs_marg_price, axis=1)
concatenated_df_soc = pd.concat(dfs_soc, axis=1)
concatenated_df_sto_disp = pd.concat(dfs_sto_disp, axis=1)
concatenated_df_sto_charg = pd.concat(dfs_sto_charg, axis=1)
concatenated_df_stat_disp = pd.concat(dfs_stat_disp, axis=1)
concatenated_df_stat_avg_tot_cost = pd.concat(dfs_stat_avg_tot_cost, axis=1)

marg_price_monte = pd.DataFrame()
for col_name, col_data in concatenated_df.items():
    if np.issubdtype(col_data.dtype, np.number):
        marg_price_monte[col_name] = concatenated_df[col_name].mean(axis=1)
mean_marg_price_monte = marg_price_monte.mean(axis=1)

marg_price_monte_std = pd.DataFrame()
for col_name, col_data in concatenated_df.items():
    if np.issubdtype(col_data.dtype, np.number):
        marg_price_monte_std[col_name] = concatenated_df[col_name].std(axis=1)
std_marg_price_monte = marg_price_monte_std.mean(axis=1)

soc_monte = pd.DataFrame()
for col_name, col_data in concatenated_df_soc.items():
    if np.issubdtype(col_data.dtype, np.number):
        soc_monte[col_name] = concatenated_df_soc[col_name].mean(axis=1)
mean_soc_monte = soc_monte.mean(axis=1)

sto_disp_monte = pd.DataFrame()
for col_name, col_data in concatenated_df_sto_disp.items():
    if np.issubdtype(col_data.dtype, np.number):
        sto_disp_monte[col_name] = concatenated_df_sto_disp[col_name].mean(axis=1)
mean_sto_disp_monte = sto_disp_monte.mean(axis=1)

sto_charg_monte = pd.DataFrame()
for col_name, col_data in concatenated_df_sto_charg.items():
    if np.issubdtype(col_data.dtype, np.number):
        sto_charg_monte[col_name] = concatenated_df_sto_charg[col_name].mean(axis=1)
mean_sto_charg_monte = sto_charg_monte.mean(axis=1)

stat_disp_monte = pd.DataFrame()
for col_name, col_data in concatenated_df_stat_disp.items():
    if np.issubdtype(col_data.dtype, np.number):
        stat_disp_monte[col_name] = concatenated_df_stat_disp[col_name].mean(axis=1)
mean_stat_disp_monte = stat_disp_monte.mean(axis=1)

stat_avg_tot_cost_monte = pd.DataFrame()
for col_name, col_data in concatenated_df_stat_avg_tot_cost.items():
    if np.issubdtype(col_data.dtype, np.number):
        stat_avg_tot_cost_monte[col_name] = concatenated_df_stat_avg_tot_cost[col_name].mean(axis=1)
mean_stat_avg_tot_cost_monte = stat_avg_tot_cost_monte.mean(axis=1)

avg_marg_price_2025_monte = marg_price_monte.mean(axis=0).mean()
print('=====================')
print(avg_marg_price_2025_monte)
print(dfs_tot_sys_cost)
print('=====================')

"""**Obtain the Probability Distribution Values - lower, upper, and best estimates (mean) - 90 CI**"""

df = concatenated_df_stat_avg_tot_cost.fillna(0)
def calculate_statistics(group):
    mean = group.mean(axis=1)
    std = group.std(axis=1)
    ci_90_low = mean - 1.645 * std / np.sqrt(group.shape[1])
    ci_90_high = mean + 1.645 * std / np.sqrt(group.shape[1])
    return mean, std, ci_90_low, ci_90_high
unique_cols = df.columns
for col in unique_cols:
    col_group = df.filter(regex=f'^{col}')
    mean, std, ci_90_low, ci_90_high = calculate_statistics(
        col_group)
    df[f'{col}_mean'] = mean
    df[f'{col}_std'] = std
    df[f'{col}_95CI_Low'] = ci_90_low
    df[f'{col}_95CI_High'] = ci_90_high
df_ = df[['Avg_Sys_Cost_95CI_Low', 'Avg_Sys_Cost_mean', 'Avg_Sys_Cost_95CI_High']]
df_['Parameter'] = df_.index

"""**Perform Sensitivity Analysis Using the Tornado Charts to illustrate Uncertainties around the Marginal Cost of Electricity**"""

dfLow = df_.Avg_Sys_Cost_95CI_Low
dfHigh = df_.Avg_Sys_Cost_95CI_High
category = df_.index
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (12, 8)
fig, ax = plt.subplots(figsize=(10, 7))
plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)
ax.cla()
ax.set_facecolor("white")
ax.spines[['top', 'right']].set_visible(False)
ax.barh(category, dfLow, align='center', height = 0.6,facecolor='gold',
        edgecolor='black')
ax.barh(category, dfHigh*-1, align='center', height = 0.6,facecolor='teal',
        edgecolor='black')
# Show the leave % on each  bar
for i, low in enumerate(dfLow):
    ax.text(low + 1, category[i],'{:,.0f}%'.format(low), ha='center',
            size = 12, color = "black")
# Show the remain % on each  bar
for i, High in enumerate(dfHigh):
    ax.text(( High*-1) -1, category[i],'{:,.0f}%'.format(High), ha='center',
            size = 12, color = "black")
# Show the title at the top of each  bar
# As the y axis is a category axis to be able to plot the labels outise the bars, we need to use the get method
for bar, cat in zip(ax.patches, category):
    width = bar.get_width()
    label_y = bar.get_y() + bar.get_height() +0.05
    plt.text(0, label_y, s=f'{cat}', size = 10)
# set the titles for each bar
# use figtext as it will allow to position multiple text values anywhere
# You can only have one ttiel in same position and you can only have ax.text inside the grid.
plt.figtext(0.38, 0.89, 'High - 90% CI', fontsize=12, rotation=0, weight="bold")
plt.figtext(0.76, 0.89, 'Low - 10% CI', fontsize=12, rotation=0, weight="bold")
for spine in ax.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax.xaxis.grid(False)
ax.yaxis.grid(False)
plt.axis('off') #turn all axis off
#add title and subtitle
plt.suptitle('',  fontsize = 10, x=0.46, y=1.18, weight="bold" )
plt.title("", fontsize = 12, x=0.43, y=1.18, color = "#bdbdbd")

"""**Visualize the Hourly Average Marginal Price of Electricity (¬£/MWh)**"""

df = pd.DataFrame(dfs_marg_price2).T
df = df.fillna(0)
# Function to compute mean and 95% CI across rows
def compute_mean_and_ci(row):
    mean = np.mean(row)
    se = stats.sem(row)  # Standard error of the mean
    ci_margin = se * stats.t.ppf(0.975, len(row)-1)  # 95% CI margin
    ci_low = mean - ci_margin
    ci_high = mean + ci_margin
    return pd.Series([mean, ci_low, ci_high], index=['mean', 'ci_low', 'ci_high'])
# Apply the function across rows
results = df.apply(compute_mean_and_ci, axis=1)
mean_series = results['mean']
ci_low_series = results['ci_low']
ci_high_series = results['ci_high']

# Obtain Data for One Day to Test and Compare
plt.set_cmap("tab10")
plt.cm.tab20(0)
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (12, 8)
fig, axs = plt.subplots(1, 1)
plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)
axs.cla()
axs.set_facecolor("white")
axs.spines[['top', 'right']].set_visible(False)
axs.set_ylabel('[¬£/MWh]', size=18, fontweight='bold')
axs.set_xlabel('Time [h]', size=18, fontweight='bold')
axs.plot(mean_series.index, mean_series, label='Mean w/UQ', color=plt.cm.tab10(1),
         linewidth=2.0)
axs.plot(mean_series.index, mean_marginal_price_All_Mix, label='Mean w/o UQ', color=plt.cm.tab10(4),
         linewidth=2.0)
axs.fill_between(mean_series.index, ci_low_series, ci_high_series, alpha=0.3, label='90% CI')
axs.plot(mean_series.index, ci_low_series, label='CI Low', color=plt.cm.tab10(0), linestyle='dashed',
         linewidth=2.0)
axs.plot(mean_series.index, ci_high_series, label='CI High', color=plt.cm.tab10(2), linestyle='dashed',
         linewidth=2.0)
legend = axs.legend(loc='best', ncol=1, frameon=True, fontsize='14',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
axs.tick_params(axis='x', rotation=30, labelsize=15)
axs.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in axs.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs.xaxis.grid(False)
axs.yaxis.grid(False)
#axs.set_yscale('log')
plt.gca().xaxis.set_major_formatter(plt.matplotlib.dates.DateFormatter('%b'))
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Average_Marginal_Price_Time_Series_2022_monte.png')
plt.tight_layout()
plt.show()

"""**Visualize the Hourly Average Marginal Price of Electricity (¬£/MWh) For Each Four Weather Seasons**"""

df = pd.DataFrame(dfs_marg_price2).T
df = df.fillna(0)
df2 = pd.DataFrame(mean_marginal_price_All_Mix)
season_months = {
    'Winter': '01',  # January
    'Spring': '04',  # April
    'Summer': '07',  # July
    'Fall': '10'     # October
}
def compute_mean_and_ci(row):
    mean = np.mean(row)
    se = stats.sem(row)  # Standard error of the mean
    ci_margin = se * stats.t.ppf(0.975, len(row)-1)  # 95% CI margin
    ci_low = mean - ci_margin
    ci_high = mean + ci_margin
    return pd.Series([mean, ci_low, ci_high], index=['mean', 'ci_low', 'ci_high'])
plt.set_cmap("tab10")
plt.cm.tab20(0)
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (14, 10)
fig, axes = plt.subplots(2, 2)
axes = axes.flatten()
plt.autoscale(tight=True)
# Process and plot each season
for i, (season, month) in enumerate(season_months.items()):
    # Slice the DataFrame for the specific month
    month_df = df[df.index.month == int(month)]
    mean_marginal_price_All_Mix_month = df2[df2.index.month == int(month)]
    # Apply the function across rows
    results = month_df.apply(compute_mean_and_ci, axis=1)
    # Convert each column to a separate Series
    mean_series = results['mean']
    ci_low_series = results['ci_low']
    ci_high_series = results['ci_high']
    # Plotting the results
    axes[i].cla()
    axes[i].set_facecolor("white")
    axes[i].spines[['top', 'right']].set_visible(False)
    axes[i].set_ylabel('[¬£/MWh]', size=13, fontweight='bold')
    axes[i].set_xlabel('Time [h]', size=13, fontweight='bold')
    axes[i].plot(mean_series, label='Mean with UQ', color=plt.cm.tab10(1), linewidth=2.0)
    axes[i].plot(mean_marginal_price_All_Mix_month, label='Mean w/o UQ',
                 color=plt.cm.tab10(4), linewidth=2.0)
    axes[i].fill_between(mean_series.index, ci_low_series, ci_high_series, color='blue', alpha=0.2, label='95% CI')
    axes[i].plot(mean_series.index, ci_low_series, label='CI Low', color=plt.cm.tab10(0),
                 linestyle='dashed', linewidth=2.0)
    axes[i].plot(mean_series.index, ci_high_series, label='CI High', color=plt.cm.tab10(2),
                 linestyle='dashed', linewidth=2.0)
    #axes[i].set_title(f'{season} (Month: {month})')
    axes[i].tick_params(axis='x', rotation=30, labelsize=15)
    axes[i].tick_params(axis='y', rotation=0, labelsize=15)
    legend = axes[i].legend(loc='best', ncol=2, frameon=True, fontsize='12',
                            fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
    legend.get_frame().set_edgecolor('black')
    legend.get_frame().set_linewidth(1)
    for spine in axes[i].spines.values():
        spine.set_linewidth(2)
        spine.set_edgecolor('black')
    axes[i].xaxis.grid(False)
    axes[i].yaxis.grid(False)
    axes[i].xaxis.set_major_formatter(plt.matplotlib.dates.DateFormatter('%b'))
fig.text(0.27, 0.50, '(a) Winter (Month: January)', ha='center', size=13, fontweight='bold')
fig.text(0.77, 0.50, '(b) Spring (Month: April)', ha='center', size=13, fontweight='bold')
fig.text(0.25, -0.03, '(c) Summer (Month: July)', ha='center', size=13, fontweight='bold')
fig.text(0.76, -0.03, '(d) Autumn (Month: October)', ha='center', size=13, fontweight='bold')
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Average_Marginal_Price_Time_Series_2022_monte.png')
plt.tight_layout()
plt.subplots_adjust(wspace=0.15, hspace=0.5)
plt.show()

"""**Print the Average Marginal Cost or Price of Electricity and the Total System Cost With 95% CI**"""

dfs_trans = []
dfs_gen_cap = []
dfs_storage = []
seed = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for s in seed:
    path = f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_monte/elec_s_6_ec_lcopt_Co2L-1H_m{s}.nc"
    n = pypsa.Network(path)
    selected_categories = ['AC', 'B2B', 'DC', 'H2 electrolysis',
                           'H2 fuel cell', 'H2 pipeline', 'battery charger',
                           'battery discharger']
    df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
    df_ = (df.groupby(level=1).sum()).fillna(0)
    dfs_trans.append(df_)
    selected_categories = ['Biomass', 'Coal', 'Combined-Cycle Gas', 'Nuclear',
                           'Offshore Wind (AC)', 'Offshore Wind (DC)', 'Oil',
                           'Onshore Wind', 'Run of River', 'Solar']
    df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
    df_ = (df.groupby(level=1).sum()).fillna(0)
    dfs_gen_cap.append(df_)
    selected_categories = ['StorageUnit']
    df = n.statistics().loc[n.statistics().index.get_level_values(0).isin(selected_categories)]
    df_ = (df.groupby(level=0).sum()).fillna(0)
    dfs_storage.append(df_)

concatenated_dfs_trans = pd.concat(dfs_trans, axis=1)
concatenated_dfs_gen_cap = pd.concat(dfs_gen_cap, axis=1)
concatenated_dfs_storage = pd.concat(dfs_storage, axis=1)

df = concatenated_dfs_trans
rows_to_sum = ['B2B', 'DC', 'H2 electrolysis', 'H2 fuel cell', 'H2 pipeline',
               'battery charger', 'battery discharger']
sum_row = df.loc[rows_to_sum].sum()
df.loc['Link'] = sum_row
df = df.fillna(0)
opt_cap_link = df[['Optimal Capacity']].loc['Link'].to_list()
inst_cap_link = df[['Installed Capacity']].loc['Link'].to_list()
new_exp_link = [a - b for a, b in zip(opt_cap_link, inst_cap_link)]

opt_cap_line = concatenated_dfs_trans[['Optimal Capacity']].loc['AC'].to_list()
inst_cap_line = concatenated_dfs_trans[['Installed Capacity']].loc['AC'].to_list()
new_exp_line = [a - b for a, b in zip(opt_cap_line, inst_cap_line)]

df = concatenated_dfs_gen_cap
rows_to_sum = ['Biomass', 'Coal', 'Combined-Cycle Gas', 'Nuclear', 'Offshore Wind (AC)',
               'Offshore Wind (DC)', 'Oil', 'Onshore Wind', 'Run of River', 'Solar']
sum_row = df.loc[rows_to_sum].sum()
df.loc['Gen'] = sum_row
df = df.fillna(0)
opt_cap_gen_cap = df[['Optimal Capacity']].loc['Gen'].to_list()
inst_cap_gen_cap = df[['Installed Capacity']].loc['Gen'].to_list()
new_exp_gen_cap = [a - b for a, b in zip(opt_cap_gen_cap, inst_cap_gen_cap)]
opt_gen_sup = df[['Supply']].loc['Gen'].to_list()

opt_sto = concatenated_dfs_storage[['Optimal Capacity']].loc['StorageUnit'].to_list()
inst_sto = concatenated_dfs_storage[['Installed Capacity']].loc['StorageUnit'].to_list()
new_exp_sto = [a - b for a, b in zip(opt_sto, inst_sto)]

df = pd.DataFrame(dfs_marg_price2).T
df = df.fillna(0)
# Function to compute mean and 95% CI across rows
def compute_mean_and_ci(row):
    mean = np.mean(row)
    se = stats.sem(row)  # Standard error of the mean
    ci_margin = se * stats.t.ppf(0.975, len(row)-1)  # 95% CI margin
    ci_low = mean - ci_margin
    ci_high = mean + ci_margin
    return pd.Series([mean, ci_low, ci_high], index=['mean', 'ci_low', 'ci_high'])
# Apply the function across rows
results = df.apply(compute_mean_and_ci, axis=1)
# Average marginal price of electricity
mean_series = results['mean'].mean()
ci_low_series = results['ci_low'].mean()
ci_high_series = results['ci_high'].mean()
df2 = mean_marginal_price_All_Mix.mean()
print('================================================================================')
print(f'Average Marginal Price of Electricity With UQ in ¬£/MWh: {mean_series:.2f}')
print(f'Average Marginal Price of Electricity With UQ (Low) in ¬£/MWh: {ci_low_series:.2f}')
print(f'Average Marginal Price of Electricity With UQ (High) in ¬£/MWh: {ci_high_series:.2f}')
print(f'Average Marginal Price of Electricity Without UQ in ¬£/MWh: {df2:.2f}')
print('================================================================================')
# Total System Cost
data = dfs_tot_sys_cost
data_clean = [x for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
df2 = tot_annual_sys_cost_2025_All_Mix
print('================================================================================')
print(f'Total System Cost With UQ in Billion ¬£/year: {mean:.2f}')
print(f'Total System Cost With UQ (Low) in Billion ¬£/year: {ci_low:.2f}')
print(f'Total System Cost With UQ (High) in Billion ¬£/year: {ci_high:.2f}')
print(f'Total System Cost Without UQ in Billion ¬£/year: {df2:.2f}')
print('================================================================================')

# New Link
data = new_exp_link
data_clean = [x if x >= 0 else 0 for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
print('================================================================================')
print(f'New Transmission Link With UQ in MWKm: {mean:.2f}')
print(f'New Transmission Link  With UQ (Low) in MWKm: {ci_low:.2f}')
print(f'New Transmission Link  With UQ (High) in MWKm: {ci_high:.2f}')
print('================================================================================')

# New Line
data = new_exp_line
data_clean = [x if x >= 0 else 0 for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
print('================================================================================')
print(f'New Transmission Line With UQ in MWKm: {mean:.2f}')
print(f'New Transmission Line  With UQ (Low) in MWKm: {ci_low:.2f}')
print(f'New Transmission Line  With UQ (High) in MWKm: {ci_high:.2f}')
print('================================================================================')

# New Installed Capacity of Generators
data = new_exp_gen_cap
data_clean = [x if x >= 0 else 0 for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
print('================================================================================')
print(f'New Generator Installed Capacity With UQ in MW: {mean:.2f}')
print(f'New Generator Installed Capacity With UQ (Low) in MW: {ci_low:.2f}')
print(f'New Generator Installed Capacity With UQ (High) in MW: {ci_high:.2f}')
print('================================================================================')

# New Generation Supply
data = opt_gen_sup
data_clean = [x if x >= 0 else 0 for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
print('================================================================================')
print(f'New Generation Supply With UQ in MW: {mean:.2f}')
print(f'New Generation Supply With UQ (Low) in MW: {ci_low:.2f}')
print(f'New Generation Supply With UQ (High) in MW: {ci_high:.2f}')
print('================================================================================')

# New Storage Capacity
data = new_exp_sto
data_clean = [x if x >= 0 else 0 for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
print('================================================================================')
print(f'New Storage Capacity With UQ in MW: {mean:.2f}')
print(f'New Storage Capacity With UQ (Low) in MW: {ci_low:.2f}')
print(f'New Storage Capacity With UQ (High) in MW: {ci_high:.2f}')
print('================================================================================')

"""###**Obtain the Total System Cost Distribution**"""

seed = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
dfs_tot_sys_cost = []
dfs_tot_sys_cost_monte = []
dfs_all_sys_cost = []
dfs_all_sys_cost_monte = []
for s in seed:
    path = f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_monte/elec_s_6_ec_lcopt_Co2L-1H_m{s}.nc"
    try:
        n = pypsa.Network(path)
        # Total System Cost
        df = (n.objective*0.84)
        dfs_tot_sys_cost.append(df)
        dfs_tot_sys_cost_monte.append(df)
        total_load = n.loads_t.p.sum().sum()
        selected_categories = ['Biomass', 'Coal', 'Combined-Cycle Gas', 'Nuclear',
                               'Offshore Wind (AC)', 'Offshore Wind (DC)', 'Oil', 'Onshore Wind',
                               'Run of River', 'Solar', 'AC', 'B2B', 'DC', 'H2 electrolysis',
                               'H2 fuel cell', 'H2 pipeline', 'battery charger', 'battery discharger',
                               'Battery Storage', 'Hydrogen Storage', 'Battery Storage',
                               'Hydrogen Storage']
        df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
        df['Avg_Sys_Cost'] = ((df['Capital Expenditure'] + df['Operational Expenditure']) / total_load)*0.84
        df['Tot_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure'])*0.84
        df_ = (df.groupby(level=1).sum()).fillna(0)
        rows_to_sum = ['AC', 'B2B', 'DC', 'H2 electrolysis', 'H2 fuel cell', 'H2 pipeline',
                       'battery charger', 'battery discharger']
        try:
            sum_row = df_.loc[rows_to_sum].sum()
            df_.loc['Transmission'] = sum_row
            df_ = df_.fillna(0)
        except KeyError as e:
            print(f"KeyError for seed {s}: {e}")
        dfs_all_sys_cost.append(df_)
        dfs_all_sys_cost_monte.append(df_)
    except Exception as e:
        print(f"Error processing seed {s}: {e}")
if dfs_all_sys_cost:
    concatenated_dfs_all_sys_cost = pd.concat(dfs_all_sys_cost, axis=1)
if dfs_all_sys_cost_monte:
    concatenated_dfs_all_sys_cost_monte = pd.concat(dfs_all_sys_cost_monte, axis=1)

#data = [d for d in dfs_tot_sys_cost if not np.isnan(d)]
df_TSC = pd.DataFrame({'Values': dfs_tot_sys_cost})
tot_sys_cost_monte = dfs_tot_sys_cost
data_TSC = np.array(dfs_tot_sys_cost)
Q5_TSC = np.percentile(data_TSC, 5)
Q25_TSC = np.percentile(data_TSC, 25)
Q50_TSC = np.median(data_TSC)
Q75_TSC = np.percentile(data_TSC, 75)
Q95_TSC = np.percentile(data_TSC, 95)

selected_categories = ['Battery Storage', 'Biomass', 'Coal', 'Combined-Cycle Gas',
                       'Hydrogen Storage', 'Nuclear', 'Offshore Wind (AC)',
                       'Offshore Wind (DC)', 'Oil', 'Onshore Wind', 'Run of River',
                       'Solar', 'Transmission']
selected_df = concatenated_dfs_all_sys_cost.loc[selected_categories]
battery_storage_cap = selected_df[['Optimal Capacity']].loc['Battery Storage'].to_list()
#data = [d for d in battery_storage_cap if not np.isnan(d)]
df_battery = pd.DataFrame({'Values': battery_storage_cap})
data_battery = np.array(battery_storage_cap)
Q5_battery = np.percentile(data_battery, 5)
Q25_battery = np.percentile(data_battery, 25)
Q50_battery = np.median(data_battery)
Q75_battery = np.percentile(data_battery, 75)
Q95_battery = np.percentile(data_battery, 95)

h2_storage_cap = selected_df[['Optimal Capacity']].loc['Hydrogen Storage'].to_list()
#data = [d for d in h2_storage_cap if not np.isnan(d)]
df_h2 = pd.DataFrame({'Values': h2_storage_cap})
data_h2 = np.array(h2_storage_cap)
Q5_h2 = np.percentile(data_h2, 5)
Q25_h2 = np.percentile(data_h2, 25)
Q50_h2 = np.median(data_h2)
Q75_h2 = np.percentile(data_h2, 75)
Q95_h2 = np.percentile(data_h2, 95)

onwind_cap = selected_df[['Optimal Capacity']].loc['Onshore Wind'].to_list()
#data = [d for d in onwind_cap if not np.isnan(d)]
df_onwind = pd.DataFrame({'Values': onwind_cap})
data_onwind = np.array(onwind_cap)
Q5_onwind = np.percentile(data_onwind, 5)
Q25_onwind = np.percentile(data_onwind, 25)
Q50_onwind = np.median(data_onwind)
Q75_onwind = np.percentile(data_onwind, 75)
Q95_onwind = np.percentile(data_onwind, 95)

offwindac_cap = selected_df[['Optimal Capacity']].loc['Offshore Wind (AC)'].to_list()
#data = [d for d in offwindac_cap if not np.isnan(d)]
df_offwindac = pd.DataFrame({'Values': offwindac_cap})
data_offwindac = np.array(offwindac_cap)
Q5_offwindac = np.percentile(data_offwindac, 5)
Q25_offwindac = np.percentile(data_offwindac, 25)
Q50_offwindac = np.median(data_offwindac)
Q75_offwindac = np.percentile(data_offwindac, 75)
Q95_offwindac = np.percentile(data_offwindac, 95)

offwinddc_cap = selected_df[['Optimal Capacity']].loc['Offshore Wind (DC)'].to_list()
#data = [d for d in offwinddc_cap if not np.isnan(d)]
df_offwinddc = pd.DataFrame({'Values': offwinddc_cap})
data_offwinddc = np.array(offwinddc_cap)
Q5_offwinddc = np.percentile(data_offwinddc, 5)
Q25_offwinddc = np.percentile(data_offwinddc, 25)
Q50_offwinddc = np.median(data_offwinddc)
Q75_offwinddc = np.percentile(data_offwinddc, 75)
Q95_offwinddc = np.percentile(data_offwinddc, 95)

solar_cap = selected_df[['Optimal Capacity']].loc['Solar'].to_list()
#data = [d for d in solar_cap if not np.isnan(d)]
df_solar = pd.DataFrame({'Values': solar_cap})
data_solar = np.array(solar_cap)
Q5_solar = np.percentile(data_solar, 5)
Q25_solar = np.percentile(data_solar, 25)
Q50_solar = np.median(data_solar)
Q75_solar = np.percentile(data_solar, 75)
Q95_solar = np.percentile(data_solar, 95)

ror_cap = selected_df[['Optimal Capacity']].loc['Run of River'].to_list()
data = [d for d in ror_cap if not np.isnan(d)]
df_ror = pd.DataFrame({'Values': data})
data_ror = np.array(data)
Q5_ror = np.percentile(data_ror, 5)
Q25_ror = np.percentile(data_ror, 25)
Q50_ror = np.median(data_ror)
Q75_ror = np.percentile(data_ror, 75)
Q95_ror = np.percentile(data_ror, 95)

transmission_cap = selected_df[['Optimal Capacity']].loc['Transmission'].to_list()
data = [d for d in transmission_cap if not np.isnan(d)]
df_transmission = pd.DataFrame({'Values': data})
data_transmission = np.array(data)
Q5_transmission = np.percentile(data_transmission, 5)
Q25_transmission = np.percentile(data_transmission, 25)
Q50_transmission = np.median(data_transmission)
Q75_transmission = np.percentile(data_transmission, 75)
Q95_transmission = np.percentile(data_transmission, 95)

import matplotlib.gridspec as gridspec
df_gen = pd.DataFrame({
    'Values': (df_solar.values/1000).flatten().tolist() + \
    (df_onwind.values/1000).flatten().tolist() + \
    (df_offwindac.values/1000).flatten().tolist() + \
    (df_offwinddc.values/1000).flatten().tolist() + \
    (df_ror.values/1000).flatten().tolist(),
    'Group': ['solar'] * len(df_solar) + ['onwind'] * len(df_onwind) + \
    ['offwindac'] * len(df_offwindac) + ['offwinddc'] * len(df_offwinddc) + \
    ['ror'] * len(df_ror)
})
df_sto = pd.DataFrame({
    'Values': df_battery.values.flatten().tolist() + df_h2.values.flatten().tolist(),
    'Group': ['battery'] * len(df_battery) + ['hydrogen'] * len(df_h2)
})
df_trans = pd.DataFrame({
    'Values': (df_transmission.values/1000).flatten().tolist(),
    'Group': ['transmission'] * len(df_transmission)
})
df_sys_cost = pd.DataFrame({
    'Values': df_TSC.values.flatten().tolist(),
    'Group': ['system cost'] * len(df_TSC)
})
palette = {'solar': 'gold', 'onwind': 'steelblue', 'offwindac': 'skyblue',
           'offwinddc': 'deepskyblue', 'ror': 'ivory'}
palette1 = {'battery': 'crimson', 'hydrogen': 'olive'}
palette2 = {'transmission': 'red'}
palette3 = {'system cost': 'orange'}

sns.set_theme(style='whitegrid')
#fig, (ax1, ax2, ax3, ax4) = plt.subplots(1, 4, figsize=(15, 10))
fig = plt.figure(figsize=(15, 10))
gs = gridspec.GridSpec(1, 4, width_ratios=[4, 2, 1, 1])
ax1 = fig.add_subplot(gs[0])
ax2 = fig.add_subplot(gs[1])
ax3 = fig.add_subplot(gs[2])
ax4 = fig.add_subplot(gs[3])
plt.subplots_adjust(wspace=0.4, hspace=0.1)
plt.autoscale(tight=True)
ax1.cla()
ax1.set_facecolor("white")
ax1.spines[['top', 'right']].set_visible(False)
sns.violinplot(ax=ax1, x='Group', y='Values', data=df_gen, palette=palette)
fig.text(0.27, -0.05, '(a) Generation Capacities', ha='center',
            size=14, fontweight='bold')
ax1.set_ylabel('[GW]', size=12, fontweight='bold')
ax1.set_xlabel('', size=12, fontweight='bold')
ax1.tick_params(axis='x', rotation=30, labelsize=15)
ax1.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in ax1.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax1.xaxis.grid(False)
ax1.yaxis.grid(False)

ax2.cla()
ax2.set_facecolor("white")
ax2.spines[['top', 'right']].set_visible(False)
sns.violinplot(ax=ax2, x='Group', y='Values', data=df_sto, palette=palette1)
fig.text(0.56, -0.05, '(b) Energy Storage Systems', ha='center',
            size=13, fontweight='bold')
ax2.set_ylabel('[MW]', size=12, fontweight='bold')
ax2.set_xlabel('', size=12, fontweight='bold')
ax2.tick_params(axis='x', rotation=30, labelsize=15)
ax2.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in ax2.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax2.xaxis.grid(False)
ax2.yaxis.grid(False)

ax3.cla()
ax3.set_facecolor("white")
ax3.spines[['top', 'right']].set_visible(False)
sns.violinplot(ax=ax3, x='Group', y='Values', data=df_trans, palette=palette2)
fig.text(0.73, -0.05, '(c) Transmission', ha='center',
            size=13, fontweight='bold')
ax3.set_ylabel('[GWKm]', size=12, fontweight='bold')
ax3.set_xlabel('', size=12, fontweight='bold')
ax3.tick_params(axis='x', rotation=30, labelsize=15)
ax3.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in ax3.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax3.xaxis.grid(False)
ax3.yaxis.grid(False)

ax4.cla()
ax4.set_facecolor("white")
ax4.spines[['top', 'right']].set_visible(False)
sns.violinplot(ax=ax4, x='Group', y='Values', data=df_sys_cost, palette=palette3)
fig.text(0.885, -0.05, '(d) Total System Cost', ha='center',
            size=13, fontweight='bold')
ax4.set_ylabel('[Billion ¬£ Per annum]', size=12, fontweight='bold')
ax4.set_xlabel('', size=12, fontweight='bold')
ax4.tick_params(axis='x', rotation=30, labelsize=15)
ax4.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in ax4.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax4.xaxis.grid(False)
ax4.yaxis.grid(False)
#plt.axis("off")
plt.savefig("cost_capacity_distribution.png", dpi=500, bbox_inches="tight")

"""###**Average System Cost Variation For Technological Units**"""

mc1 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 0].fillna(0) #.stack()
mc2 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 1].fillna(0)
mc3 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 2].fillna(0)
mc4 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 3].fillna(0)
mc5 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 4].fillna(0)
mc6 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 5].fillna(0)
mc7 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 6].fillna(0)
mc8 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 7].fillna(0)
mc9 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 8].fillna(0)
mc10 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 9].fillna(0)

## Add average system cost bar plot
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (12, 12)
fig, ax = plt.subplots(1, 1)
plt.subplots_adjust(wspace=0.01, hspace=0.01)
plt.autoscale(tight=True)
ax.cla()
ax.set_facecolor("white")
ax.spines[['top', 'right']].set_visible(False)
ax.set_xlabel('Technology', size=15, fontweight='bold')
ax.set_ylabel('Average System Cost [¬£/MWh]', size=15, fontweight='bold')
bar_width = 0.065
num_bars = 10
r = np.arange(len(mc1))
ax.bar(r, mc1, width=bar_width, color='gold', edgecolor='grey', label='MC 1')
ax.bar(r + bar_width, mc2, width=bar_width, color='gold', edgecolor='grey', label='MC 2')
ax.bar(r + 2.5*bar_width, mc3, width=bar_width, color='gold', edgecolor='grey', label='MC 3')
ax.bar(r + 3.5*bar_width, mc4, width=bar_width, color='gold', edgecolor='grey', label='MC 4')
ax.bar(r + 4.5*bar_width, mc5, width=bar_width, color='gold', edgecolor='grey', label='MC 5')
ax.bar(r + 5.5*bar_width, mc6, width=bar_width, color='gold', edgecolor='grey', label='MC 6')
ax.bar(r + 6.5*bar_width, mc7, width=bar_width, color='gold', edgecolor='grey', label='MC 7')
ax.bar(r + 7.5*bar_width, mc8, width=bar_width, color='gold', edgecolor='grey', label='MC 8')
ax.bar(r + 8.5*bar_width, mc9, width=bar_width, color='gold', edgecolor='grey', label='MC 9')
ax.bar(r + 9.5*bar_width, mc10, width=bar_width, color='gold', edgecolor='grey', label='MC 10')
ax.bar(r + 11.5*bar_width, df_avg_sys_cost_All_Mix['Avg_Sys_Cost'], width=bar_width,
        color='#CC4E5C', edgecolor='grey', label='W/O UQ')
ax.set_xticks(r + 5*bar_width)  # Center y-ticks between bars
ax.set_xticklabels(mc1.index)
legend = ax.legend(loc='best', ncol=4, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
ax.tick_params(axis='x', rotation=90, labelsize=12)
ax.tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in ax.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax.xaxis.grid(False)
ax.yaxis.grid(False)
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Average_System_Cost_Dispatch_Units_2022_monte_RES_LC.png')
plt.tight_layout()
plt.show()

"""###**Variability of the Optimal Renewable Generators and Storage Units Capacity Configurations**"""

concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0)
solar = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Solar'].tolist()
mean_value = sum(solar) / len(solar)
solar.append(mean_value)
onwind = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Onshore Wind'].tolist()
mean_value = sum(onwind) / len(onwind)
onwind.append(mean_value)
offwindac = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Offshore Wind (AC)'].tolist()
mean_value = sum(offwindac) / len(offwindac)
offwindac.append(mean_value)
offwinddc = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Offshore Wind (DC)'].tolist()
mean_value = sum(offwinddc) / len(offwinddc)
offwinddc.append(mean_value)
battery = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Battery Storage'].tolist()
mean_value = sum(battery) / len(battery)
battery.append(mean_value)
h2 = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Hydrogen Storage'].tolist()
mean_value = sum(h2) / len(h2)
h2.append(mean_value)

selected_categories = ['Battery Storage', 'Biomass', 'Coal', 'Combined-Cycle Gas',
                       'Hydrogen Storage', 'Nuclear', 'Offshore Wind (AC)',
                       'Offshore Wind (DC)', 'Oil', 'Onshore Wind', 'Run of River',
                       'Solar']
df = stat_All_Mix.loc[stat_All_Mix.index.get_level_values(1).isin(selected_categories)]
df['Avg_Sys_Cost'] = ((df['Capital Expenditure'] + df['Operational Expenditure']) / total_load)*0.84
df['Tot_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure'])*0.84
df['Gen_Elec'] = df['Supply'] / (1 + 0.07)
df['LCOE'] = (df['Tot_Sys_Cost'] / (1 + 0.07)) / df['Gen_Elec']
df_ = (df.groupby(level=1).sum()).fillna(0)
solar_ = df_[['Optimal Capacity']].fillna(0).loc['Solar'].tolist()
df_solar = solar_ + solar
onwind_ = df_[['Optimal Capacity']].fillna(0).loc['Onshore Wind'].tolist()
df_onwind = onwind_ + onwind
offwindac_ = df_[['Optimal Capacity']].fillna(0).loc['Offshore Wind (AC)'].tolist()
df_offwindac = offwindac_ + offwindac
offwinddc_ = df_[['Optimal Capacity']].fillna(0).loc['Offshore Wind (DC)'].tolist()
df_offwinddc = offwinddc_ + offwinddc
battery_ = df_[['Optimal Capacity']].fillna(0).loc['Battery Storage'].tolist()
df_battery = battery_ + battery
h2_ = df_[['Optimal Capacity']].fillna(0).loc['Hydrogen Storage'].tolist()
df_h2 = h2_ + h2

scenarios = ['W/O MC', 'MC 1', 'MC 2', 'MC 3', 'MC 4', 'MC 5', 'MC 6', 'MC 7',
             'MC 8', 'MC 9', 'MC 10', 'Mean MC']
colors = ['brown', 'teal', 'red', 'peru', 'darkolivegreen', 'violet', 'slategrey',
          'gold', 'navy', 'crimson', 'green', 'skyblue', 'black']

import matplotlib.patches as mpatches
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (16, 12)
fig, axs = plt.subplots(3, 2)
#plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)

axs[0, 0].cla()
axs[0, 0].set_facecolor("white")
axs[0, 0].spines[['top', 'right']].set_visible(False)
axs[0, 0].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[0, 0].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_solar))
bars = axs[0, 0].barh(positions, df_solar, height=bar_width, color=colors, edgecolor='grey')
axs[0, 0].set_yticks(positions)
axs[0, 0].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend1 = axs[0, 0].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
#axs[0, 0].tick_params(axis='x', rotation=0, labelsize=12)
axs[0, 0].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[0, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0, 0].xaxis.grid(False)
axs[0, 0].yaxis.grid(False)
fig.text(0.27, 0.66, '(a) Solar', ha='center', size=19, fontweight='bold')

axs[0, 1].cla()
axs[0, 1].set_facecolor("white")
axs[0, 1].spines[['top', 'right']].set_visible(False)
#axs[0, 1].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[0, 1].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_onwind))
bars = axs[0, 1].barh(positions, df_onwind, height=bar_width, color=colors, edgecolor='grey')
axs[0, 1].set_yticks(positions)
axs[0, 1].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend2 = axs[0, 1].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
#axs[0, 1].tick_params(axis='x', rotation=0, labelsize=12)
axs[0, 1].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[0, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0, 1].xaxis.grid(False)
axs[0, 1].yaxis.grid(False)
fig.text(0.77, 0.66, '(b) Onshore Wind', ha='center', size=19, fontweight='bold')

axs[1, 0].cla()
axs[1, 0].set_facecolor("white")
axs[1, 0].spines[['top', 'right']].set_visible(False)
axs[1, 0].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[1, 0].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_offwindac))
bars = axs[1, 0].barh(positions, df_offwindac, height=bar_width, color=colors, edgecolor='grey')
axs[1, 0].set_yticks(positions)
axs[1, 0].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend3 = axs[1, 0].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend3.get_frame().set_edgecolor('black')
legend3.get_frame().set_linewidth(1)
#axs[1, 0].tick_params(axis='x', rotation=0, labelsize=12)
axs[1, 0].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[1, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1, 0].xaxis.grid(False)
axs[1, 0].yaxis.grid(False)
fig.text(0.27, 0.33, '(c) Offshore Wind (AC)', ha='center', size=19, fontweight='bold')

axs[1, 1].cla()
axs[1, 1].set_facecolor("white")
axs[1, 1].spines[['top', 'right']].set_visible(False)
#axs[1, 1].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[1, 1].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_offwinddc))
bars = axs[1, 1].barh(positions, df_offwinddc, height=bar_width, color=colors, edgecolor='grey')
axs[1, 1].set_yticks(positions)
axs[1, 1].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend4 = axs[1, 1].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend4.get_frame().set_edgecolor('black')
legend4.get_frame().set_linewidth(1)
#axs[1, 1].tick_params(axis='x', rotation=0, labelsize=12)
axs[1, 1].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[1, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1, 1].xaxis.grid(False)
axs[1, 1].yaxis.grid(False)
fig.text(0.77, 0.33, '(d) Offshore Wind (DC)', ha='center', size=19, fontweight='bold')

axs[2, 0].cla()
axs[2, 0].set_facecolor("white")
axs[2, 0].spines[['top', 'right']].set_visible(False)
axs[2, 0].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[2, 0].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_battery))
bars = axs[2, 0].barh(positions, df_battery, height=bar_width, color=colors, edgecolor='grey')
axs[2, 0].set_yticks(positions)
axs[2, 0].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend5 = axs[2, 0].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend5.get_frame().set_edgecolor('black')
legend5.get_frame().set_linewidth(1)
#axs[2, 0].tick_params(axis='x', rotation=0, labelsize=12)
axs[2, 0].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[2, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[2, 0].xaxis.grid(False)
axs[2, 0].yaxis.grid(False)
fig.text(0.27, -0.01, '(e) Battery Storage', ha='center', size=19, fontweight='bold')

axs[2, 1].cla()
axs[2, 1].set_facecolor("white")
axs[2, 1].spines[['top', 'right']].set_visible(False)
#axs[2, 1].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[2, 1].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_h2))
bars = axs[2, 1].barh(positions, df_h2, height=bar_width, color=colors, edgecolor='grey')
axs[2, 1].set_yticks(positions)
axs[2, 1].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend6 = axs[2, 1].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend6.get_frame().set_edgecolor('black')
legend6.get_frame().set_linewidth(1)
#axs[2, 1].tick_params(axis='x', rotation=0, labelsize=12)
axs[2, 1].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[2, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[2, 1].xaxis.grid(False)
axs[2, 1].yaxis.grid(False)
fig.text(0.77, -0.01, '(f) Hydrogen Storage', ha='center', size=19, fontweight='bold')

output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Optimal_RES_Storage_Config_Variability_Scenarios.png')
plt.tight_layout()
plt.subplots_adjust(wspace=0.2, hspace=0.3)
plt.show()

"""###**Charactering the Uncertainties of Renewable Generators, Storage Units, and Transmission Optimal Capacities With Respect to the Total System Cost**

###**Sensitivity Analysis Using Tornado Diagrams and Spider**
"""

selected_categories = ['Battery Storage', 'Hydrogen Storage', 'Offshore Wind (AC)',
                       'Offshore Wind (DC)', 'Onshore Wind', 'Run of River',
                       'Solar', 'Transmission']
selected_df = concatenated_dfs_all_sys_cost_monte.loc[selected_categories]
df = selected_df[['Optimal Capacity']].T
df['Total System Cost'] = dfs_tot_sys_cost_monte
df.index = pd.Index(range(1, len(df) + 1))
df = df.fillna(0)
# Fit a linear regression model
X = df.drop(['Total System Cost'], axis=1)
y = df['Total System Cost']
reg = LinearRegression()
reg.fit(X, y)
# Base case prediction
base_prediction = reg.predict(X).mean()
variation_range = 95 # 95 % CI  # percentage variation from the mean # 95 % CI
# Calculate the impact of varying each input parameter
sensitivities = {}
low_impacts = []
high_impacts = []
features = X.columns
for feature in features:
    mean_value = X[feature].mean()
    variation = mean_value * variation_range / 100
    X_high = X.copy()
    X_high[feature] = mean_value + variation
    high_prediction = reg.predict(X_high).mean()
    X_low = X.copy()
    X_low[feature] = mean_value - variation
    low_prediction = reg.predict(X_low).mean()
    sensitivities[feature] = (high_prediction - low_prediction) / 2
    low_impacts.append(low_prediction)
    high_impacts.append(high_prediction)

# Plot the tornado diagrams
sns.set_theme(style='whitegrid')
fig, axs = plt.subplots(3, 1, figsize=(8, 12))
plt.subplots_adjust(wspace=0.1, hspace=0.45)
plt.autoscale(tight=True)
axs[0].cla()
axs[0].set_facecolor("white")
axs[0].spines[['top', 'right']].set_visible(False)
features = list(sensitivities.keys())
impacts = [sensitivities[feature] for feature in features]
bars = axs[0].barh(features, impacts, color='gold', edgecolor='black')
axs[0].set_xlabel('Impact on Total System Cost [¬£ Per Annum]', size=8, fontweight='bold')
axs[0].set_ylabel('Technologies', size=10, fontweight='bold')
axs[0].tick_params(axis='y', rotation=0, labelsize=8)
axs[0].tick_params(axis='x', rotation=30, labelsize=10)
# Calculate total width for normalization
total_width = sum(abs(bar.get_width()) for bar in bars)
# Add data labels for the sensitivity plot with percentages
for bar in bars:
    width = bar.get_width()
    percentage = (abs(width) / total_width) * 100
    axs[0].annotate(f'{percentage:.1f}%',
                    xy=(width, bar.get_y() + bar.get_height() / 2),
                    xytext=(9, 0),  # 5 points horizontal offset
                    textcoords="offset points",
                    ha='right', va='center', rotation=90,
                    fontsize=7,  # Adjust font size if needed
                    color='black',  # Text color
                    bbox=dict(boxstyle='round,pad=0.3', fc='white', ec='black', lw=1))
plt.figtext(0.4, 0.66, '(a) Sensitivity analysis tornado plot', fontsize=10,
            rotation=0, weight="bold")
for spine in axs[0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0].xaxis.grid(False)
axs[0].yaxis.grid(False)

axs[1].cla()
axs[1].set_facecolor("white")
axs[1].spines[['top', 'right']].set_visible(False)
axs[1].axvline(base_prediction, color='navy', linestyle='--', label='Base Prediction',
               linewidth=2.5)
# Plot the low impacts
axs[1].barh(features, base_prediction - np.array(low_impacts), left=low_impacts,
            color='#CC4E5C', edgecolor='black', label='Low Prediction')
# Plot the high impacts
axs[1].barh(features, high_impacts - base_prediction, left=base_prediction,
            color='teal', edgecolor='black', label='High Prediction')
axs[1].set_xlabel('Total System Cost [¬£ Per Annum]', size=8, fontweight='bold')
axs[1].set_ylabel('Technologies', size=10, fontweight='bold')
axs[1].tick_params(axis='y', rotation=0, labelsize=8)
axs[1].tick_params(axis='x', rotation=30, labelsize=10)
plt.figtext(0.4, 0.32, '(b) Low and high prediction tornado plot', fontsize=10,
            rotation=0, weight="bold")
legend = axs[1].legend(loc='best', ncol=1, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
for spine in axs[1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1].xaxis.grid(False)
axs[1].yaxis.grid(False)

selected_categories = ['Battery Storage', 'Hydrogen Storage', 'Offshore Wind (AC)',
                       'Offshore Wind (DC)', 'Onshore Wind', 'Run of River',
                       'Solar', 'Transmission']
selected_df = concatenated_dfs_all_sys_cost_monte.loc[selected_categories]
df = selected_df[['Optimal Capacity']].T
df['Total System Cost'] = dfs_tot_sys_cost_monte
df.index = pd.Index(range(1, len(df) + 1))
df = df.fillna(0)
# Fit a linear regression model
X = df.drop(['Total System Cost'], axis=1)
y = df['Total System Cost']
reg = LinearRegression()
reg.fit(X, y)
variation_range = np.linspace(-0.95, 0.95, 20)  # ¬±95% variation
# Initialize lists to store results
results = {}
# Calculate the impact of varying each input parameter
base_prediction = reg.predict(X.mean().values.reshape(1, -1))[0]
for feature in X.columns:
    feature_mean = X[feature].mean()
    feature_values = feature_mean * (1 + variation_range)
    other_features = X.drop(columns=[feature]).mean().values.reshape(1, -1)
    output_changes = []
    for value in feature_values:
        X_temp = other_features.copy()
        X_temp = np.insert(X_temp, list(X.columns).index(feature), value, axis=1)
        output_changes.append(reg.predict(X_temp)[0] - base_prediction)
    results[feature] = output_changes
# Plot the results
markers = ['o', 's', 'D', '^', 'v', '*', 'p', 'h', 'H', 'X', 'd', '|', '_']
colors = cm.get_cmap('tab10', X.shape[0]).colors  # Use a colormap to generate colors
axs[2].cla()
axs[2].set_facecolor("white")
axs[2].spines[['top', 'right']].set_visible(False)
for i, (feature, output_changes) in enumerate(results.items()):
    axs[2].plot(variation_range * 100, output_changes, label=feature,
            marker=markers[i % len(markers)], color=colors[i % len(colors)])
axs[2].set_xlabel('Variation in Input Parameter (%)', size=8, fontweight='bold')
axs[2].set_ylabel('Change in Output [¬£]', size=10, fontweight='bold')
axs[2].set_xticks(np.arange(-95, 100, 10))  # Set x-ticks from -95% to 95% in steps of 10%
axs[2].set_xticklabels([f'{int(x)}' for x in np.arange(-95, 100, 10)])  # Convert x-ticks to percentage format
axs[2].tick_params(axis='y', rotation=0, labelsize=8)
axs[2].tick_params(axis='x', rotation=30, labelsize=10)
plt.figtext(0.4, -0.02, '(c) Sensitivity Analysis Spider Plot', fontsize=10,
            rotation=0, weight="bold")
for spine in axs[2].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[2].xaxis.grid(True)
axs[2].yaxis.grid(True)
legend = axs[2].legend(loc='best', ncol=1, frameon=True, fontsize='8',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)

output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/tornado_Spider_plots_scenario_1.png')
plt.tight_layout()
plt.show()

"""**Print the Table of Change in Output variable**"""

columns = list(results.keys())
# Create the table header
header = f"{'Change (%)':>10} " + " ".join(f"{col:>20}" for col in columns)
# Create the rows
rows = []
for i, change in enumerate(variation_range):
    row = f"{change:>10.2%} " + " ".join(f"{results[col][i]:>20.2f}" for col in columns)
    rows.append(row)
# Combine header and rows
table = "\n".join([header] + rows)
# Print the table
print(table)

"""##**Scenario 2 : RES Only - Renewable Generators**"""

seed = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
dfs_marg_price = []
dfs_marg_price2 = []
dfs_tot_sys_cost = []
dfs_soc = []
dfs_sto_disp = []
dfs_sto_charg = []
dfs_stat_disp = []
dfs_stat_avg_tot_cost = []
for s in seed:
    path = f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_RES_monte/elec_s_6_ec_lcopt_Co2L-1H_m{s}.nc"
    n = pypsa.Network(path)
    # Marginal Price
    df = (n.buses_t.marginal_price*0.84)
    dfs_marg_price.append(df)
    df = (n.buses_t.marginal_price.mean(axis=1) * 0.84)
    dfs_marg_price2.append(df)
    # Total System Cost
    df = (n.objective *0.84)
    dfs_tot_sys_cost.append(df)
    # SOC
    df = n.storage_units_t.state_of_charge
    dfs_soc.append(df)
    # Power Dispatch
    df = n.storage_units_t.p_dispatch
    dfs_sto_disp.append(df)
    # Power Charging
    df = n.storage_units_t.p_store
    dfs_sto_charg.append(df)
    # Dispatch
    df_ = n.statistics.dispatch(groupby=get_bus_and_carrier, aggregate_time=False).T
    df = df_[["Generator", "StorageUnit"]].droplevel(0, axis=1)
    dfs_stat_disp.append(df)
    # Average System Cost
    total_load = n.loads_t.p.sum().sum()
    selected_categories = ['Battery Storage', 'Biomass', 'Coal', 'Combined-Cycle Gas',
                           'Hydrogen Storage', 'Nuclear', 'Offshore Wind (AC)',
                           'Offshore Wind (DC)', 'Oil', 'Onshore Wind', 'Run of River', 'Solar']
    df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
    df['Avg_Sys_Cost'] = ((df['Capital Expenditure'] + df['Operational Expenditure']) / total_load)*0.84
    df['Tot_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure'])*0.84
    df['Gen_Elec'] = df['Supply'] / (1 + 0.07)
    df['LCOE'] = (df['Tot_Sys_Cost'] / (1 + 0.07)) / df['Gen_Elec']
    df_ = (df.groupby(level=1).sum()).fillna(0)
    dfs_stat_avg_tot_cost.append(df_)

concatenated_df = pd.concat(dfs_marg_price, axis=1)
concatenated_df_soc = pd.concat(dfs_soc, axis=1)
concatenated_df_sto_disp = pd.concat(dfs_sto_disp, axis=1)
concatenated_df_sto_charg = pd.concat(dfs_sto_charg, axis=1)
concatenated_df_stat_disp = pd.concat(dfs_stat_disp, axis=1)
concatenated_df_stat_avg_tot_cost = pd.concat(dfs_stat_avg_tot_cost, axis=1)

marg_price_monte_RES = pd.DataFrame()
for col_name, col_data in concatenated_df.items():
    if np.issubdtype(col_data.dtype, np.number):
        marg_price_monte_RES[col_name] = concatenated_df[col_name].mean(axis=1)
mean_marg_price_monte_RES = marg_price_monte_RES.mean(axis=1)

marg_price_monte_std_RES = pd.DataFrame()
for col_name, col_data in concatenated_df.items():
    if np.issubdtype(col_data.dtype, np.number):
        marg_price_monte_std_RES[col_name] = concatenated_df[col_name].std(axis=1)
std_marg_price_monte_RES = marg_price_monte_std_RES.mean(axis=1)

soc_monte_RES = pd.DataFrame()
for col_name, col_data in concatenated_df_soc.items():
    if np.issubdtype(col_data.dtype, np.number):
        soc_monte_RES[col_name] = concatenated_df_soc[col_name].mean(axis=1)
mean_soc_monte_RES = soc_monte_RES.mean(axis=1)

sto_disp_monte_RES = pd.DataFrame()
for col_name, col_data in concatenated_df_sto_disp.items():
    if np.issubdtype(col_data.dtype, np.number):
        sto_disp_monte_RES[col_name] = concatenated_df_sto_disp[col_name].mean(axis=1)
mean_sto_disp_monte_RES = sto_disp_monte_RES.mean(axis=1)

sto_charg_monte_RES = pd.DataFrame()
for col_name, col_data in concatenated_df_sto_charg.items():
    if np.issubdtype(col_data.dtype, np.number):
        sto_charg_monte_RES[col_name] = concatenated_df_sto_charg[col_name].mean(axis=1)
mean_sto_charg_monte_RES = sto_charg_monte_RES.mean(axis=1)

stat_disp_monte_RES = pd.DataFrame()
for col_name, col_data in concatenated_df_stat_disp.items():
    if np.issubdtype(col_data.dtype, np.number):
        stat_disp_monte_RES[col_name] = concatenated_df_stat_disp[col_name].mean(axis=1)
mean_stat_disp_monte_RES = stat_disp_monte_RES.mean(axis=1)

stat_avg_tot_cost_monte_RES = pd.DataFrame()
for col_name, col_data in concatenated_df_stat_avg_tot_cost.items():
    if np.issubdtype(col_data.dtype, np.number):
        stat_avg_tot_cost_monte_RES[col_name] = concatenated_df_stat_avg_tot_cost[col_name].mean(axis=1)
mean_stat_avg_tot_cost_monte_RES = stat_avg_tot_cost_monte_RES.mean(axis=1)

avg_marg_price_2025_monte_RES = marg_price_monte_RES.mean(axis=0).mean()
print('=====================')
print(avg_marg_price_2025_monte_RES)
print(dfs_tot_sys_cost)
print('=====================')

"""**Obtain the Probability Distribution Values - lower, upper, and best estimates (mean) - 90 CI**"""

df = concatenated_df_stat_avg_tot_cost.fillna(0)
def calculate_statistics(group):
    mean = group.mean(axis=1)
    std = group.std(axis=1)
    ci_90_low = mean - 1.645 * std / np.sqrt(group.shape[1])
    ci_90_high = mean + 1.645 * std / np.sqrt(group.shape[1])
    return mean, std, ci_90_low, ci_90_high
unique_cols = df.columns
for col in unique_cols:
    col_group = df.filter(regex=f'^{col}')
    mean, std, ci_90_low, ci_90_high = calculate_statistics(
        col_group)
    df[f'{col}_mean'] = mean
    df[f'{col}_std'] = std
    df[f'{col}_95CI_Low'] = ci_90_low
    df[f'{col}_95CI_High'] = ci_90_high
df_ = df[['Avg_Sys_Cost_95CI_Low', 'Avg_Sys_Cost_mean', 'Avg_Sys_Cost_95CI_High']]
df_['Parameter'] = df_.index

"""**Perform Sensitivity Analysis Using the Tornado Charts to illustrate Uncertainties around the Marginal Cost of Electricity**"""

dfLow = df_.Avg_Sys_Cost_95CI_Low
dfHigh = df_.Avg_Sys_Cost_95CI_High
category = df_.index
sns.set_theme(style='whitegrid')
#plt.rcParams["figure.figsize"] = (12, 8)
fig, ax = plt.subplots(figsize=(8, 5))
plt.subplots_adjust(wspace=0.01, hspace=0.01)
#plt.autoscale(tight=True)
ax.cla()
ax.set_facecolor("white")
ax.spines[['top', 'right']].set_visible(False)
ax.barh(category, dfLow, align='center', height = 0.4, facecolor='gold',
        edgecolor='black')
ax.barh(category, dfHigh*-1, align='center', height = 0.4, facecolor='teal',
        edgecolor='black')
# Show the leave % on each  bar
for i, low in enumerate(dfLow):
    ax.text(low + 1, category[i],'{:,.0f}%'.format(low), ha='center',
            size = 10, color = "black")
# Show the remain % on each  bar
for i, High in enumerate(dfHigh):
    ax.text(( High*-1) -1, category[i],'{:,.0f}%'.format(High), ha='center',
            size = 10, color = "black")
# Show the title at the top of each  bar
# As the y axis is a category axis to be able to plot the labels outise the bars, we need to use the get method
for bar, cat in zip(ax.patches, category):
    width = bar.get_width()
    label_y = bar.get_y() + bar.get_height() +0.03
    plt.text(0, label_y, s=f'{cat}', size = 10)
# set the titles for each bar
# use figtext as it will allow to position multiple text values anywhere
# You can only have one ttiel in same position and you can only have ax.text inside the grid.
plt.figtext(0.05, 0.59, 'High - 90% CI', fontsize=12, rotation=90, weight="bold")
plt.figtext(0.83, 0.59, 'Low - 10% CI', fontsize=12, rotation=90, weight="bold")
for spine in ax.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax.xaxis.grid(False)
ax.yaxis.grid(False)
plt.axis('off') #turn all axis off
#add title and subtitle
plt.suptitle('',  fontsize = 10, x=0.46, y=1.18, weight="bold" )
plt.title("", fontsize = 12, x=0.43, y=1.18, color = "#bdbdbd")

"""**Visualize the Hourly Average Marginal Price of Electricity (¬£/MWh)**"""

df = pd.DataFrame(dfs_marg_price2).T
df = df.fillna(0)
# Function to compute mean and 95% CI across rows
def compute_mean_and_ci(row):
    mean = np.mean(row)
    se = stats.sem(row)  # Standard error of the mean
    ci_margin = se * stats.t.ppf(0.975, len(row)-1)  # 95% CI margin
    ci_low = mean - ci_margin
    ci_high = mean + ci_margin
    return pd.Series([mean, ci_low, ci_high], index=['mean', 'ci_low', 'ci_high'])
# Apply the function across rows
results = df.apply(compute_mean_and_ci, axis=1)
mean_series = results['mean']
ci_low_series = results['ci_low']
ci_high_series = results['ci_high']

# Obtain Data for One Day to Test and Compare
plt.set_cmap("tab10")
plt.cm.tab20(0)
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (12, 8)
fig, axs = plt.subplots(1, 1)
plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)
axs.cla()
axs.set_facecolor("white")
axs.spines[['top', 'right']].set_visible(False)
axs.set_ylabel('[¬£/MWh]', size=18, fontweight='bold')
axs.set_xlabel('Time [h]', size=18, fontweight='bold')
axs.plot(mean_series.index, mean_series, label='Mean w/UQ', color=plt.cm.tab10(1),
         linewidth=2.0)
axs.plot(mean_series.index, mean_marginal_price_RES, label='Mean w/o UQ', color=plt.cm.tab10(4),
         linewidth=2.0)
axs.fill_between(mean_series.index, ci_low_series, ci_high_series, alpha=0.3, label='90% CI')
axs.plot(mean_series.index, ci_low_series, label='CI Low', color=plt.cm.tab10(0), linestyle='dashed',
         linewidth=2.0)
axs.plot(mean_series.index, ci_high_series, label='CI High', color=plt.cm.tab10(2), linestyle='dashed',
         linewidth=2.0)
legend = axs.legend(loc='best', ncol=1, frameon=True, fontsize='14',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
axs.tick_params(axis='x', rotation=30, labelsize=15)
axs.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in axs.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs.xaxis.grid(False)
axs.yaxis.grid(False)
#axs.set_yscale('log')
plt.gca().xaxis.set_major_formatter(plt.matplotlib.dates.DateFormatter('%b'))
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Average_Marginal_Price_Time_Series_2022_monteRES.png')
plt.tight_layout()
plt.show()

"""**Visualize the Hourly Average Marginal Price of Electricity (¬£/MWh) For Each Four Weather Seasons**"""

df = pd.DataFrame(dfs_marg_price2).T
df = df.fillna(0)
df2 = pd.DataFrame(mean_marginal_price_RES)
season_months = {
    'Winter': '01',  # January
    'Spring': '04',  # April
    'Summer': '07',  # July
    'Fall': '10'     # October
}
def compute_mean_and_ci(row):
    mean = np.mean(row)
    se = stats.sem(row)  # Standard error of the mean
    ci_margin = se * stats.t.ppf(0.975, len(row)-1)  # 95% CI margin
    ci_low = mean - ci_margin
    ci_high = mean + ci_margin
    return pd.Series([mean, ci_low, ci_high], index=['mean', 'ci_low', 'ci_high'])
plt.set_cmap("tab10")
plt.cm.tab20(0)
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (14, 10)
fig, axes = plt.subplots(2, 2)
axes = axes.flatten()
plt.autoscale(tight=True)
# Process and plot each season
for i, (season, month) in enumerate(season_months.items()):
    # Slice the DataFrame for the specific month
    month_df = df[df.index.month == int(month)]
    mean_marginal_price_RES_month = df2[df2.index.month == int(month)]
    # Apply the function across rows
    results = month_df.apply(compute_mean_and_ci, axis=1)
    # Convert each column to a separate Series
    mean_series = results['mean']
    ci_low_series = results['ci_low']
    ci_high_series = results['ci_high']
    # Plotting the results
    axes[i].cla()
    axes[i].set_facecolor("white")
    axes[i].spines[['top', 'right']].set_visible(False)
    axes[i].set_ylabel('[¬£/MWh]', size=13, fontweight='bold')
    axes[i].set_xlabel('Time [h]', size=13, fontweight='bold')
    axes[i].plot(mean_series, label='Mean with UQ', color=plt.cm.tab10(1), linewidth=2.0)
    axes[i].plot(mean_marginal_price_RES_month, label='Mean w/o UQ',
                 color=plt.cm.tab10(4), linewidth=2.0)
    axes[i].fill_between(mean_series.index, ci_low_series, ci_high_series, color='blue', alpha=0.2, label='95% CI')
    axes[i].plot(mean_series.index, ci_low_series, label='CI Low', color=plt.cm.tab10(0),
                 linestyle='dashed', linewidth=2.0)
    axes[i].plot(mean_series.index, ci_high_series, label='CI High', color=plt.cm.tab10(2),
                 linestyle='dashed', linewidth=2.0)
    #axes[i].set_title(f'{season} (Month: {month})')
    axes[i].tick_params(axis='x', rotation=30, labelsize=15)
    axes[i].tick_params(axis='y', rotation=0, labelsize=15)
    legend = axes[i].legend(loc='best', ncol=2, frameon=True, fontsize='12',
                            fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
    legend.get_frame().set_edgecolor('black')
    legend.get_frame().set_linewidth(1)
    for spine in axes[i].spines.values():
        spine.set_linewidth(2)
        spine.set_edgecolor('black')
    axes[i].xaxis.grid(False)
    axes[i].yaxis.grid(False)
    axes[i].xaxis.set_major_formatter(plt.matplotlib.dates.DateFormatter('%b'))
fig.text(0.27, 0.50, '(a) Winter (Month: January)', ha='center', size=13, fontweight='bold')
fig.text(0.77, 0.50, '(b) Spring (Month: April)', ha='center', size=13, fontweight='bold')
fig.text(0.25, -0.03, '(c) Summer (Month: July)', ha='center', size=13, fontweight='bold')
fig.text(0.76, -0.03, '(d) Autumn (Month: October)', ha='center', size=13, fontweight='bold')
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Average_Marginal_Price_Time_Series_2022_monteRES.png')
plt.tight_layout()
plt.subplots_adjust(wspace=0.15, hspace=0.5)
plt.show()

"""**Print the Average Marginal Cost or Price of Electricity and the Total System Cost With 95% CI**"""

dfs_trans = []
dfs_gen_cap = []
dfs_storage = []
seed = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for s in seed:
    path = f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_RES_monte/elec_s_6_ec_lcopt_Co2L-1H_m{s}.nc"
    n = pypsa.Network(path)
    selected_categories = ['AC', 'B2B', 'DC', 'H2 electrolysis',
                           'H2 fuel cell', 'H2 pipeline', 'battery charger',
                           'battery discharger']
    df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
    df_ = (df.groupby(level=1).sum()).fillna(0)
    dfs_trans.append(df_)
    selected_categories = ['Biomass', 'Coal', 'Combined-Cycle Gas', 'Nuclear',
                           'Offshore Wind (AC)', 'Offshore Wind (DC)', 'Oil',
                           'Onshore Wind', 'Run of River', 'Solar']
    df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
    df_ = (df.groupby(level=1).sum()).fillna(0)
    dfs_gen_cap.append(df_)
    selected_categories = ['StorageUnit']
    df = n.statistics().loc[n.statistics().index.get_level_values(0).isin(selected_categories)]
    df_ = (df.groupby(level=0).sum()).fillna(0)
    dfs_storage.append(df_)

concatenated_dfs_trans = pd.concat(dfs_trans, axis=1)
concatenated_dfs_gen_cap = pd.concat(dfs_gen_cap, axis=1)
concatenated_dfs_storage = pd.concat(dfs_storage, axis=1)

df = concatenated_dfs_trans
rows_to_sum = ['B2B', 'DC', 'H2 electrolysis', 'H2 fuel cell', 'H2 pipeline',
               'battery charger', 'battery discharger']
sum_row = df.loc[rows_to_sum].sum()
df.loc['Link'] = sum_row
df = df.fillna(0)
opt_cap_link = df[['Optimal Capacity']].loc['Link'].to_list()
inst_cap_link = df[['Installed Capacity']].loc['Link'].to_list()
new_exp_link = [a - b for a, b in zip(opt_cap_link, inst_cap_link)]

opt_cap_line = concatenated_dfs_trans[['Optimal Capacity']].loc['AC'].to_list()
inst_cap_line = concatenated_dfs_trans[['Installed Capacity']].loc['AC'].to_list()
new_exp_line = [a - b for a, b in zip(opt_cap_line, inst_cap_line)]

df = concatenated_dfs_gen_cap
rows_to_sum = ['Offshore Wind (AC)', 'Offshore Wind (DC)', 'Onshore Wind',
               'Run of River', 'Solar']
sum_row = df.loc[rows_to_sum].sum()
df.loc['Gen'] = sum_row
df = df.fillna(0)
opt_cap_gen_cap = df[['Optimal Capacity']].loc['Gen'].to_list()
inst_cap_gen_cap = df[['Installed Capacity']].loc['Gen'].to_list()
new_exp_gen_cap = [a - b for a, b in zip(opt_cap_gen_cap, inst_cap_gen_cap)]
opt_gen_sup = df[['Supply']].loc['Gen'].to_list()

opt_sto = concatenated_dfs_storage[['Optimal Capacity']].loc['StorageUnit'].to_list()
inst_sto = concatenated_dfs_storage[['Installed Capacity']].loc['StorageUnit'].to_list()
new_exp_sto = [a - b for a, b in zip(opt_sto, inst_sto)]

df = pd.DataFrame(dfs_marg_price2).T
df = df.fillna(0)
# Function to compute mean and 95% CI across rows
def compute_mean_and_ci(row):
    mean = np.mean(row)
    se = stats.sem(row)  # Standard error of the mean
    ci_margin = se * stats.t.ppf(0.975, len(row)-1)  # 95% CI margin
    ci_low = mean - ci_margin
    ci_high = mean + ci_margin
    return pd.Series([mean, ci_low, ci_high], index=['mean', 'ci_low', 'ci_high'])
# Apply the function across rows
results = df.apply(compute_mean_and_ci, axis=1)
# Average marginal price of electricity
mean_series = results['mean'].mean()
ci_low_series = results['ci_low'].mean()
ci_high_series = results['ci_high'].mean()
df2 = mean_marginal_price_RES.mean()
print('================================================================================')
print(f'Average Marginal Price of Electricity With UQ in ¬£/MWh: {mean_series:.2f}')
print(f'Average Marginal Price of Electricity With UQ (Low) in ¬£/MWh: {ci_low_series:.2f}')
print(f'Average Marginal Price of Electricity With UQ (High) in ¬£/MWh: {ci_high_series:.2f}')
print(f'Average Marginal Price of Electricity Without UQ in ¬£/MWh: {df2:.2f}')
print('================================================================================')
# Total System Cost
data = dfs_tot_sys_cost
data_clean = [x for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
df2 = tot_annual_sys_cost_2025_RES
print('================================================================================')
print(f'Total System Cost With UQ in Billion ¬£/year: {mean:.2f}')
print(f'Total System Cost With UQ (Low) in Billion ¬£/year: {ci_low:.2f}')
print(f'Total System Cost With UQ (High) in Billion ¬£/year: {ci_high:.2f}')
print(f'Total System Cost Without UQ in Billion ¬£/year: {df2:.2f}')
print('================================================================================')

# New Link
data = new_exp_link
data_clean = [x if x >= 0 else 0 for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
print('================================================================================')
print(f'New Transmission Link With UQ in MWKm: {mean:.2f}')
print(f'New Transmission Link  With UQ (Low) in MWKm: {ci_low:.2f}')
print(f'New Transmission Link  With UQ (High) in MWKm: {ci_high:.2f}')
print('================================================================================')

# New Line
data = new_exp_line
data_clean = [x if x >= 0 else 0 for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
print('================================================================================')
print(f'New Transmission Line With UQ in MWKm: {mean:.2f}')
print(f'New Transmission Line  With UQ (Low) in MWKm: {ci_low:.2f}')
print(f'New Transmission Line  With UQ (High) in MWKm: {ci_high:.2f}')
print('================================================================================')

# New Installed Capacity of Generators
data = new_exp_gen_cap
data_clean = [x if x >= 0 else 0 for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
print('================================================================================')
print(f'New Generator Installed Capacity With UQ in MW: {mean:.2f}')
print(f'New Generator Installed Capacity With UQ (Low) in MW: {ci_low:.2f}')
print(f'New Generator Installed Capacity With UQ (High) in MW: {ci_high:.2f}')
print('================================================================================')

# New Generation Supply
data = opt_gen_sup
data_clean = [x if x >= 0 else 0 for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
print('================================================================================')
print(f'New Generation Supply With UQ in MW: {mean:.2f}')
print(f'New Generation Supply With UQ (Low) in MW: {ci_low:.2f}')
print(f'New Generation Supply With UQ (High) in MW: {ci_high:.2f}')
print('================================================================================')

# New Storage Capacity
data = new_exp_sto
data_clean = [x if x >= 0 else 0 for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
print('================================================================================')
print(f'New Storage Capacity With UQ in MW: {mean:.2f}')
print(f'New Storage Capacity With UQ (Low) in MW: {ci_low:.2f}')
print(f'New Storage Capacity With UQ (High) in MW: {ci_high:.2f}')
print('================================================================================')

"""###**Obtain the Total System Cost Distribution**"""

seed = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
dfs_tot_sys_cost = []
dfs_tot_sys_cost_RES = []
dfs_all_sys_cost = []
dfs_all_sys_cost_RES = []
for s in seed:
    path = f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_RES_monte/elec_s_6_ec_lcopt_Co2L-1H_m{s}.nc"
    try:
        n = pypsa.Network(path)
        # Total System Cost
        df = (n.objective *0.84)
        dfs_tot_sys_cost.append(df)
        dfs_tot_sys_cost_RES.append(df)
        total_load = n.loads_t.p.sum().sum()
        selected_categories = ['Biomass', 'Coal', 'Combined-Cycle Gas', 'Nuclear',
                               'Offshore Wind (AC)', 'Offshore Wind (DC)', 'Oil', 'Onshore Wind',
                               'Run of River', 'Solar', 'AC', 'B2B', 'DC', 'H2 electrolysis',
                               'H2 fuel cell', 'H2 pipeline', 'battery charger', 'battery discharger',
                               'Battery Storage', 'Hydrogen Storage', 'Battery Storage',
                               'Hydrogen Storage']
        df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
        df['Avg_Sys_Cost'] = ((df['Capital Expenditure'] + df['Operational Expenditure']) / total_load)*0.84
        df['Tot_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure'])*0.84
        df_ = (df.groupby(level=1).sum()).fillna(0)
        rows_to_sum = ['AC', 'B2B', 'DC', 'H2 electrolysis', 'H2 fuel cell', 'H2 pipeline',
                       'battery charger', 'battery discharger']
        try:
            sum_row = df_.loc[rows_to_sum].sum()
            df_.loc['Transmission'] = sum_row
            df_ = df_.fillna(0)
        except KeyError as e:
            print(f"KeyError for seed {s}: {e}")
        dfs_all_sys_cost.append(df_)
        dfs_all_sys_cost_RES.append(df_)
    except Exception as e:
        print(f"Error processing seed {s}: {e}")
if dfs_all_sys_cost:
    concatenated_dfs_all_sys_cost = pd.concat(dfs_all_sys_cost, axis=1)
if dfs_all_sys_cost_RES:
    concatenated_dfs_all_sys_cost_RES = pd.concat(dfs_all_sys_cost_RES, axis=1)

#data = [d for d in dfs_tot_sys_cost if not np.isnan(d)]
df_TSC = pd.DataFrame({'Values': dfs_tot_sys_cost})
tot_sys_cost_monte_RES = dfs_tot_sys_cost
data_TSC = np.array(dfs_tot_sys_cost)
Q5_TSC = np.percentile(data_TSC, 5)
Q25_TSC = np.percentile(data_TSC, 25)
Q50_TSC = np.median(data_TSC)
Q75_TSC = np.percentile(data_TSC, 75)
Q95_TSC = np.percentile(data_TSC, 95)

selected_categories = ['Battery Storage', 'Hydrogen Storage', 'Offshore Wind (AC)',
                       'Offshore Wind (DC)', 'Onshore Wind', 'Run of River',
                       'Solar', 'Transmission']
selected_df = concatenated_dfs_all_sys_cost.loc[selected_categories]
battery_storage_cap = selected_df[['Optimal Capacity']].loc['Battery Storage'].to_list()
#data = [d for d in battery_storage_cap if not np.isnan(d)]
df_battery = pd.DataFrame({'Values': battery_storage_cap})
data_battery = np.array(battery_storage_cap)
Q5_battery = np.percentile(data_battery, 5)
Q25_battery = np.percentile(data_battery, 25)
Q50_battery = np.median(data_battery)
Q75_battery = np.percentile(data_battery, 75)
Q95_battery = np.percentile(data_battery, 95)

h2_storage_cap = selected_df[['Optimal Capacity']].loc['Hydrogen Storage'].to_list()
#data = [d for d in h2_storage_cap if not np.isnan(d)]
df_h2 = pd.DataFrame({'Values': h2_storage_cap})
data_h2 = np.array(h2_storage_cap)
Q5_h2 = np.percentile(data_h2, 5)
Q25_h2 = np.percentile(data_h2, 25)
Q50_h2 = np.median(data_h2)
Q75_h2 = np.percentile(data_h2, 75)
Q95_h2 = np.percentile(data_h2, 95)

onwind_cap = selected_df[['Optimal Capacity']].loc['Onshore Wind'].to_list()
#data = [d for d in onwind_cap if not np.isnan(d)]
df_onwind = pd.DataFrame({'Values': onwind_cap})
data_onwind = np.array(onwind_cap)
Q5_onwind = np.percentile(data_onwind, 5)
Q25_onwind = np.percentile(data_onwind, 25)
Q50_onwind = np.median(data_onwind)
Q75_onwind = np.percentile(data_onwind, 75)
Q95_onwind = np.percentile(data_onwind, 95)

offwindac_cap = selected_df[['Optimal Capacity']].loc['Offshore Wind (AC)'].to_list()
#data = [d for d in offwindac_cap if not np.isnan(d)]
df_offwindac = pd.DataFrame({'Values': offwindac_cap})
data_offwindac = np.array(offwindac_cap)
Q5_offwindac = np.percentile(data_offwindac, 5)
Q25_offwindac = np.percentile(data_offwindac, 25)
Q50_offwindac = np.median(data_offwindac)
Q75_offwindac = np.percentile(data_offwindac, 75)
Q95_offwindac = np.percentile(data_offwindac, 95)

offwinddc_cap = selected_df[['Optimal Capacity']].loc['Offshore Wind (DC)'].to_list()
#data = [d for d in offwinddc_cap if not np.isnan(d)]
df_offwinddc = pd.DataFrame({'Values': offwinddc_cap})
data_offwinddc = np.array(offwinddc_cap)
Q5_offwinddc = np.percentile(data_offwinddc, 5)
Q25_offwinddc = np.percentile(data_offwinddc, 25)
Q50_offwinddc = np.median(data_offwinddc)
Q75_offwinddc = np.percentile(data_offwinddc, 75)
Q95_offwinddc = np.percentile(data_offwinddc, 95)

solar_cap = selected_df[['Optimal Capacity']].loc['Solar'].to_list()
#data = [d for d in solar_cap if not np.isnan(d)]
df_solar = pd.DataFrame({'Values': solar_cap})
data_solar = np.array(solar_cap)
Q5_solar = np.percentile(data_solar, 5)
Q25_solar = np.percentile(data_solar, 25)
Q50_solar = np.median(data_solar)
Q75_solar = np.percentile(data_solar, 75)
Q95_solar = np.percentile(data_solar, 95)

ror_cap = selected_df[['Optimal Capacity']].loc['Run of River'].to_list()
data = [d for d in ror_cap if not np.isnan(d)]
df_ror = pd.DataFrame({'Values': data})
data_ror = np.array(data)
Q5_ror = np.percentile(data_ror, 5)
Q25_ror = np.percentile(data_ror, 25)
Q50_ror = np.median(data_ror)
Q75_ror = np.percentile(data_ror, 75)
Q95_ror = np.percentile(data_ror, 95)

transmission_cap = selected_df[['Optimal Capacity']].loc['Transmission'].to_list()
data = [d for d in transmission_cap if not np.isnan(d)]
df_transmission = pd.DataFrame({'Values': data})
data_transmission = np.array(data)
Q5_transmission = np.percentile(data_transmission, 5)
Q25_transmission = np.percentile(data_transmission, 25)
Q50_transmission = np.median(data_transmission)
Q75_transmission = np.percentile(data_transmission, 75)
Q95_transmission = np.percentile(data_transmission, 95)

import matplotlib.gridspec as gridspec
df_gen = pd.DataFrame({
    'Values': (df_solar.values/1000).flatten().tolist() + \
    (df_onwind.values/1000).flatten().tolist() + \
    (df_offwindac.values/1000).flatten().tolist() + \
    (df_offwinddc.values/1000).flatten().tolist() + \
    (df_ror.values/1000).flatten().tolist(),
    'Group': ['solar'] * len(df_solar) + ['onwind'] * len(df_onwind) + \
    ['offwindac'] * len(df_offwindac) + ['offwinddc'] * len(df_offwinddc) + \
    ['ror'] * len(df_ror)
})
df_sto = pd.DataFrame({
    'Values': df_battery.values.flatten().tolist() + df_h2.values.flatten().tolist(),
    'Group': ['battery'] * len(df_battery) + ['hydrogen'] * len(df_h2)
})
df_trans = pd.DataFrame({
    'Values': (df_transmission.values/1000).flatten().tolist(),
    'Group': ['transmission'] * len(df_transmission)
})
df_sys_cost = pd.DataFrame({
    'Values': df_TSC.values.flatten().tolist(),
    'Group': ['system cost'] * len(df_TSC)
})
palette = {'solar': 'gold', 'onwind': 'steelblue', 'offwindac': 'skyblue',
           'offwinddc': 'deepskyblue', 'ror': 'ivory'}
palette1 = {'battery': 'crimson', 'hydrogen': 'olive'}
palette2 = {'transmission': 'red'}
palette3 = {'system cost': 'orange'}

sns.set_theme(style='whitegrid')
#fig, (ax1, ax2, ax3, ax4) = plt.subplots(1, 4, figsize=(15, 10))
fig = plt.figure(figsize=(15, 10))
gs = gridspec.GridSpec(1, 4, width_ratios=[4, 2, 1, 1])
ax1 = fig.add_subplot(gs[0])
ax2 = fig.add_subplot(gs[1])
ax3 = fig.add_subplot(gs[2])
ax4 = fig.add_subplot(gs[3])
plt.subplots_adjust(wspace=0.4, hspace=0.1)
plt.autoscale(tight=True)
ax1.cla()
ax1.set_facecolor("white")
ax1.spines[['top', 'right']].set_visible(False)
sns.violinplot(ax=ax1, x='Group', y='Values', data=df_gen, palette=palette)
fig.text(0.27, -0.05, '(a) Generation Capacities', ha='center',
            size=14, fontweight='bold')
ax1.set_ylabel('[GW]', size=12, fontweight='bold')
ax1.set_xlabel('', size=12, fontweight='bold')
ax1.tick_params(axis='x', rotation=30, labelsize=15)
ax1.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in ax1.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax1.xaxis.grid(False)
ax1.yaxis.grid(False)

ax2.cla()
ax2.set_facecolor("white")
ax2.spines[['top', 'right']].set_visible(False)
sns.violinplot(ax=ax2, x='Group', y='Values', data=df_sto, palette=palette1)
fig.text(0.56, -0.05, '(b) Energy Storage Systems', ha='center',
            size=13, fontweight='bold')
ax2.set_ylabel('[MW]', size=12, fontweight='bold')
ax2.set_xlabel('', size=12, fontweight='bold')
ax2.tick_params(axis='x', rotation=30, labelsize=15)
ax2.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in ax2.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax2.xaxis.grid(False)
ax2.yaxis.grid(False)

ax3.cla()
ax3.set_facecolor("white")
ax3.spines[['top', 'right']].set_visible(False)
sns.violinplot(ax=ax3, x='Group', y='Values', data=df_trans, palette=palette2)
fig.text(0.73, -0.05, '(c) Transmission', ha='center',
            size=13, fontweight='bold')
ax3.set_ylabel('[GWKm]', size=12, fontweight='bold')
ax3.set_xlabel('', size=12, fontweight='bold')
ax3.tick_params(axis='x', rotation=30, labelsize=15)
ax3.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in ax3.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax3.xaxis.grid(False)
ax3.yaxis.grid(False)

ax4.cla()
ax4.set_facecolor("white")
ax4.spines[['top', 'right']].set_visible(False)
sns.violinplot(ax=ax4, x='Group', y='Values', data=df_sys_cost, palette=palette3)
fig.text(0.885, -0.05, '(d) Total System Cost', ha='center',
            size=13, fontweight='bold')
ax4.set_ylabel('[Billion ¬£ Per annum]', size=12, fontweight='bold')
ax4.set_xlabel('', size=12, fontweight='bold')
ax4.tick_params(axis='x', rotation=30, labelsize=15)
ax4.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in ax4.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax4.xaxis.grid(False)
ax4.yaxis.grid(False)
#plt.axis("off")
plt.savefig("cost_capacity_distribution.png", dpi=500, bbox_inches="tight")

"""###**Average System Cost Variation For Technological Units**"""

mc1 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 0].fillna(0) #.stack()
mc2 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 1].fillna(0)
mc3 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 2].fillna(0)
mc4 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 3].fillna(0)
mc5 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 4].fillna(0)
mc6 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 5].fillna(0)
mc7 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 6].fillna(0)
mc8 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 7].fillna(0)
mc9 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 8].fillna(0)
mc10 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 9].fillna(0)

## Add average system cost bar plot
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (12, 12)
fig, ax = plt.subplots(1, 1)
plt.subplots_adjust(wspace=0.01, hspace=0.01)
plt.autoscale(tight=True)
ax.cla()
ax.set_facecolor("white")
ax.spines[['top', 'right']].set_visible(False)
ax.set_xlabel('Technology', size=15, fontweight='bold')
ax.set_ylabel('Average System Cost [¬£/MWh]', size=15, fontweight='bold')
bar_width = 0.065
num_bars = 10
r = np.arange(len(mc1))
ax.bar(r, mc1, width=bar_width, color='gold', edgecolor='grey', label='MC 1')
ax.bar(r + bar_width, mc2, width=bar_width, color='gold', edgecolor='grey', label='MC 2')
ax.bar(r + 2.5*bar_width, mc3, width=bar_width, color='gold', edgecolor='grey', label='MC 3')
ax.bar(r + 3.5*bar_width, mc4, width=bar_width, color='gold', edgecolor='grey', label='MC 4')
ax.bar(r + 4.5*bar_width, mc5, width=bar_width, color='gold', edgecolor='grey', label='MC 5')
ax.bar(r + 5.5*bar_width, mc6, width=bar_width, color='gold', edgecolor='grey', label='MC 6')
ax.bar(r + 6.5*bar_width, mc7, width=bar_width, color='gold', edgecolor='grey', label='MC 7')
ax.bar(r + 7.5*bar_width, mc8, width=bar_width, color='gold', edgecolor='grey', label='MC 8')
ax.bar(r + 8.5*bar_width, mc9, width=bar_width, color='gold', edgecolor='grey', label='MC 9')
ax.bar(r + 9.5*bar_width, mc10, width=bar_width, color='gold', edgecolor='grey', label='MC 10')
ax.bar(r + 11.5*bar_width, df_avg_sys_cost_RES['Avg_Sys_Cost'], width=bar_width,
        color='#CC4E5C', edgecolor='grey', label='W/O UQ')
ax.set_xticks(r + 5*bar_width)  # Center y-ticks between bars
ax.set_xticklabels(mc1.index)
legend = ax.legend(loc='best', ncol=4, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
ax.tick_params(axis='x', rotation=90, labelsize=12)
ax.tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in ax.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax.xaxis.grid(False)
ax.yaxis.grid(False)
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Average_System_Cost_Dispatch_Units_2022_monte_RES_LC.png')
plt.tight_layout()
plt.show()

"""###**Variability of the Optimal Renewable Generators and Storage Units Capacity Configurations**"""

concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0)
solar = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Solar'].tolist()
mean_value = sum(solar) / len(solar)
solar.append(mean_value)
onwind = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Onshore Wind'].tolist()
mean_value = sum(onwind) / len(onwind)
onwind.append(mean_value)
offwindac = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Offshore Wind (AC)'].tolist()
mean_value = sum(offwindac) / len(offwindac)
offwindac.append(mean_value)
offwinddc = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Offshore Wind (DC)'].tolist()
mean_value = sum(offwinddc) / len(offwinddc)
offwinddc.append(mean_value)
battery = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Battery Storage'].tolist()
mean_value = sum(battery) / len(battery)
battery.append(mean_value)
h2 = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Hydrogen Storage'].tolist()
mean_value = sum(h2) / len(h2)
h2.append(mean_value)

selected_categories = ['Battery Storage', 'Biomass', 'Coal', 'Combined-Cycle Gas',
                       'Hydrogen Storage', 'Nuclear', 'Offshore Wind (AC)',
                       'Offshore Wind (DC)', 'Oil', 'Onshore Wind', 'Run of River',
                       'Solar']
df = stat_RES.loc[stat_RES.index.get_level_values(1).isin(selected_categories)]
df['Avg_Sys_Cost'] = ((df['Capital Expenditure'] + df['Operational Expenditure']) / total_load)*0.84
df['Tot_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure'])*0.84
df['Gen_Elec'] = df['Supply'] / (1 + 0.07)
df['LCOE'] = (df['Tot_Sys_Cost'] / (1 + 0.07)) / df['Gen_Elec']
df_ = (df.groupby(level=1).sum()).fillna(0)
solar_ = df_[['Optimal Capacity']].fillna(0).loc['Solar'].tolist()
df_solar = solar_ + solar
onwind_ = df_[['Optimal Capacity']].fillna(0).loc['Onshore Wind'].tolist()
df_onwind = onwind_ + onwind
offwindac_ = df_[['Optimal Capacity']].fillna(0).loc['Offshore Wind (AC)'].tolist()
df_offwindac = offwindac_ + offwindac
offwinddc_ = df_[['Optimal Capacity']].fillna(0).loc['Offshore Wind (DC)'].tolist()
df_offwinddc = offwinddc_ + offwinddc
battery_ = df_[['Optimal Capacity']].fillna(0).loc['Battery Storage'].tolist()
df_battery = battery_ + battery
h2_ = df_[['Optimal Capacity']].fillna(0).loc['Hydrogen Storage'].tolist()
df_h2 = h2_ + h2

scenarios = ['W/O MC', 'MC 1', 'MC 2', 'MC 3', 'MC 4', 'MC 5', 'MC 6', 'MC 7',
             'MC 8', 'MC 9', 'MC 10', 'Mean MC']
colors = ['brown', 'teal', 'red', 'peru', 'darkolivegreen', 'violet', 'slategrey',
          'gold', 'navy', 'crimson', 'green', 'skyblue', 'black']

import matplotlib.patches as mpatches
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (16, 12)
fig, axs = plt.subplots(3, 2)
#plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)

axs[0, 0].cla()
axs[0, 0].set_facecolor("white")
axs[0, 0].spines[['top', 'right']].set_visible(False)
axs[0, 0].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[0, 0].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_solar))
bars = axs[0, 0].barh(positions, df_solar, height=bar_width, color=colors, edgecolor='grey')
axs[0, 0].set_yticks(positions)
axs[0, 0].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend1 = axs[0, 0].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
#axs[0, 0].tick_params(axis='x', rotation=0, labelsize=12)
axs[0, 0].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[0, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0, 0].xaxis.grid(False)
axs[0, 0].yaxis.grid(False)
fig.text(0.27, 0.66, '(a) Solar', ha='center', size=19, fontweight='bold')

axs[0, 1].cla()
axs[0, 1].set_facecolor("white")
axs[0, 1].spines[['top', 'right']].set_visible(False)
#axs[0, 1].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[0, 1].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_onwind))
bars = axs[0, 1].barh(positions, df_onwind, height=bar_width, color=colors, edgecolor='grey')
axs[0, 1].set_yticks(positions)
axs[0, 1].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend2 = axs[0, 1].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
#axs[0, 1].tick_params(axis='x', rotation=0, labelsize=12)
axs[0, 1].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[0, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0, 1].xaxis.grid(False)
axs[0, 1].yaxis.grid(False)
fig.text(0.77, 0.66, '(b) Onshore Wind', ha='center', size=19, fontweight='bold')

axs[1, 0].cla()
axs[1, 0].set_facecolor("white")
axs[1, 0].spines[['top', 'right']].set_visible(False)
axs[1, 0].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[1, 0].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_offwindac))
bars = axs[1, 0].barh(positions, df_offwindac, height=bar_width, color=colors, edgecolor='grey')
axs[1, 0].set_yticks(positions)
axs[1, 0].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend3 = axs[1, 0].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend3.get_frame().set_edgecolor('black')
legend3.get_frame().set_linewidth(1)
#axs[1, 0].tick_params(axis='x', rotation=0, labelsize=12)
axs[1, 0].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[1, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1, 0].xaxis.grid(False)
axs[1, 0].yaxis.grid(False)
fig.text(0.27, 0.33, '(c) Offshore Wind (AC)', ha='center', size=19, fontweight='bold')

axs[1, 1].cla()
axs[1, 1].set_facecolor("white")
axs[1, 1].spines[['top', 'right']].set_visible(False)
#axs[1, 1].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[1, 1].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_offwinddc))
bars = axs[1, 1].barh(positions, df_offwinddc, height=bar_width, color=colors, edgecolor='grey')
axs[1, 1].set_yticks(positions)
axs[1, 1].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend4 = axs[1, 1].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend4.get_frame().set_edgecolor('black')
legend4.get_frame().set_linewidth(1)
#axs[1, 1].tick_params(axis='x', rotation=0, labelsize=12)
axs[1, 1].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[1, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1, 1].xaxis.grid(False)
axs[1, 1].yaxis.grid(False)
fig.text(0.77, 0.33, '(d) Offshore Wind (DC)', ha='center', size=19, fontweight='bold')

axs[2, 0].cla()
axs[2, 0].set_facecolor("white")
axs[2, 0].spines[['top', 'right']].set_visible(False)
axs[2, 0].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[2, 0].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_battery))
bars = axs[2, 0].barh(positions, df_battery, height=bar_width, color=colors, edgecolor='grey')
axs[2, 0].set_yticks(positions)
axs[2, 0].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend5 = axs[2, 0].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend5.get_frame().set_edgecolor('black')
legend5.get_frame().set_linewidth(1)
#axs[2, 0].tick_params(axis='x', rotation=0, labelsize=12)
axs[2, 0].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[2, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[2, 0].xaxis.grid(False)
axs[2, 0].yaxis.grid(False)
fig.text(0.27, -0.01, '(e) Battery Storage', ha='center', size=19, fontweight='bold')

axs[2, 1].cla()
axs[2, 1].set_facecolor("white")
axs[2, 1].spines[['top', 'right']].set_visible(False)
#axs[2, 1].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[2, 1].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_h2))
bars = axs[2, 1].barh(positions, df_h2, height=bar_width, color=colors, edgecolor='grey')
axs[2, 1].set_yticks(positions)
axs[2, 1].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend6 = axs[2, 1].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend6.get_frame().set_edgecolor('black')
legend6.get_frame().set_linewidth(1)
#axs[2, 1].tick_params(axis='x', rotation=0, labelsize=12)
axs[2, 1].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[2, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[2, 1].xaxis.grid(False)
axs[2, 1].yaxis.grid(False)
fig.text(0.77, -0.01, '(f) Hydrogen Storage', ha='center', size=19, fontweight='bold')

output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Optimal_RES_Storage_Config_Variability_Scenarios.png')
plt.tight_layout()
plt.subplots_adjust(wspace=0.2, hspace=0.3)
plt.show()

"""###**Charactering the Uncertainties of Renewable Generators, Storage Units, and Transmission Optimal Capacities With Respect to the Total System Cost**

###**Sensitivity Analysis Using Tornado Diagrams and Spider**
"""

selected_categories = ['Battery Storage', 'Hydrogen Storage', 'Offshore Wind (AC)',
                       'Offshore Wind (DC)', 'Onshore Wind', 'Run of River',
                       'Solar', 'Transmission']
selected_df = concatenated_dfs_all_sys_cost_RES.loc[selected_categories]
df = selected_df[['Optimal Capacity']].T
df['Total System Cost'] = dfs_tot_sys_cost_RES
df.index = pd.Index(range(1, len(df) + 1))
df = df.fillna(0)
# Fit a linear regression model
X = df.drop(['Total System Cost'], axis=1)
y = df['Total System Cost']
reg = LinearRegression()
reg.fit(X, y)
# Base case prediction
base_prediction = reg.predict(X).mean()
variation_range = 95 # 95 % CI  # percentage variation from the mean # 95 % CI
# Calculate the impact of varying each input parameter
sensitivities = {}
low_impacts = []
high_impacts = []
features = X.columns
for feature in features:
    mean_value = X[feature].mean()
    variation = mean_value * variation_range / 100
    X_high = X.copy()
    X_high[feature] = mean_value + variation
    high_prediction = reg.predict(X_high).mean()
    X_low = X.copy()
    X_low[feature] = mean_value - variation
    low_prediction = reg.predict(X_low).mean()
    sensitivities[feature] = (high_prediction - low_prediction) / 2
    low_impacts.append(low_prediction)
    high_impacts.append(high_prediction)

# Plot the tornado diagrams
sns.set_theme(style='whitegrid')
fig, axs = plt.subplots(3, 1, figsize=(8, 12))
plt.subplots_adjust(wspace=0.1, hspace=0.45)
plt.autoscale(tight=True)
axs[0].cla()
axs[0].set_facecolor("white")
axs[0].spines[['top', 'right']].set_visible(False)
features = list(sensitivities.keys())
impacts = [sensitivities[feature] for feature in features]
bars = axs[0].barh(features, impacts, color='gold', edgecolor='black')
axs[0].set_xlabel('Impact on Total System Cost [¬£ Per Annum]', size=8, fontweight='bold')
axs[0].set_ylabel('Technologies', size=10, fontweight='bold')
axs[0].tick_params(axis='y', rotation=0, labelsize=8)
axs[0].tick_params(axis='x', rotation=30, labelsize=10)
# Calculate total width for normalization
total_width = sum(abs(bar.get_width()) for bar in bars)
# Add data labels for the sensitivity plot with percentages
for bar in bars:
    width = bar.get_width()
    percentage = (abs(width) / total_width) * 100
    axs[0].annotate(f'{percentage:.1f}%',
                    xy=(width, bar.get_y() + bar.get_height() / 2),
                    xytext=(9, 0),  # 5 points horizontal offset
                    textcoords="offset points",
                    ha='right', va='center', rotation=90,
                    fontsize=7,  # Adjust font size if needed
                    color='black',  # Text color
                    bbox=dict(boxstyle='round,pad=0.3', fc='white', ec='black', lw=1))
plt.figtext(0.4, 0.66, '(a) Sensitivity analysis tornado plot', fontsize=10,
            rotation=0, weight="bold")
for spine in axs[0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0].xaxis.grid(False)
axs[0].yaxis.grid(False)

axs[1].cla()
axs[1].set_facecolor("white")
axs[1].spines[['top', 'right']].set_visible(False)
axs[1].axvline(base_prediction, color='navy', linestyle='--', label='Base Prediction',
               linewidth=2.5)
# Plot the low impacts
axs[1].barh(features, base_prediction - np.array(low_impacts), left=low_impacts,
            color='#CC4E5C', edgecolor='black', label='Low Prediction')
# Plot the high impacts
axs[1].barh(features, high_impacts - base_prediction, left=base_prediction,
            color='teal', edgecolor='black', label='High Prediction')
axs[1].set_xlabel('Total System Cost [¬£ Per Annum]', size=8, fontweight='bold')
axs[1].set_ylabel('Technologies', size=10, fontweight='bold')
axs[1].tick_params(axis='y', rotation=0, labelsize=8)
axs[1].tick_params(axis='x', rotation=30, labelsize=10)
plt.figtext(0.4, 0.33, '(b) Low and high prediction tornado plot', fontsize=10,
            rotation=0, weight="bold")
legend = axs[1].legend(loc='best', ncol=1, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
for spine in axs[1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1].xaxis.grid(False)
axs[1].yaxis.grid(False)

selected_categories = ['Battery Storage', 'Hydrogen Storage', 'Offshore Wind (AC)',
                       'Offshore Wind (DC)', 'Onshore Wind', 'Run of River',
                       'Solar', 'Transmission']
selected_df = concatenated_dfs_all_sys_cost_RES.loc[selected_categories]
df = selected_df[['Optimal Capacity']].T
df['Total System Cost'] = dfs_tot_sys_cost_RES
df.index = pd.Index(range(1, len(df) + 1))
df = df.fillna(0)
# Fit a linear regression model
X = df.drop(['Total System Cost'], axis=1)
y = df['Total System Cost']
reg = LinearRegression()
reg.fit(X, y)
variation_range = np.linspace(-0.95, 0.95, 20)  # ¬±95% variation
# Initialize lists to store results
results = {}
# Calculate the impact of varying each input parameter
base_prediction = reg.predict(X.mean().values.reshape(1, -1))[0]
for feature in X.columns:
    feature_mean = X[feature].mean()
    feature_values = feature_mean * (1 + variation_range)
    other_features = X.drop(columns=[feature]).mean().values.reshape(1, -1)
    output_changes = []
    for value in feature_values:
        X_temp = other_features.copy()
        X_temp = np.insert(X_temp, list(X.columns).index(feature), value, axis=1)
        output_changes.append(reg.predict(X_temp)[0] - base_prediction)
    results[feature] = output_changes
# Plot the results
markers = ['o', 's', 'D', '^', 'v', '*', 'p', 'h', 'H', 'X', 'd', '|', '_']
colors = cm.get_cmap('tab10', X.shape[0]).colors  # Use a colormap to generate colors
axs[2].cla()
axs[2].set_facecolor("white")
axs[2].spines[['top', 'right']].set_visible(False)
for i, (feature, output_changes) in enumerate(results.items()):
    axs[2].plot(variation_range * 100, output_changes, label=feature,
            marker=markers[i % len(markers)], color=colors[i % len(colors)])
axs[2].set_xlabel('Variation in Input Parameter (%)', size=8, fontweight='bold')
axs[2].set_ylabel('Change in Output [¬£]', size=10, fontweight='bold')
axs[2].set_xticks(np.arange(-95, 100, 10))  # Set x-ticks from -95% to 95% in steps of 10%
axs[2].set_xticklabels([f'{int(x)}' for x in np.arange(-95, 100, 10)])  # Convert x-ticks to percentage format
axs[2].tick_params(axis='y', rotation=0, labelsize=8)
axs[2].tick_params(axis='x', rotation=30, labelsize=10)
plt.figtext(0.4, -0.02, '(c) Sensitivity Analysis Spider Plot', fontsize=10,
            rotation=0, weight="bold")
for spine in axs[2].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[2].xaxis.grid(True)
axs[2].yaxis.grid(True)
legend = axs[2].legend(loc='best', ncol=1, frameon=True, fontsize='8',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)

output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/tornado_Spider_plots_scenario_2.png')
plt.tight_layout()
plt.show()

"""**Print the Table of Change in Output variable**"""

columns = list(results.keys())
# Create the table header
header = f"{'Change (%)':>10} " + " ".join(f"{col:>20}" for col in columns)
# Create the rows
rows = []
for i, change in enumerate(variation_range):
    row = f"{change:>10.2%} " + " ".join(f"{results[col][i]:>20.2f}" for col in columns)
    rows.append(row)
# Combine header and rows
table = "\n".join([header] + rows)
# Print the table
print(table)

"""##**Scenario 3 : RES and Low Carbon Generators Only**"""

seed = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
dfs_marg_price = []
dfs_marg_price2 = []
dfs_tot_sys_cost = []
dfs_soc = []
dfs_sto_disp = []
dfs_sto_charg = []
dfs_stat_disp = []
dfs_stat_avg_tot_cost = []
for s in seed:
    path = f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_RES_LC_monte/elec_s_6_ec_lcopt_Co2L-1H_m{s}.nc"
    n = pypsa.Network(path)
    # Marginal Price
    df = (n.buses_t.marginal_price*0.84)
    dfs_marg_price.append(df)
    df = (n.buses_t.marginal_price.mean(axis=1) * 0.84)
    dfs_marg_price2.append(df)
    # Total System Cost
    df = (n.objective *0.84)
    dfs_tot_sys_cost.append(df)
    # SOC
    df = n.storage_units_t.state_of_charge
    dfs_soc.append(df)
    # Power Dispatch
    df = n.storage_units_t.p_dispatch
    dfs_sto_disp.append(df)
    # Power Charging
    df = n.storage_units_t.p_store
    dfs_sto_charg.append(df)
    # Dispatch
    df_ = n.statistics.dispatch(groupby=get_bus_and_carrier, aggregate_time=False).T
    df = df_[["Generator", "StorageUnit"]].droplevel(0, axis=1)
    dfs_stat_disp.append(df)
    # Average System Cost
    total_load = n.loads_t.p.sum().sum()
    selected_categories = ['Battery Storage', 'Biomass', 'Coal', 'Combined-Cycle Gas',
                           'Hydrogen Storage', 'Nuclear', 'Offshore Wind (AC)',
                           'Offshore Wind (DC)', 'Oil', 'Onshore Wind', 'Run of River', 'Solar']
    df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
    df['Avg_Sys_Cost'] = ((df['Capital Expenditure'] + df['Operational Expenditure']) / total_load)*0.84
    df['Tot_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure'])*0.84
    df['Gen_Elec'] = df['Supply'] / (1 + 0.07)
    df['LCOE'] = (df['Tot_Sys_Cost'] / (1 + 0.07)) / df['Gen_Elec']
    df_ = (df.groupby(level=1).sum()).fillna(0)
    dfs_stat_avg_tot_cost.append(df_)

concatenated_df = pd.concat(dfs_marg_price, axis=1)
concatenated_df_soc = pd.concat(dfs_soc, axis=1)
concatenated_df_sto_disp = pd.concat(dfs_sto_disp, axis=1)
concatenated_df_sto_charg = pd.concat(dfs_sto_charg, axis=1)
concatenated_df_stat_disp = pd.concat(dfs_stat_disp, axis=1)
concatenated_df_stat_avg_tot_cost = pd.concat(dfs_stat_avg_tot_cost, axis=1)

marg_price_monte_RES_LC = pd.DataFrame()
for col_name, col_data in concatenated_df.items():
    if np.issubdtype(col_data.dtype, np.number):
        marg_price_monte_RES_LC[col_name] = concatenated_df[col_name].mean(axis=1)
mean_marg_price_monte_RES_LC = marg_price_monte_RES_LC.mean(axis=1)

marg_price_monte_std_RES_LC = pd.DataFrame()
for col_name, col_data in concatenated_df.items():
    if np.issubdtype(col_data.dtype, np.number):
        marg_price_monte_std_RES_LC[col_name] = concatenated_df[col_name].std(axis=1)
std_marg_price_monte_RES_LC = marg_price_monte_std_RES_LC.mean(axis=1)

soc_monte_RES_LC = pd.DataFrame()
for col_name, col_data in concatenated_df_soc.items():
    if np.issubdtype(col_data.dtype, np.number):
        soc_monte_RES_LC[col_name] = concatenated_df_soc[col_name].mean(axis=1)
mean_soc_monte_RES_LC = soc_monte_RES_LC.mean(axis=1)

sto_disp_monte_RES_LC = pd.DataFrame()
for col_name, col_data in concatenated_df_sto_disp.items():
    if np.issubdtype(col_data.dtype, np.number):
        sto_disp_monte_RES_LC[col_name] = concatenated_df_sto_disp[col_name].mean(axis=1)
mean_sto_disp_monte_RES_LC = sto_disp_monte_RES_LC.mean(axis=1)

sto_charg_monte_RES_LC = pd.DataFrame()
for col_name, col_data in concatenated_df_sto_charg.items():
    if np.issubdtype(col_data.dtype, np.number):
        sto_charg_monte_RES_LC[col_name] = concatenated_df_sto_charg[col_name].mean(axis=1)
mean_sto_charg_monte_RES_LC = sto_charg_monte_RES_LC.mean(axis=1)

stat_disp_monte_RES_LC = pd.DataFrame()
for col_name, col_data in concatenated_df_stat_disp.items():
    if np.issubdtype(col_data.dtype, np.number):
        stat_disp_monte_RES_LC[col_name] = concatenated_df_stat_disp[col_name].mean(axis=1)
mean_stat_disp_monte_RES_LC = stat_disp_monte_RES_LC.mean(axis=1)

stat_avg_tot_cost_monte_RES_LC = pd.DataFrame()
for col_name, col_data in concatenated_df_stat_avg_tot_cost.items():
    if np.issubdtype(col_data.dtype, np.number):
        stat_avg_tot_cost_monte_RES_LC[col_name] = concatenated_df_stat_avg_tot_cost[col_name].mean(axis=1)
mean_stat_avg_tot_cost_monte_RES_LC = stat_avg_tot_cost_monte_RES_LC.mean(axis=1)

avg_marg_price_2025_monte_RES_LC = marg_price_monte_RES_LC.mean(axis=0).mean()
print('=====================')
print(avg_marg_price_2025_monte_RES_LC)
print(dfs_tot_sys_cost)
print('=====================')

"""**Obtain the Probability Distribution Values - lower, upper, and best estimates (mean) - 90 CI**"""

df = concatenated_df_stat_avg_tot_cost.fillna(0)
def calculate_statistics(group):
    mean = group.mean(axis=1)
    std = group.std(axis=1)
    ci_90_low = mean - 1.645 * std / np.sqrt(group.shape[1])
    ci_90_high = mean + 1.645 * std / np.sqrt(group.shape[1])
    return mean, std, ci_90_low, ci_90_high
unique_cols = df.columns
for col in unique_cols:
    col_group = df.filter(regex=f'^{col}')
    mean, std, ci_90_low, ci_90_high = calculate_statistics(
        col_group)
    df[f'{col}_mean'] = mean
    df[f'{col}_std'] = std
    df[f'{col}_95CI_Low'] = ci_90_low
    df[f'{col}_95CI_High'] = ci_90_high
df_ = df[['Avg_Sys_Cost_95CI_Low', 'Avg_Sys_Cost_mean', 'Avg_Sys_Cost_95CI_High']]
df_['Parameter'] = df_.index

"""**Perform Sensitivity Analysis Using the Tornado Charts to illustrate Uncertainties around the Marginal Cost of Electricity**"""

dfLow = df_.Avg_Sys_Cost_95CI_Low
dfHigh = df_.Avg_Sys_Cost_95CI_High
category = df_.index
sns.set_theme(style='whitegrid')
#plt.rcParams["figure.figsize"] = (12, 8)
fig, ax = plt.subplots(figsize=(8, 5))
plt.subplots_adjust(wspace=0.01, hspace=0.01)
#plt.autoscale(tight=True)
ax.cla()
ax.set_facecolor("white")
ax.spines[['top', 'right']].set_visible(False)
ax.barh(category, dfLow, align='center', height = 0.4, facecolor='gold',
        edgecolor='black')
ax.barh(category, dfHigh*-1, align='center', height = 0.4, facecolor='teal',
        edgecolor='black')
# Show the leave % on each  bar
for i, low in enumerate(dfLow):
    ax.text(low + 1, category[i],'{:,.0f}%'.format(low), ha='center',
            size = 10, color = "black")
# Show the remain % on each  bar
for i, High in enumerate(dfHigh):
    ax.text(( High*-1) -1, category[i],'{:,.0f}%'.format(High), ha='center',
            size = 10, color = "black")
# Show the title at the top of each  bar
# As the y axis is a category axis to be able to plot the labels outise the bars, we need to use the get method
for bar, cat in zip(ax.patches, category):
    width = bar.get_width()
    label_y = bar.get_y() + bar.get_height() +0.03
    plt.text(0, label_y, s=f'{cat}', size = 10)
# set the titles for each bar
# use figtext as it will allow to position multiple text values anywhere
# You can only have one ttiel in same position and you can only have ax.text inside the grid.
plt.figtext(0.05, 0.59, 'High - 90% CI', fontsize=12, rotation=90, weight="bold")
plt.figtext(0.83, 0.59, 'Low - 10% CI', fontsize=12, rotation=90, weight="bold")
for spine in ax.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax.xaxis.grid(False)
ax.yaxis.grid(False)
plt.axis('off') #turn all axis off
#add title and subtitle
plt.suptitle('',  fontsize = 10, x=0.46, y=1.18, weight="bold" )
plt.title("", fontsize = 12, x=0.43, y=1.18, color = "#bdbdbd")

"""**Visualize the Hourly Average Marginal Price of Electricity (¬£/MWh)**"""

df = pd.DataFrame(dfs_marg_price2).T
df = df.fillna(0)
# Function to compute mean and 95% CI across rows
def compute_mean_and_ci(row):
    mean = np.mean(row)
    se = stats.sem(row)  # Standard error of the mean
    ci_margin = se * stats.t.ppf(0.975, len(row)-1)  # 95% CI margin
    ci_low = mean - ci_margin
    ci_high = mean + ci_margin
    return pd.Series([mean, ci_low, ci_high], index=['mean', 'ci_low', 'ci_high'])
# Apply the function across rows
results = df.apply(compute_mean_and_ci, axis=1)
mean_series = results['mean']
ci_low_series = results['ci_low']
ci_high_series = results['ci_high']

# Obtain Data for One Day to Test and Compare
plt.set_cmap("tab10")
plt.cm.tab20(0)
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (12, 8)
fig, axs = plt.subplots(1, 1)
plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)
axs.cla()
axs.set_facecolor("white")
axs.spines[['top', 'right']].set_visible(False)
axs.set_ylabel('[¬£/MWh]', size=18, fontweight='bold')
axs.set_xlabel('Time [h]', size=18, fontweight='bold')
axs.plot(mean_series.index, mean_series, label='Mean w/UQ', color=plt.cm.tab10(1),
         linewidth=2.0)
axs.plot(mean_series.index, mean_marginal_price_RES_LC, label='Mean w/o UQ', color=plt.cm.tab10(4),
         linewidth=2.0)
axs.fill_between(mean_series.index, ci_low_series, ci_high_series, alpha=0.3, label='90% CI')
axs.plot(mean_series.index, ci_low_series, label='CI Low', color=plt.cm.tab10(0), linestyle='dashed',
         linewidth=2.0)
axs.plot(mean_series.index, ci_high_series, label='CI High', color=plt.cm.tab10(2), linestyle='dashed',
         linewidth=2.0)
legend = axs.legend(loc='best', ncol=1, frameon=True, fontsize='14',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
axs.tick_params(axis='x', rotation=30, labelsize=15)
axs.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in axs.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs.xaxis.grid(False)
axs.yaxis.grid(False)
#axs.set_yscale('log')
plt.gca().xaxis.set_major_formatter(plt.matplotlib.dates.DateFormatter('%b'))
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Average_Marginal_Price_Time_Series_2022_monteRESLC.png')
plt.tight_layout()
plt.show()

"""**Visualize the Hourly Average Marginal Price of Electricity (¬£/MWh) For Each Four Weather Seasons**"""

df = pd.DataFrame(dfs_marg_price2).T
df = df.fillna(0)
df2 = pd.DataFrame(mean_marginal_price_RES_LC)
season_months = {
    'Winter': '01',  # January
    'Spring': '04',  # April
    'Summer': '07',  # July
    'Fall': '10'     # October
}
def compute_mean_and_ci(row):
    mean = np.mean(row)
    se = stats.sem(row)  # Standard error of the mean
    ci_margin = se * stats.t.ppf(0.975, len(row)-1)  # 95% CI margin
    ci_low = mean - ci_margin
    ci_high = mean + ci_margin
    return pd.Series([mean, ci_low, ci_high], index=['mean', 'ci_low', 'ci_high'])
plt.set_cmap("tab10")
plt.cm.tab20(0)
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (14, 10)
fig, axes = plt.subplots(2, 2)
axes = axes.flatten()
plt.autoscale(tight=True)
# Process and plot each season
for i, (season, month) in enumerate(season_months.items()):
    # Slice the DataFrame for the specific month
    month_df = df[df.index.month == int(month)]
    mean_marginal_price_RESLC_month = df2[df2.index.month == int(month)]
    # Apply the function across rows
    results = month_df.apply(compute_mean_and_ci, axis=1)
    # Convert each column to a separate Series
    mean_series = results['mean']
    ci_low_series = results['ci_low']
    ci_high_series = results['ci_high']
    # Plotting the results
    axes[i].cla()
    axes[i].set_facecolor("white")
    axes[i].spines[['top', 'right']].set_visible(False)
    axes[i].set_ylabel('[¬£/MWh]', size=13, fontweight='bold')
    axes[i].set_xlabel('Time [h]', size=13, fontweight='bold')
    axes[i].plot(mean_series, label='Mean with UQ', color=plt.cm.tab10(1), linewidth=2.0)
    axes[i].plot(mean_marginal_price_RESLC_month, label='Mean w/o UQ',
                 color=plt.cm.tab10(4), linewidth=2.0)
    axes[i].fill_between(mean_series.index, ci_low_series, ci_high_series, color='blue', alpha=0.2, label='95% CI')
    axes[i].plot(mean_series.index, ci_low_series, label='CI Low', color=plt.cm.tab10(0),
                 linestyle='dashed', linewidth=2.0)
    axes[i].plot(mean_series.index, ci_high_series, label='CI High', color=plt.cm.tab10(2),
                 linestyle='dashed', linewidth=2.0)
    #axes[i].set_title(f'{season} (Month: {month})')
    axes[i].tick_params(axis='x', rotation=30, labelsize=15)
    axes[i].tick_params(axis='y', rotation=0, labelsize=15)
    legend = axes[i].legend(loc='best', ncol=2, frameon=True, fontsize='12',
                            fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
    legend.get_frame().set_edgecolor('black')
    legend.get_frame().set_linewidth(1)
    for spine in axes[i].spines.values():
        spine.set_linewidth(2)
        spine.set_edgecolor('black')
    axes[i].xaxis.grid(False)
    axes[i].yaxis.grid(False)
    axes[i].xaxis.set_major_formatter(plt.matplotlib.dates.DateFormatter('%b'))
fig.text(0.27, 0.50, '(a) Winter (Month: January)', ha='center', size=13, fontweight='bold')
fig.text(0.77, 0.50, '(b) Spring (Month: April)', ha='center', size=13, fontweight='bold')
fig.text(0.25, -0.03, '(c) Summer (Month: July)', ha='center', size=13, fontweight='bold')
fig.text(0.76, -0.03, '(d) Autumn (Month: October)', ha='center', size=13, fontweight='bold')
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Average_Marginal_Price_Time_Series_2022_monteRESLC.png')
plt.tight_layout()
plt.subplots_adjust(wspace=0.15, hspace=0.5)
plt.show()

"""**Print the Average Marginal Cost or Price of Electricity and the Total System Cost With 95% CI**"""

dfs_trans = []
dfs_gen_cap = []
dfs_storage = []
seed = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for s in seed:
    path = f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_RES_LC_monte/elec_s_6_ec_lcopt_Co2L-1H_m{s}.nc"
    n = pypsa.Network(path)
    selected_categories = ['AC', 'B2B', 'DC', 'H2 electrolysis',
                           'H2 fuel cell', 'H2 pipeline', 'battery charger',
                           'battery discharger']
    df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
    df_ = (df.groupby(level=1).sum()).fillna(0)
    dfs_trans.append(df_)
    selected_categories = ['Biomass', 'Coal', 'Combined-Cycle Gas', 'Nuclear',
                           'Offshore Wind (AC)', 'Offshore Wind (DC)', 'Oil',
                           'Onshore Wind', 'Run of River', 'Solar']
    df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
    df_ = (df.groupby(level=1).sum()).fillna(0)
    dfs_gen_cap.append(df_)
    selected_categories = ['StorageUnit']
    df = n.statistics().loc[n.statistics().index.get_level_values(0).isin(selected_categories)]
    df_ = (df.groupby(level=0).sum()).fillna(0)
    dfs_storage.append(df_)

concatenated_dfs_trans = pd.concat(dfs_trans, axis=1)
concatenated_dfs_gen_cap = pd.concat(dfs_gen_cap, axis=1)
concatenated_dfs_storage = pd.concat(dfs_storage, axis=1)

df = concatenated_dfs_trans
rows_to_sum = ['B2B', 'DC', 'H2 electrolysis', 'H2 fuel cell', 'H2 pipeline',
               'battery charger', 'battery discharger']
sum_row = df.loc[rows_to_sum].sum()
df.loc['Link'] = sum_row
df = df.fillna(0)
opt_cap_link = df[['Optimal Capacity']].loc['Link'].to_list()
inst_cap_link = df[['Installed Capacity']].loc['Link'].to_list()
new_exp_link = [a - b for a, b in zip(opt_cap_link, inst_cap_link)]

opt_cap_line = concatenated_dfs_trans[['Optimal Capacity']].loc['AC'].to_list()
inst_cap_line = concatenated_dfs_trans[['Installed Capacity']].loc['AC'].to_list()
new_exp_line = [a - b for a, b in zip(opt_cap_line, inst_cap_line)]

df = concatenated_dfs_gen_cap
rows_to_sum = ['Biomass', 'Nuclear', 'Offshore Wind (AC)',
               'Offshore Wind (DC)', 'Onshore Wind', 'Run of River', 'Solar']
sum_row = df.loc[rows_to_sum].sum()
df.loc['Gen'] = sum_row
df = df.fillna(0)
opt_cap_gen_cap = df[['Optimal Capacity']].loc['Gen'].to_list()
inst_cap_gen_cap = df[['Installed Capacity']].loc['Gen'].to_list()
new_exp_gen_cap = [a - b for a, b in zip(opt_cap_gen_cap, inst_cap_gen_cap)]
opt_gen_sup = df[['Supply']].loc['Gen'].to_list()

opt_sto = concatenated_dfs_storage[['Optimal Capacity']].loc['StorageUnit'].to_list()
inst_sto = concatenated_dfs_storage[['Installed Capacity']].loc['StorageUnit'].to_list()
new_exp_sto = [a - b for a, b in zip(opt_sto, inst_sto)]

df = pd.DataFrame(dfs_marg_price2).T
df = df.fillna(0)
# Function to compute mean and 95% CI across rows
def compute_mean_and_ci(row):
    mean = np.mean(row)
    se = stats.sem(row)  # Standard error of the mean
    ci_margin = se * stats.t.ppf(0.975, len(row)-1)  # 95% CI margin
    ci_low = mean - ci_margin
    ci_high = mean + ci_margin
    return pd.Series([mean, ci_low, ci_high], index=['mean', 'ci_low', 'ci_high'])
# Apply the function across rows
results = df.apply(compute_mean_and_ci, axis=1)
# Average marginal price of electricity
mean_series = results['mean'].mean()
ci_low_series = results['ci_low'].mean()
ci_high_series = results['ci_high'].mean()
df2 = mean_marginal_price_RES_LC.mean()
print('================================================================================')
print(f'Average Marginal Price of Electricity With UQ in ¬£/MWh: {mean_series:.2f}')
print(f'Average Marginal Price of Electricity With UQ (Low) in ¬£/MWh: {ci_low_series:.2f}')
print(f'Average Marginal Price of Electricity With UQ (High) in ¬£/MWh: {ci_high_series:.2f}')
print(f'Average Marginal Price of Electricity Without UQ in ¬£/MWh: {df2:.2f}')
print('================================================================================')
# Total System Cost
data = dfs_tot_sys_cost
data_clean = [x for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
df2 = tot_annual_sys_cost_2025_RES_LC
print('================================================================================')
print(f'Total System Cost With UQ in Billion ¬£/year: {mean:.2f}')
print(f'Total System Cost With UQ (Low) in Billion ¬£/year: {ci_low:.2f}')
print(f'Total System Cost With UQ (High) in Billion ¬£/year: {ci_high:.2f}')
print(f'Total System Cost Without UQ in Billion ¬£/year: {df2:.2f}')
print('================================================================================')

# New Link
data = new_exp_link
data_clean = [x if x >= 0 else 0 for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
print('================================================================================')
print(f'New Transmission Link With UQ in MWKm: {mean:.2f}')
print(f'New Transmission Link  With UQ (Low) in MWKm: {ci_low:.2f}')
print(f'New Transmission Link  With UQ (High) in MWKm: {ci_high:.2f}')
print('================================================================================')

# New Line
data = new_exp_line
data_clean = [x if x >= 0 else 0 for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
print('================================================================================')
print(f'New Transmission Line With UQ in MWKm: {mean:.2f}')
print(f'New Transmission Line  With UQ (Low) in MWKm: {ci_low:.2f}')
print(f'New Transmission Line  With UQ (High) in MWKm: {ci_high:.2f}')
print('================================================================================')

# New Installed Capacity of Generators
data = new_exp_gen_cap
data_clean = [x if x >= 0 else 0 for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
print('================================================================================')
print(f'New Generator Installed Capacity With UQ in MW: {mean:.2f}')
print(f'New Generator Installed Capacity With UQ (Low) in MW: {ci_low:.2f}')
print(f'New Generator Installed Capacity With UQ (High) in MW: {ci_high:.2f}')
print('================================================================================')

# New Generation Supply
data = opt_gen_sup
data_clean = [x if x >= 0 else 0 for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
print('================================================================================')
print(f'New Generation Supply With UQ in MW: {mean:.2f}')
print(f'New Generation Supply With UQ (Low) in MW: {ci_low:.2f}')
print(f'New Generation Supply With UQ (High) in MW: {ci_high:.2f}')
print('================================================================================')

# New Storage Capacity
data = new_exp_sto
data_clean = [x if x >= 0 else 0 for x in data if not np.isnan(x)]
mean = np.mean(data_clean)
# Calculate 95% confidence interval
ci = stats.t.interval(0.95, len(data_clean)-1, loc=np.mean(data_clean), scale=stats.sem(data_clean))
# Extract the lower and upper bounds of the confidence interval
ci_low = ci[0]
ci_high = ci[1]
print('================================================================================')
print(f'New Storage Capacity With UQ in MW: {mean:.2f}')
print(f'New Storage Capacity With UQ (Low) in MW: {ci_low:.2f}')
print(f'New Storage Capacity With UQ (High) in MW: {ci_high:.2f}')
print('================================================================================')

"""###**Obtain the Total System Cost Distribution**"""

seed = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
dfs_tot_sys_cost = []
dfs_tot_sys_cost_RES_LC = []
dfs_all_sys_cost = []
dfs_all_sys_cost_RES_LC = []
for s in seed:
    path = f"/content/gdrive/MyDrive/Energy_System_Modelling_GB/esm_GB_2025_RES_LC_monte/elec_s_6_ec_lcopt_Co2L-1H_m{s}.nc"
    try:
        n = pypsa.Network(path)
        # Total System Cost
        df = (n.objective *0.84)
        dfs_tot_sys_cost.append(df)
        dfs_tot_sys_cost_RES_LC.append(df)
        total_load = n.loads_t.p.sum().sum()
        selected_categories = ['Biomass', 'Coal', 'Combined-Cycle Gas', 'Nuclear',
                               'Offshore Wind (AC)', 'Offshore Wind (DC)', 'Oil', 'Onshore Wind',
                               'Run of River', 'Solar', 'AC', 'B2B', 'DC', 'H2 electrolysis',
                               'H2 fuel cell', 'H2 pipeline', 'battery charger', 'battery discharger',
                               'Battery Storage', 'Hydrogen Storage', 'Battery Storage',
                               'Hydrogen Storage']
        df = n.statistics().loc[n.statistics().index.get_level_values(1).isin(selected_categories)]
        df['Avg_Sys_Cost'] = ((df['Capital Expenditure'] + df['Operational Expenditure']) / total_load)*0.84
        df['Tot_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure'])*0.84
        df_ = (df.groupby(level=1).sum()).fillna(0)
        rows_to_sum = ['AC', 'B2B', 'DC', 'H2 electrolysis', 'H2 fuel cell', 'H2 pipeline',
                       'battery charger', 'battery discharger']
        try:
            sum_row = df_.loc[rows_to_sum].sum()
            df_.loc['Transmission'] = sum_row
            df_ = df_.fillna(0)
        except KeyError as e:
            print(f"KeyError for seed {s}: {e}")
        dfs_all_sys_cost.append(df_)
        dfs_all_sys_cost_RES_LC.append(df_)
    except Exception as e:
        print(f"Error processing seed {s}: {e}")
if dfs_all_sys_cost:
    concatenated_dfs_all_sys_cost = pd.concat(dfs_all_sys_cost, axis=1)
if dfs_all_sys_cost_RES_LC:
    concatenated_dfs_all_sys_cost_RES_LC = pd.concat(dfs_all_sys_cost_RES_LC, axis=1)

#data = [d for d in dfs_tot_sys_cost if not np.isnan(d)]
df_TSC = pd.DataFrame({'Values': dfs_tot_sys_cost})
tot_sys_cost_monte_RES_LC = dfs_tot_sys_cost
data_TSC = np.array(dfs_tot_sys_cost)
Q5_TSC = np.percentile(data_TSC, 5)
Q25_TSC = np.percentile(data_TSC, 25)
Q50_TSC = np.median(data_TSC)
Q75_TSC = np.percentile(data_TSC, 75)
Q95_TSC = np.percentile(data_TSC, 95)

selected_categories = ['Battery Storage', 'Biomass', 'Hydrogen Storage', 'Nuclear',
                       'Offshore Wind (AC)', 'Offshore Wind (DC)', 'Onshore Wind',
                       'Run of River', 'Solar', 'Transmission']
selected_df = concatenated_dfs_all_sys_cost.loc[selected_categories]
battery_storage_cap = selected_df[['Optimal Capacity']].loc['Battery Storage'].to_list()
#data = [d for d in battery_storage_cap if not np.isnan(d)]
df_battery = pd.DataFrame({'Values': battery_storage_cap})
data_battery = np.array(battery_storage_cap)
Q5_battery = np.percentile(data_battery, 5)
Q25_battery = np.percentile(data_battery, 25)
Q50_battery = np.median(data_battery)
Q75_battery = np.percentile(data_battery, 75)
Q95_battery = np.percentile(data_battery, 95)

h2_storage_cap = selected_df[['Optimal Capacity']].loc['Hydrogen Storage'].to_list()
#data = [d for d in h2_storage_cap if not np.isnan(d)]
df_h2 = pd.DataFrame({'Values': h2_storage_cap})
data_h2 = np.array(h2_storage_cap)
Q5_h2 = np.percentile(data_h2, 5)
Q25_h2 = np.percentile(data_h2, 25)
Q50_h2 = np.median(data_h2)
Q75_h2 = np.percentile(data_h2, 75)
Q95_h2 = np.percentile(data_h2, 95)

onwind_cap = selected_df[['Optimal Capacity']].loc['Onshore Wind'].to_list()
#data = [d for d in onwind_cap if not np.isnan(d)]
df_onwind = pd.DataFrame({'Values': onwind_cap})
data_onwind = np.array(onwind_cap)
Q5_onwind = np.percentile(data_onwind, 5)
Q25_onwind = np.percentile(data_onwind, 25)
Q50_onwind = np.median(data_onwind)
Q75_onwind = np.percentile(data_onwind, 75)
Q95_onwind = np.percentile(data_onwind, 95)

offwindac_cap = selected_df[['Optimal Capacity']].loc['Offshore Wind (AC)'].to_list()
#data = [d for d in offwindac_cap if not np.isnan(d)]
df_offwindac = pd.DataFrame({'Values': offwindac_cap})
data_offwindac = np.array(offwindac_cap)
Q5_offwindac = np.percentile(data_offwindac, 5)
Q25_offwindac = np.percentile(data_offwindac, 25)
Q50_offwindac = np.median(data_offwindac)
Q75_offwindac = np.percentile(data_offwindac, 75)
Q95_offwindac = np.percentile(data_offwindac, 95)

offwinddc_cap = selected_df[['Optimal Capacity']].loc['Offshore Wind (DC)'].to_list()
#data = [d for d in offwinddc_cap if not np.isnan(d)]
df_offwinddc = pd.DataFrame({'Values': offwinddc_cap})
data_offwinddc = np.array(offwinddc_cap)
Q5_offwinddc = np.percentile(data_offwinddc, 5)
Q25_offwinddc = np.percentile(data_offwinddc, 25)
Q50_offwinddc = np.median(data_offwinddc)
Q75_offwinddc = np.percentile(data_offwinddc, 75)
Q95_offwinddc = np.percentile(data_offwinddc, 95)

solar_cap = selected_df[['Optimal Capacity']].loc['Solar'].to_list()
#data = [d for d in solar_cap if not np.isnan(d)]
df_solar = pd.DataFrame({'Values': solar_cap})
data_solar = np.array(solar_cap)
Q5_solar = np.percentile(data_solar, 5)
Q25_solar = np.percentile(data_solar, 25)
Q50_solar = np.median(data_solar)
Q75_solar = np.percentile(data_solar, 75)
Q95_solar = np.percentile(data_solar, 95)

ror_cap = selected_df[['Optimal Capacity']].loc['Run of River'].to_list()
data = [d for d in ror_cap if not np.isnan(d)]
df_ror = pd.DataFrame({'Values': data})
data_ror = np.array(data)
Q5_ror = np.percentile(data_ror, 5)
Q25_ror = np.percentile(data_ror, 25)
Q50_ror = np.median(data_ror)
Q75_ror = np.percentile(data_ror, 75)
Q95_ror = np.percentile(data_ror, 95)

transmission_cap = selected_df[['Optimal Capacity']].loc['Transmission'].to_list()
data = [d for d in transmission_cap if not np.isnan(d)]
df_transmission = pd.DataFrame({'Values': data})
data_transmission = np.array(data)
Q5_transmission = np.percentile(data_transmission, 5)
Q25_transmission = np.percentile(data_transmission, 25)
Q50_transmission = np.median(data_transmission)
Q75_transmission = np.percentile(data_transmission, 75)
Q95_transmission = np.percentile(data_transmission, 95)

import matplotlib.gridspec as gridspec
df_gen = pd.DataFrame({
    'Values': (df_solar.values/1000).flatten().tolist() + \
    (df_onwind.values/1000).flatten().tolist() + \
    (df_offwindac.values/1000).flatten().tolist() + \
    (df_offwinddc.values/1000).flatten().tolist() + \
    (df_ror.values/1000).flatten().tolist(),
    'Group': ['solar'] * len(df_solar) + ['onwind'] * len(df_onwind) + \
    ['offwindac'] * len(df_offwindac) + ['offwinddc'] * len(df_offwinddc) + \
    ['ror'] * len(df_ror)
})
df_sto = pd.DataFrame({
    'Values': df_battery.values.flatten().tolist() + df_h2.values.flatten().tolist(),
    'Group': ['battery'] * len(df_battery) + ['hydrogen'] * len(df_h2)
})
df_trans = pd.DataFrame({
    'Values': (df_transmission.values/1000).flatten().tolist(),
    'Group': ['transmission'] * len(df_transmission)
})
df_sys_cost = pd.DataFrame({
    'Values': df_TSC.values.flatten().tolist(),
    'Group': ['system cost'] * len(df_TSC)
})
palette = {'solar': 'gold', 'onwind': 'steelblue', 'offwindac': 'skyblue',
           'offwinddc': 'deepskyblue', 'ror': 'ivory'}
palette1 = {'battery': 'crimson', 'hydrogen': 'olive'}
palette2 = {'transmission': 'red'}
palette3 = {'system cost': 'orange'}

sns.set_theme(style='whitegrid')
#fig, (ax1, ax2, ax3, ax4) = plt.subplots(1, 4, figsize=(15, 10))
fig = plt.figure(figsize=(15, 10))
gs = gridspec.GridSpec(1, 4, width_ratios=[4, 2, 1, 1])
ax1 = fig.add_subplot(gs[0])
ax2 = fig.add_subplot(gs[1])
ax3 = fig.add_subplot(gs[2])
ax4 = fig.add_subplot(gs[3])
plt.subplots_adjust(wspace=0.4, hspace=0.1)
plt.autoscale(tight=True)
ax1.cla()
ax1.set_facecolor("white")
ax1.spines[['top', 'right']].set_visible(False)
sns.violinplot(ax=ax1, x='Group', y='Values', data=df_gen, palette=palette)
fig.text(0.27, -0.05, '(a) Generation Capacities', ha='center',
            size=14, fontweight='bold')
ax1.set_ylabel('[GW]', size=12, fontweight='bold')
ax1.set_xlabel('', size=12, fontweight='bold')
ax1.tick_params(axis='x', rotation=30, labelsize=15)
ax1.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in ax1.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax1.xaxis.grid(False)
ax1.yaxis.grid(False)

ax2.cla()
ax2.set_facecolor("white")
ax2.spines[['top', 'right']].set_visible(False)
sns.violinplot(ax=ax2, x='Group', y='Values', data=df_sto, palette=palette1)
fig.text(0.56, -0.05, '(b) Energy Storage Systems', ha='center',
            size=13, fontweight='bold')
ax2.set_ylabel('[MW]', size=12, fontweight='bold')
ax2.set_xlabel('', size=12, fontweight='bold')
ax2.tick_params(axis='x', rotation=30, labelsize=15)
ax2.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in ax2.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax2.xaxis.grid(False)
ax2.yaxis.grid(False)

ax3.cla()
ax3.set_facecolor("white")
ax3.spines[['top', 'right']].set_visible(False)
sns.violinplot(ax=ax3, x='Group', y='Values', data=df_trans, palette=palette2)
fig.text(0.73, -0.05, '(c) Transmission', ha='center',
            size=13, fontweight='bold')
ax3.set_ylabel('[GWKm]', size=12, fontweight='bold')
ax3.set_xlabel('', size=12, fontweight='bold')
ax3.tick_params(axis='x', rotation=30, labelsize=15)
ax3.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in ax3.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax3.xaxis.grid(False)
ax3.yaxis.grid(False)

ax4.cla()
ax4.set_facecolor("white")
ax4.spines[['top', 'right']].set_visible(False)
sns.violinplot(ax=ax4, x='Group', y='Values', data=df_sys_cost, palette=palette3)
fig.text(0.885, -0.05, '(d) Total System Cost', ha='center',
            size=13, fontweight='bold')
ax4.set_ylabel('[Billion ¬£ Per annum]', size=12, fontweight='bold')
ax4.set_xlabel('', size=12, fontweight='bold')
ax4.tick_params(axis='x', rotation=30, labelsize=15)
ax4.tick_params(axis='y', rotation=0, labelsize=15)
#axs[1] = plt.gca()
for spine in ax4.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax4.xaxis.grid(False)
ax4.yaxis.grid(False)
#plt.axis("off")
plt.savefig("cost_capacity_distribution.png", dpi=500, bbox_inches="tight")

"""###**Average System Cost Variation For Technological Units**"""

mc1 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 0].fillna(0) #.stack()
mc2 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 1].fillna(0)
mc3 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 2].fillna(0)
mc4 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 3].fillna(0)
mc5 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 4].fillna(0)
mc6 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 5].fillna(0)
mc7 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 6].fillna(0)
mc8 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 7].fillna(0)
mc9 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 8].fillna(0)
mc10 = concatenated_df_stat_avg_tot_cost[['Avg_Sys_Cost']].iloc[:, 9].fillna(0)

## Add average system cost bar plot
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (12, 12)
fig, ax = plt.subplots(1, 1)
plt.subplots_adjust(wspace=0.01, hspace=0.01)
plt.autoscale(tight=True)
ax.cla()
ax.set_facecolor("white")
ax.spines[['top', 'right']].set_visible(False)
ax.set_xlabel('Technology', size=15, fontweight='bold')
ax.set_ylabel('Average System Cost [¬£/MWh]', size=15, fontweight='bold')
bar_width = 0.065
num_bars = 10
r = np.arange(len(mc1))
ax.bar(r, mc1, width=bar_width, color='gold', edgecolor='grey', label='MC 1')
ax.bar(r + bar_width, mc2, width=bar_width, color='gold', edgecolor='grey', label='MC 2')
ax.bar(r + 2.5*bar_width, mc3, width=bar_width, color='gold', edgecolor='grey', label='MC 3')
ax.bar(r + 3.5*bar_width, mc4, width=bar_width, color='gold', edgecolor='grey', label='MC 4')
ax.bar(r + 4.5*bar_width, mc5, width=bar_width, color='gold', edgecolor='grey', label='MC 5')
ax.bar(r + 5.5*bar_width, mc6, width=bar_width, color='gold', edgecolor='grey', label='MC 6')
ax.bar(r + 6.5*bar_width, mc7, width=bar_width, color='gold', edgecolor='grey', label='MC 7')
ax.bar(r + 7.5*bar_width, mc8, width=bar_width, color='gold', edgecolor='grey', label='MC 8')
ax.bar(r + 8.5*bar_width, mc9, width=bar_width, color='gold', edgecolor='grey', label='MC 9')
ax.bar(r + 9.5*bar_width, mc10, width=bar_width, color='gold', edgecolor='grey', label='MC 10')
ax.bar(r + 11.5*bar_width, df_avg_sys_cost_RES_LC['Avg_Sys_Cost'], width=bar_width,
        color='#CC4E5C', edgecolor='grey', label='W/O UQ')
ax.set_xticks(r + 5*bar_width)  # Center y-ticks between bars
ax.set_xticklabels(mc1.index)
legend = ax.legend(loc='best', ncol=4, frameon=True, fontsize='10',
        fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
ax.tick_params(axis='x', rotation=90, labelsize=12)
ax.tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in ax.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax.xaxis.grid(False)
ax.yaxis.grid(False)
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Average_System_Cost_Dispatch_Units_2022_monte_RES_LC.png')
plt.tight_layout()
plt.show()

"""###**Variability of the Optimal Renewable Generators and Storage Units Capacity Configurations**"""

concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0)
solar = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Solar'].tolist()
mean_value = sum(solar) / len(solar)
solar.append(mean_value)
onwind = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Onshore Wind'].tolist()
mean_value = sum(onwind) / len(onwind)
onwind.append(mean_value)
offwindac = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Offshore Wind (AC)'].tolist()
mean_value = sum(offwindac) / len(offwindac)
offwindac.append(mean_value)
offwinddc = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Offshore Wind (DC)'].tolist()
mean_value = sum(offwinddc) / len(offwinddc)
offwinddc.append(mean_value)
battery = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Battery Storage'].tolist()
mean_value = sum(battery) / len(battery)
battery.append(mean_value)
h2 = concatenated_df_stat_avg_tot_cost[['Optimal Capacity']].fillna(0).loc['Hydrogen Storage'].tolist()
mean_value = sum(h2) / len(h2)
h2.append(mean_value)

selected_categories = ['Battery Storage', 'Biomass', 'Coal', 'Combined-Cycle Gas',
                       'Hydrogen Storage', 'Nuclear', 'Offshore Wind (AC)',
                       'Offshore Wind (DC)', 'Oil', 'Onshore Wind', 'Run of River',
                       'Solar']
df = stat_RES_LC.loc[stat_RES_LC.index.get_level_values(1).isin(selected_categories)]
df['Avg_Sys_Cost'] = ((df['Capital Expenditure'] + df['Operational Expenditure']) / total_load)*0.84
df['Tot_Sys_Cost'] = (df['Capital Expenditure'] + df['Operational Expenditure'])*0.84
df['Gen_Elec'] = df['Supply'] / (1 + 0.07)
df['LCOE'] = (df['Tot_Sys_Cost'] / (1 + 0.07)) / df['Gen_Elec']
df_ = (df.groupby(level=1).sum()).fillna(0)
solar_ = df_[['Optimal Capacity']].fillna(0).loc['Solar'].tolist()
df_solar = solar_ + solar
onwind_ = df_[['Optimal Capacity']].fillna(0).loc['Onshore Wind'].tolist()
df_onwind = onwind_ + onwind
offwindac_ = df_[['Optimal Capacity']].fillna(0).loc['Offshore Wind (AC)'].tolist()
df_offwindac = offwindac_ + offwindac
offwinddc_ = df_[['Optimal Capacity']].fillna(0).loc['Offshore Wind (DC)'].tolist()
df_offwinddc = offwinddc_ + offwinddc
battery_ = df_[['Optimal Capacity']].fillna(0).loc['Battery Storage'].tolist()
df_battery = battery_ + battery
h2_ = df_[['Optimal Capacity']].fillna(0).loc['Hydrogen Storage'].tolist()
df_h2 = h2_ + h2

scenarios = ['W/O MC', 'MC 1', 'MC 2', 'MC 3', 'MC 4', 'MC 5', 'MC 6', 'MC 7',
             'MC 8', 'MC 9', 'MC 10', 'Mean MC']
colors = ['brown', 'teal', 'red', 'peru', 'darkolivegreen', 'violet', 'slategrey',
          'gold', 'navy', 'crimson', 'green', 'skyblue', 'black']

import matplotlib.patches as mpatches
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (16, 12)
fig, axs = plt.subplots(3, 2)
#plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.autoscale(tight=True)

axs[0, 0].cla()
axs[0, 0].set_facecolor("white")
axs[0, 0].spines[['top', 'right']].set_visible(False)
axs[0, 0].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[0, 0].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_solar))
bars = axs[0, 0].barh(positions, df_solar, height=bar_width, color=colors, edgecolor='grey')
axs[0, 0].set_yticks(positions)
axs[0, 0].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend1 = axs[0, 0].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)
#axs[0, 0].tick_params(axis='x', rotation=0, labelsize=12)
axs[0, 0].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[0, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0, 0].xaxis.grid(False)
axs[0, 0].yaxis.grid(False)
fig.text(0.27, 0.66, '(a) Solar', ha='center', size=19, fontweight='bold')

axs[0, 1].cla()
axs[0, 1].set_facecolor("white")
axs[0, 1].spines[['top', 'right']].set_visible(False)
#axs[0, 1].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[0, 1].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_onwind))
bars = axs[0, 1].barh(positions, df_onwind, height=bar_width, color=colors, edgecolor='grey')
axs[0, 1].set_yticks(positions)
axs[0, 1].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend2 = axs[0, 1].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)
#axs[0, 1].tick_params(axis='x', rotation=0, labelsize=12)
axs[0, 1].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[0, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0, 1].xaxis.grid(False)
axs[0, 1].yaxis.grid(False)
fig.text(0.77, 0.66, '(b) Onshore Wind', ha='center', size=19, fontweight='bold')

axs[1, 0].cla()
axs[1, 0].set_facecolor("white")
axs[1, 0].spines[['top', 'right']].set_visible(False)
axs[1, 0].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[1, 0].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_offwindac))
bars = axs[1, 0].barh(positions, df_offwindac, height=bar_width, color=colors, edgecolor='grey')
axs[1, 0].set_yticks(positions)
axs[1, 0].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend3 = axs[1, 0].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend3.get_frame().set_edgecolor('black')
legend3.get_frame().set_linewidth(1)
#axs[1, 0].tick_params(axis='x', rotation=0, labelsize=12)
axs[1, 0].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[1, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1, 0].xaxis.grid(False)
axs[1, 0].yaxis.grid(False)
fig.text(0.27, 0.33, '(c) Offshore Wind (AC)', ha='center', size=19, fontweight='bold')

axs[1, 1].cla()
axs[1, 1].set_facecolor("white")
axs[1, 1].spines[['top', 'right']].set_visible(False)
#axs[1, 1].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[1, 1].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_offwinddc))
bars = axs[1, 1].barh(positions, df_offwinddc, height=bar_width, color=colors, edgecolor='grey')
axs[1, 1].set_yticks(positions)
axs[1, 1].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend4 = axs[1, 1].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend4.get_frame().set_edgecolor('black')
legend4.get_frame().set_linewidth(1)
#axs[1, 1].tick_params(axis='x', rotation=0, labelsize=12)
axs[1, 1].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[1, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1, 1].xaxis.grid(False)
axs[1, 1].yaxis.grid(False)
fig.text(0.77, 0.33, '(d) Offshore Wind (DC)', ha='center', size=19, fontweight='bold')

axs[2, 0].cla()
axs[2, 0].set_facecolor("white")
axs[2, 0].spines[['top', 'right']].set_visible(False)
axs[2, 0].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[2, 0].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_battery))
bars = axs[2, 0].barh(positions, df_battery, height=bar_width, color=colors, edgecolor='grey')
axs[2, 0].set_yticks(positions)
axs[2, 0].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend5 = axs[2, 0].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend5.get_frame().set_edgecolor('black')
legend5.get_frame().set_linewidth(1)
#axs[2, 0].tick_params(axis='x', rotation=0, labelsize=12)
axs[2, 0].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[2, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[2, 0].xaxis.grid(False)
axs[2, 0].yaxis.grid(False)
fig.text(0.27, -0.01, '(e) Battery Storage', ha='center', size=19, fontweight='bold')

axs[2, 1].cla()
axs[2, 1].set_facecolor("white")
axs[2, 1].spines[['top', 'right']].set_visible(False)
#axs[2, 1].set_ylabel('Scenarios', size=15, fontweight='bold')
#axs[2, 1].set_xlabel('Power [MW]', size=20, fontweight='bold')
bar_width = 0.1
positions = [0.1, 0.23, 0.33, 0.43, 0.53, 0.63, 0.73, 0.83, 0.93, 1.03, 1.13, 1.3]
r1 = np.arange(len(df_h2))
bars = axs[2, 1].barh(positions, df_h2, height=bar_width, color=colors, edgecolor='grey')
axs[2, 1].set_yticks(positions)
axs[2, 1].set_yticklabels(scenarios, rotation=0)
handles = [mpatches.Rectangle((0, 0), 1, 1, color=color) for color in colors]
legend6 = axs[2, 1].legend(handles, scenarios, loc='best', ncol=4, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend6.get_frame().set_edgecolor('black')
legend6.get_frame().set_linewidth(1)
#axs[2, 1].tick_params(axis='x', rotation=0, labelsize=12)
axs[2, 1].tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in axs[2, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[2, 1].xaxis.grid(False)
axs[2, 1].yaxis.grid(False)
fig.text(0.77, -0.01, '(f) Hydrogen Storage', ha='center', size=19, fontweight='bold')

output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Optimal_RES_Storage_Config_Variability_Scenarios.png')
plt.tight_layout()
plt.subplots_adjust(wspace=0.2, hspace=0.3)
plt.show()

"""###**Charactering the Uncertainties of Renewable Generators, Storage Units, and Transmission Optimal Capacities With Respect to the Total System Cost**

###**Sensitivity Analysis Using Tornado Diagrams and Spider**
"""

selected_categories = ['Battery Storage', 'Hydrogen Storage', 'Offshore Wind (AC)',
                       'Offshore Wind (DC)', 'Onshore Wind', 'Run of River',
                       'Solar', 'Transmission']
selected_df = concatenated_dfs_all_sys_cost_RES_LC.loc[selected_categories]
df = selected_df[['Optimal Capacity']].T
df['Total System Cost'] = dfs_tot_sys_cost_RES_LC
df.index = pd.Index(range(1, len(df) + 1))
df = df.fillna(0)
# Fit a linear regression model
X = df.drop(['Total System Cost'], axis=1)
y = df['Total System Cost']
reg = LinearRegression()
reg.fit(X, y)
# Base case prediction
base_prediction = reg.predict(X).mean()
variation_range = 95 # 95 % CI  # percentage variation from the mean # 95 % CI
# Calculate the impact of varying each input parameter
sensitivities = {}
low_impacts = []
high_impacts = []
features = X.columns
for feature in features:
    mean_value = X[feature].mean()
    variation = mean_value * variation_range / 100
    X_high = X.copy()
    X_high[feature] = mean_value + variation
    high_prediction = reg.predict(X_high).mean()
    X_low = X.copy()
    X_low[feature] = mean_value - variation
    low_prediction = reg.predict(X_low).mean()
    sensitivities[feature] = (high_prediction - low_prediction) / 2
    low_impacts.append(low_prediction)
    high_impacts.append(high_prediction)

# Plot the tornado diagrams
sns.set_theme(style='whitegrid')
fig, axs = plt.subplots(3, 1, figsize=(8, 12))
plt.subplots_adjust(wspace=0.1, hspace=0.45)
plt.autoscale(tight=True)
axs[0].cla()
axs[0].set_facecolor("white")
axs[0].spines[['top', 'right']].set_visible(False)
features = list(sensitivities.keys())
impacts = [sensitivities[feature] for feature in features]
bars = axs[0].barh(features, impacts, color='gold', edgecolor='black')
axs[0].set_xlabel('Impact on Total System Cost [¬£ Per Annum]', size=8, fontweight='bold')
axs[0].set_ylabel('Technologies', size=10, fontweight='bold')
axs[0].tick_params(axis='y', rotation=0, labelsize=8)
axs[0].tick_params(axis='x', rotation=30, labelsize=10)
# Calculate total width for normalization
total_width = sum(abs(bar.get_width()) for bar in bars)
# Add data labels for the sensitivity plot with percentages
for bar in bars:
    width = bar.get_width()
    percentage = (abs(width) / total_width) * 100
    axs[0].annotate(f'{percentage:.1f}%',
                    xy=(width, bar.get_y() + bar.get_height() / 2),
                    xytext=(9, 0),  # 5 points horizontal offset
                    textcoords="offset points",
                    ha='right', va='center', rotation=90,
                    fontsize=7,  # Adjust font size if needed
                    color='black',  # Text color
                    bbox=dict(boxstyle='round,pad=0.3', fc='white', ec='black', lw=1))
plt.figtext(0.4, 0.66, '(a) Sensitivity analysis tornado plot', fontsize=10,
            rotation=0, weight="bold")
for spine in axs[0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0].xaxis.grid(False)
axs[0].yaxis.grid(False)

axs[1].cla()
axs[1].set_facecolor("white")
axs[1].spines[['top', 'right']].set_visible(False)
axs[1].axvline(base_prediction, color='navy', linestyle='--', label='Base Prediction',
               linewidth=2.5)
# Plot the low impacts
axs[1].barh(features, base_prediction - np.array(low_impacts), left=low_impacts,
            color='#CC4E5C', edgecolor='black', label='Low Prediction')
# Plot the high impacts
axs[1].barh(features, high_impacts - base_prediction, left=base_prediction,
            color='teal', edgecolor='black', label='High Prediction')
axs[1].set_xlabel('Total System Cost [¬£ Per Annum]', size=8, fontweight='bold')
axs[1].set_ylabel('Technologies', size=10, fontweight='bold')
axs[1].tick_params(axis='y', rotation=0, labelsize=8)
axs[1].tick_params(axis='x', rotation=30, labelsize=10)
plt.figtext(0.4, 0.32, '(b) Low and high prediction tornado plot', fontsize=10,
            rotation=0, weight="bold")
legend = axs[1].legend(loc='best', ncol=1, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
for spine in axs[1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1].xaxis.grid(False)
axs[1].yaxis.grid(False)

selected_categories = ['Battery Storage', 'Hydrogen Storage', 'Offshore Wind (AC)',
                       'Offshore Wind (DC)', 'Onshore Wind', 'Run of River',
                       'Solar', 'Transmission']
selected_df = concatenated_dfs_all_sys_cost_RES_LC.loc[selected_categories]
df = selected_df[['Optimal Capacity']].T
df['Total System Cost'] = dfs_tot_sys_cost_RES_LC
df.index = pd.Index(range(1, len(df) + 1))
df = df.fillna(0)
# Fit a linear regression model
X = df.drop(['Total System Cost'], axis=1)
y = df['Total System Cost']
reg = LinearRegression()
reg.fit(X, y)
variation_range = np.linspace(-0.95, 0.95, 20)  # ¬±95% variation
# Initialize lists to store results
results = {}
# Calculate the impact of varying each input parameter
base_prediction = reg.predict(X.mean().values.reshape(1, -1))[0]
for feature in X.columns:
    feature_mean = X[feature].mean()
    feature_values = feature_mean * (1 + variation_range)
    other_features = X.drop(columns=[feature]).mean().values.reshape(1, -1)
    output_changes = []
    for value in feature_values:
        X_temp = other_features.copy()
        X_temp = np.insert(X_temp, list(X.columns).index(feature), value, axis=1)
        output_changes.append(reg.predict(X_temp)[0] - base_prediction)
    results[feature] = output_changes
# Plot the results
markers = ['o', 's', 'D', '^', 'v', '*', 'p', 'h', 'H', 'X', 'd', '|', '_']
colors = cm.get_cmap('tab10', X.shape[0]).colors  # Use a colormap to generate colors
axs[2].cla()
axs[2].set_facecolor("white")
axs[2].spines[['top', 'right']].set_visible(False)
for i, (feature, output_changes) in enumerate(results.items()):
    axs[2].plot(variation_range * 100, output_changes, label=feature,
            marker=markers[i % len(markers)], color=colors[i % len(colors)])
axs[2].set_xlabel('Variation in Input Parameter (%)', size=8, fontweight='bold')
axs[2].set_ylabel('Change in Output [¬£]', size=10, fontweight='bold')
axs[2].set_xticks(np.arange(-95, 100, 10))  # Set x-ticks from -95% to 95% in steps of 10%
axs[2].set_xticklabels([f'{int(x)}' for x in np.arange(-95, 100, 10)])  # Convert x-ticks to percentage format
axs[2].tick_params(axis='y', rotation=0, labelsize=8)
axs[2].tick_params(axis='x', rotation=30, labelsize=10)
plt.figtext(0.4, -0.02, '(c) Sensitivity Analysis Spider Plot', fontsize=10,
            rotation=0, weight="bold")
for spine in axs[2].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[2].xaxis.grid(True)
axs[2].yaxis.grid(True)
legend = axs[2].legend(loc='best', ncol=1, frameon=True, fontsize='8',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)

output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/tornado_Spider_plots_scenario_3.png')
plt.tight_layout()
plt.show()

"""**Print the Table of Change in Output variable**"""

columns = list(results.keys())
# Create the table header
header = f"{'Change (%)':>10} " + " ".join(f"{col:>20}" for col in columns)
# Create the rows
rows = []
for i, change in enumerate(variation_range):
    row = f"{change:>10.2%} " + " ".join(f"{results[col][i]:>20.2f}" for col in columns)
    rows.append(row)
# Combine header and rows
table = "\n".join([header] + rows)
# Print the table
print(table)

"""###**Plot Average Marginal Electricity Price For All Scenarios**"""

all_marg_sys_elec_price = [avg_marg_price_2025_All_Mix,
                    avg_marg_price_2025_RES,
                    avg_marg_price_2025_RES_LC,
                    avg_marg_price_2025_monte,
                    avg_marg_price_2025_monte_RES,
                    avg_marg_price_2025_monte_RES_LC]
scenarios = ['All Mix', 'All Mix-UQ', 'RES Only', 'RES Only-UQ', 'RES-LowCarbon',
             'RES-LowCarbon-UQ']
colors = ['sienna', 'darkorange', 'forestgreen', 'lavender', 'slateblue', 'purple']
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (12, 8)
fig, ax = plt.subplots(1, 1)
plt.subplots_adjust(wspace=0.1, hspace=0.1)
plt.autoscale(tight=True)
bar_width = 0.4
positions = [0.5, 1, 2.0, 2.5, 3.5, 4.0]
r1 = np.arange(len(all_marg_sys_elec_price))
ax.cla()
ax.set_facecolor("white")
ax.spines[['top', 'right']].set_visible(False)
ax.set_ylabel('Scenarios', size=15, fontweight='bold')
ax.set_xlabel('Average Marginal Price of Electricity [¬£/MWh]', size=15, fontweight='bold')
#bars = ax.barh(range(len(df_)), df_['Avg_Sys_Cost'], color=color, edgecolor='grey')
bars = ax.barh(positions, all_marg_sys_elec_price, height=bar_width,
               color=colors, edgecolor='k')
ax.set_yticks(positions)
ax.set_yticklabels(scenarios, rotation=0)
handles = [plt.Rectangle((0,0),1,1, color=color) for color in colors]
legend = ax.legend(handles, scenarios, loc='best', ncol=1, frameon=True, fontsize='10',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
ax.tick_params(axis='x', rotation=0, labelsize=12)
ax.tick_params(axis='y', rotation=0, labelsize=12)
#axs[1] = plt.gca()
for spine in ax.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax.xaxis.grid(False)
ax.yaxis.grid(False)
output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/Average_marginal_price_electricity_Scenarios.png')
plt.tight_layout()
plt.show()

"""###**Plot Average Total System Cost For All Scenarios**"""

dataAllmix = [tot_annual_sys_cost_2025_All_Mix]
allmix_tot_sys_cost = [0 if np.isnan(x) or x < 0 else x for x in dataAllmix]
dataRES = [tot_annual_sys_cost_2025_RES]
RES_tot_sys_cost = [0 if np.isnan(x) or x < 0 else x for x in dataRES]
dataRES_LC = [tot_annual_sys_cost_2025_RES_LC]
RES_LC_tot_sys_cost = [0 if np.isnan(x) or x < 0 else x for x in dataRES_LC]
dataMonte = [tot_sys_cost_monte[0], tot_sys_cost_monte[1], tot_sys_cost_monte[2],
             tot_sys_cost_monte[3], tot_sys_cost_monte[4], tot_sys_cost_monte[5],
             tot_sys_cost_monte[6], tot_sys_cost_monte[7], tot_sys_cost_monte[8],
             tot_sys_cost_monte[9]]
monte_tot_sys_cost = [0 if np.isnan(x) or x < 0 else x for x in dataMonte]
dataMonteRES = [tot_sys_cost_monte_RES[0], tot_sys_cost_monte_RES[1],
                tot_sys_cost_monte_RES[2], tot_sys_cost_monte_RES[3],
                tot_sys_cost_monte_RES[4], tot_sys_cost_monte_RES[5],
                tot_sys_cost_monte_RES[6], tot_sys_cost_monte_RES[7],
                tot_sys_cost_monte_RES[8], tot_sys_cost_monte_RES[9]]
MonteRES_tot_sys_cost = [0 if np.isnan(x) or x < 0 else x for x in dataMonteRES]

dataMonteRESLC = [tot_sys_cost_monte_RES_LC[0], tot_sys_cost_monte_RES_LC[1],
                tot_sys_cost_monte_RES_LC[2], tot_sys_cost_monte_RES_LC[3],
                tot_sys_cost_monte_RES_LC[4], tot_sys_cost_monte_RES_LC[5],
                tot_sys_cost_monte_RES_LC[6], tot_sys_cost_monte_RES_LC[7],
                tot_sys_cost_monte_RES_LC[8], tot_sys_cost_monte_RES_LC[9]]
MonteRESLC_tot_sys_cost = [0 if np.isnan(x) or x < 0 else x for x in dataMonteRESLC]
scenarios = [
    'All Mix', 'All Mix-UQ1', 'All Mix-UQ2', 'All Mix-UQ3', 'All Mix-UQ4',
    'All Mix-UQ5', 'All Mix-UQ6', 'All Mix-UQ7', 'All Mix-UQ8', 'All Mix-UQ9', 'All Mix-UQ10',
    'RES Only', 'RES-UQ1', 'RES-UQ2', 'RES-UQ3', 'RES-UQ4', 'RES-UQ5', 'RES-UQ6', 'RES-UQ7',
    'RES-UQ8', 'RES-UQ9', 'RES-UQ10', 'RES-LC', 'RES-LC-UQ1', 'RES-LC-UQ2', 'RES-LC-UQ3',
    'RES-LC-UQ4', 'RES-LC-UQ5', 'RES-LC-UQ6', 'RES-LC-UQ7', 'RES-LC-UQ8', 'RES-LC-UQ9', 'RES-LC-UQ10'
]
colors = [
    'cyan', 'peru', 'peru', 'peru', 'peru', 'peru', 'peru', 'peru', 'peru', 'peru', 'peru',
    'olive', 'crimson', 'crimson', 'crimson', 'crimson', 'crimson', 'crimson', 'crimson',
    'crimson', 'crimson', 'crimson', 'darkolivegreen', 'slategrey', 'slategrey', 'slategrey',
    'slategrey', 'slategrey', 'slategrey', 'slategrey', 'slategrey', 'slategrey', 'slategrey'
]
all_data = allmix_tot_sys_cost + monte_tot_sys_cost + RES_tot_sys_cost + \
MonteRES_tot_sys_cost + RES_LC_tot_sys_cost + MonteRESLC_tot_sys_cost
sns.set_theme(style='whitegrid')
plt.rcParams["figure.figsize"] = (12, 8)
fig, ax = plt.subplots(1, 1)
plt.subplots_adjust(wspace=0.1, hspace=0.1)
plt.autoscale(tight=True)
bar_width = 0.4
positions = np.arange(len(all_data))
ax.barh(positions, all_data, height=bar_width, color=colors, edgecolor='grey')
ax.set_yticks(positions)
ax.set_yticklabels(scenarios)
ax.set_ylabel('Scenarios', size=15, fontweight='bold')
ax.set_xlabel('Total Annual System Cost [Billion ¬£]', size=15, fontweight='bold')
ax.set_facecolor("white")
ax.spines[['top', 'right']].set_visible(False)
unique_labels = ['All Mix', 'Monte Carlo All Mix', 'RES Only', 'Monte Carlo RES',
                 'RES-LowCarbon', 'Monte Carlo RES-LowCarbon']
unique_colors = ['cyan', 'peru', 'olive', 'crimson', 'darkolivegreen', 'slategrey']
handles = [plt.Rectangle((0, 0), 1, 1, color=color) for color in unique_colors]
legend = ax.legend(handles, unique_labels, loc='best', ncol=2, frameon=True,
                   fontsize='10', fancybox=True, framealpha=1, shadow=False,
                   borderpad=1, labelspacing=0.2)
legend.get_frame().set_edgecolor('black')
legend.get_frame().set_linewidth(1)
ax.tick_params(axis='x', rotation=0, labelsize=12)
ax.tick_params(axis='y', rotation=0, labelsize=12)
for spine in ax.spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
ax.xaxis.grid(False)
ax.yaxis.grid(False)
plt.tight_layout()
plt.show()

"""###**Comparison of the Uncertainties of Renewable Generators, Storage Units, and Transmission Optimal Capacities With Respect to the Total System Cost for All Scenarios**

###**Sensitivity Analysis Uisng Tornado and Spider Plots in all Scenarios.**
"""

X_monte

base_prediction_monte = X_monte.mean()

base_prediction_monte

base_prediction_monte = reg.predict(X_monte)
base_prediction_monte

selected_categories = ['Battery Storage', 'Hydrogen Storage', 'Offshore Wind (AC)',
                       'Offshore Wind (DC)', 'Onshore Wind', 'Run of River',
                       'Solar', 'Transmission']
# Scenario 1
selected_df = concatenated_dfs_all_sys_cost_monte.loc[selected_categories]
df_monte = selected_df[['Optimal Capacity']].T
df_monte['Total System Cost'] = dfs_tot_sys_cost_monte
df_monte.index = pd.Index(range(1, len(df_monte) + 1))
df_monte = df_monte.fillna(0)
# Fit a linear regression model
X_monte = df_monte.drop(['Total System Cost'], axis=1)
y_monte = df_monte['Total System Cost']
reg = LinearRegression()
reg.fit(X_monte, y_monte)
# Base case prediction
#base_prediction_monte = reg.predict(X_monte).mean()
base_prediction_monte = X_monte.mean()
variation_range = 10 # 95 % CI  # percentage variation from the mean
# Calculate the impact of varying each input parameter
sensitivities = {}
low_impacts_monte = []
high_impacts_monte = []
features = X_monte.columns
for feature in features:
    mean_value = X_monte[feature].mean()
    variation = mean_value * variation_range / 100
    X_high = X_monte.copy()
    X_high[feature] = mean_value + variation
    high_prediction_monte = reg.predict(X_high).mean()
    X_low = X_monte.copy()
    X_low[feature] = mean_value - variation
    low_prediction_monte = reg.predict(X_low).mean()
    sensitivities[feature] = (high_prediction_monte - low_prediction_monte) / 2
    low_impacts_monte.append(low_prediction_monte)
    high_impacts_monte.append(high_prediction_monte)
features_monte = list(sensitivities.keys())
impacts_monte = [sensitivities[feature] for feature in features]

results_monte = {}
variation_range = np.linspace(-0.10, 0.10, 10)
# Calculate the impact of varying each input parameter
base_prediction_monte2 = reg.predict(X_monte.mean().values.reshape(1, -1))[0]
for feature in X_monte.columns:
    feature_mean = X_monte[feature].mean()
    feature_values = feature_mean * (1 + variation_range)
    other_features = X_monte.drop(columns=[feature]).mean().values.reshape(1, -1)
    output_changes = []
    for value in feature_values:
        X_temp = other_features.copy()
        X_temp = np.insert(X_temp, list(X_monte.columns).index(feature), value, axis=1)
        output_changes.append(reg.predict(X_temp)[0] - base_prediction_monte2)
    results_monte[feature] = output_changes

# Scenario 2
selected_df = concatenated_dfs_all_sys_cost_RES.loc[selected_categories]
df_RES = selected_df[['Optimal Capacity']].T
df_RES['Total System Cost'] = dfs_tot_sys_cost_RES
df_RES.index = pd.Index(range(1, len(df_RES) + 1))
df_RES = df_RES.fillna(0)
# Fit a linear regression model
X_RES = df_RES.drop(['Total System Cost'], axis=1)
y_RES = df_RES['Total System Cost']
reg = LinearRegression()
reg.fit(X_RES, y_RES)
# Base case prediction
#base_prediction_RES = reg.predict(X_RES).mean()
base_prediction_RES = X_RES.mean()
variation_range = 10 # 95 % CI  # percentage variation from the mean
# Calculate the impact of varying each input parameter
sensitivities = {}
low_impacts_RES = []
high_impacts_RES = []
features = X_RES.columns
for feature in features:
    mean_value = X_RES[feature].mean()
    variation = mean_value * variation_range / 100
    X_high = X_RES.copy()
    X_high[feature] = mean_value + variation
    high_prediction_RES = reg.predict(X_high).mean()
    X_low = X_RES.copy()
    X_low[feature] = mean_value - variation
    low_prediction_RES = reg.predict(X_low).mean()
    sensitivities[feature] = (high_prediction_RES - low_prediction_RES) / 2
    low_impacts_RES.append(low_prediction_RES)
    high_impacts_RES.append(high_prediction_RES)
features_RES = list(sensitivities.keys())
impacts_RES = [sensitivities[feature] for feature in features]

results_RES = {}
variation_range = np.linspace(-0.10, 0.10, 10)
# Calculate the impact of varying each input parameter
base_prediction_RES2 = reg.predict(X_RES.mean().values.reshape(1, -1))[0]
for feature in X_RES.columns:
    feature_mean = X_RES[feature].mean()
    feature_values = feature_mean * (1 + variation_range)
    other_features = X_RES.drop(columns=[feature]).mean().values.reshape(1, -1)
    output_changes = []
    for value in feature_values:
        X_temp = other_features.copy()
        X_temp = np.insert(X_temp, list(X_RES.columns).index(feature), value, axis=1)
        output_changes.append(reg.predict(X_temp)[0] - base_prediction_RES2)
    results_RES[feature] = output_changes

# Scenario 3
selected_df = concatenated_dfs_all_sys_cost_RES_LC.loc[selected_categories]
df_RES_LC = selected_df[['Optimal Capacity']].T
df_RES_LC['Total System Cost'] = dfs_tot_sys_cost_RES_LC
df_RES_LC.index = pd.Index(range(1, len(df_RES_LC) + 1))
df_RES_LC = df_RES_LC.fillna(0)
# Fit a linear regression model
X_RES_LC = df_RES_LC.drop(['Total System Cost'], axis=1)
y_RES_LC = df_RES_LC['Total System Cost']
reg = LinearRegression()
reg.fit(X_RES_LC, y_RES_LC)
# Base case prediction
#base_prediction_RES_LC = reg.predict(X_RES_LC).mean()
base_prediction_RES_LC = X_RES_LC.mean()
variation_range = 10 # 95 % CI  # percentage variation from the mean
# Calculate the impact of varying each input parameter
sensitivities = {}
low_impacts_RES_LC = []
high_impacts_RES_LC = []
features = X_RES_LC.columns
for feature in features:
    mean_value = X_RES_LC[feature].mean()
    variation = mean_value * variation_range / 100
    X_high = X_RES_LC.copy()
    X_high[feature] = mean_value + variation
    high_prediction_RES_LC = reg.predict(X_high).mean()
    X_low = X_RES_LC.copy()
    X_low[feature] = mean_value - variation
    low_prediction_RES_LC = reg.predict(X_low).mean()
    sensitivities[feature] = (high_prediction_RES_LC - low_prediction_RES_LC) / 2
    low_impacts_RES_LC.append(low_prediction_RES_LC)
    high_impacts_RES_LC.append(high_prediction_RES_LC)
features_RES_LC = list(sensitivities.keys())
impacts_RES_LC = [sensitivities[feature] for feature in features]

results_RES_LC = {}
variation_range = np.linspace(-0.1, 0.1, 10)
# Calculate the impact of varying each input parameter
base_prediction_RES_LC2 = reg.predict(X_RES_LC.mean().values.reshape(1, -1))[0]
for feature in X_RES_LC.columns:
    feature_mean = X_RES_LC[feature].mean()
    feature_values = feature_mean * (1 + variation_range)
    other_features = X_RES_LC.drop(columns=[feature]).mean().values.reshape(1, -1)
    output_changes = []
    for value in feature_values:
        X_temp = other_features.copy()
        X_temp = np.insert(X_temp, list(X_RES_LC.columns).index(feature), value, axis=1)
        output_changes.append(reg.predict(X_temp)[0] - base_prediction_RES_LC2)
    results_RES_LC[feature] = output_changes

# Plot the tornado diagrams
sns.set_theme(style='whitegrid')
fig, axs = plt.subplots(2, 3, figsize=(16, 16), sharey='row')
plt.autoscale(tight=True)
axs[0, 0].cla()
axs[0, 0].set_facecolor("white")
axs[0, 0].spines[['top', 'right']].set_visible(False)
#bars = axs[0, 0].barh(features_monte, impacts_monte, color='gold', edgecolor='black')
axs[0, 0].axvline(base_prediction_monte, color='k', linestyle='-', label='Base',
               linewidth=2.5)
# Plot the low impacts
axs[0, 0].barh(features_monte, base_prediction_monte - np.array(low_impacts_monte),
               left=low_impacts_monte, color='orange', edgecolor='black', label='Low')
# Plot the high impacts
axs[0, 0].barh(features_monte, high_impacts_monte - base_prediction_monte,
               left=base_prediction_monte, color='teal', edgecolor='black', label='High')
axs[0, 0].set_xlabel('Total System Cost [¬£ Per Annum]', size=12, fontweight='bold')
axs[0, 0].set_ylabel('Technologies', size=15, fontweight='bold')
# Calculate total width for normalization
'''total_width = sum(abs(bar.get_width()) for bar in bars)
# Add data labels for the sensitivity plot with percentages
for bar in bars:
    width = bar.get_width()
    percentage = (abs(width) / total_width) * 100
    axs[0, 0].annotate(f'{percentage:.1f}%',
                    xy=(width, bar.get_y() + bar.get_height() / 2),
                    xytext=(9, 0),  # 5 points horizontal offset
                    textcoords="offset points",
                    ha='right', va='center', rotation=90,
                    fontsize=8,  # Adjust font size if needed
                    color='black',  # Text color
                    bbox=dict(boxstyle='round,pad=0.3', fc='white', ec='black', lw=1))'''
axs[0, 0].tick_params(axis='x', rotation=30, labelsize=12)
plt.figtext(0.15, 0.50, '(a) Scenario 1 : Tornado Diagram', fontsize=15,
            rotation=0, weight="bold")
for spine in axs[0, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0, 0].xaxis.grid(True)
axs[0, 0].yaxis.grid(True)

axs[0, 1].cla()
axs[0, 1].set_facecolor("white")
axs[0, 1].spines[['top', 'right']].set_visible(False)
#bars = axs[0, 1].barh(features_RES, impacts_RES, color='gold', edgecolor='black')
axs[0, 1].axvline(base_prediction_RES, color='k', linestyle='-', label='Base',
               linewidth=2.5)
# Plot the low impacts
axs[0, 1].barh(features_RES, base_prediction_RES - np.array(low_impacts_RES),
               left=low_impacts_RES, color='orange', edgecolor='black', label='Low')
# Plot the high impacts
axs[0, 1].barh(features_RES, high_impacts_RES - base_prediction_RES,
               left=base_prediction_RES, color='teal', edgecolor='black', label='High')
axs[0, 1].set_xlabel('Total System Cost [¬£ Per Annum]', size=12, fontweight='bold')
#axs[0, 1].set_ylabel('Technologies', size=15, fontweight='bold')
# Calculate total width for normalization
'''total_width = sum(abs(bar.get_width()) for bar in bars)
# Add data labels for the sensitivity plot with percentages
for bar in bars:
    width = bar.get_width()
    percentage = (abs(width) / total_width) * 100
    axs[0, 1].annotate(f'{percentage:.1f}%',
                    xy=(width, bar.get_y() + bar.get_height() / 2),
                    xytext=(9, 0),  # 5 points horizontal offset
                    textcoords="offset points",
                    ha='right', va='center', rotation=90,
                    fontsize=8,  # Adjust font size if needed
                    color='black',  # Text color
                    bbox=dict(boxstyle='round,pad=0.3', fc='white', ec='black', lw=1))'''
axs[0, 1].tick_params(axis='x', rotation=30, labelsize=12)
plt.figtext(0.44, 0.50, '(b) Scenario 2 : Tornado Diagram', fontsize=15,
            rotation=0, weight="bold")
for spine in axs[0, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0, 1].xaxis.grid(True)
axs[0, 1].yaxis.grid(True)

axs[0, 2].cla()
axs[0, 2].set_facecolor("white")
axs[0, 2].spines[['top', 'right']].set_visible(False)
#bars = axs[0, 2].barh(features_RES_LC, impacts_RES_LC, color='gold', edgecolor='black')
axs[0, 2].axvline(base_prediction_RES_LC, color='k', linestyle='-', label='Base',
               linewidth=2.5)
# Plot the low impacts
axs[0, 2].barh(features_RES_LC, base_prediction_RES_LC - np.array(low_impacts_RES_LC),
               left=low_impacts_RES_LC, color='orange', edgecolor='black', label='Low')
# Plot the high impacts
axs[0, 2].barh(features_RES_LC, high_impacts_RES_LC - base_prediction_RES_LC,
               left=base_prediction_RES_LC, color='teal', edgecolor='black', label='High')
axs[0, 2].set_xlabel('Total System Cost [¬£ Per Annum]', size=12, fontweight='bold')
#axs[0, 2].set_ylabel('Technologies', size=15, fontweight='bold')
# Calculate total width for normalization
'''total_width = sum(abs(bar.get_width()) for bar in bars)
# Add data labels for the sensitivity plot with percentages
for bar in bars:
    width = bar.get_width()
    percentage = (abs(width) / total_width) * 100
    axs[0, 2].annotate(f'{percentage:.1f}%',
                    xy=(width, bar.get_y() + bar.get_height() / 2),
                    xytext=(9, 0),  # 5 points horizontal offset
                    textcoords="offset points",
                    ha='right', va='center', rotation=90,
                    fontsize=8,  # Adjust font size if needed
                    color='black',  # Text color
                    bbox=dict(boxstyle='round,pad=0.3', fc='white', ec='black', lw=1))'''
#axs[0, 2].xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{x/1e9:.0f}B'))
axs[0, 2].tick_params(axis='x', rotation=30, labelsize=12)
plt.figtext(0.72, 0.50, '(c) Scenario 3 : Tornado Diagram', fontsize=15,
            rotation=0, weight="bold")
for spine in axs[0, 2].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[0, 2].xaxis.grid(True)
axs[0, 2].yaxis.grid(True)

# Plot the results
markers = ['o', 's', 'D', '^', 'v', '*', 'p', 'h', 'H', 'X', 'd', '|', '_']
colors = cm.get_cmap('tab10', X.shape[0]).colors  # Use a colormap to generate colors
axs[1, 0].cla()
axs[1, 0].set_facecolor("white")
axs[1, 0].spines[['top', 'right']].set_visible(False)
for i, (feature, output_changes) in enumerate(results_monte.items()):
    axs[1, 0].plot(variation_range * 100, output_changes, label=feature,
            marker=markers[i % len(markers)], color=colors[i % len(colors)])
axs[1, 0].set_xlabel('Variation in Input Parameter (%)', size=12, fontweight='bold')
axs[1, 0].set_ylabel('Change in Output [¬£]', size=12, fontweight='bold')
#axs[1, 0].set_xticks(np.arange(-95, 100, 10))  # Set x-ticks from -95% to 95% in steps of 10%
#axs[1, 0].set_xticklabels([f'{int(x)}' for x in np.arange(-95, 100, 10)])  # Convert x-ticks to percentage format
axs[1, 0].tick_params(axis='y', rotation=0, labelsize=10)
axs[1, 0].tick_params(axis='x', rotation=30, labelsize=10)
plt.figtext(0.14, -0.02, '(d) Scenario 1 : Spider Plot', fontsize=15,
            rotation=0, weight="bold")
for spine in axs[1, 0].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1, 0].xaxis.grid(True)
axs[1, 0].yaxis.grid(True)
legend1 = axs[1, 0].legend(loc='best', ncol=1, frameon=True, fontsize='9',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend1.get_frame().set_edgecolor('black')
legend1.get_frame().set_linewidth(1)

# Plot the results
markers = ['o', 's', 'D', '^', 'v', '*', 'p', 'h', 'H', 'X', 'd', '|', '_']
colors = cm.get_cmap('tab10', X.shape[0]).colors  # Use a colormap to generate colors
axs[1, 1].cla()
axs[1, 1].set_facecolor("white")
axs[1, 1].spines[['top', 'right']].set_visible(False)
for i, (feature, output_changes) in enumerate(results_RES.items()):
    axs[1, 1].plot(variation_range * 100, output_changes, label=feature,
            marker=markers[i % len(markers)], color=colors[i % len(colors)])
axs[1, 1].set_xlabel('Variation in Input Parameter (%)', size=12, fontweight='bold')
axs[1, 1].set_ylabel('Change in Output [¬£]', size=12, fontweight='bold')
#axs[1, 1].set_xticks(np.arange(-95, 100, 10))  # Set x-ticks from -95% to 95% in steps of 10%
#axs[1, 1].set_xticklabels([f'{int(x)}' for x in np.arange(-95, 100, 10)])  # Convert x-ticks to percentage format
axs[1, 1].tick_params(axis='y', rotation=0, labelsize=10)
axs[1, 1].tick_params(axis='x', rotation=30, labelsize=10)
plt.figtext(0.45, -0.02, '(e) Scenario 2 : Spider Plot', fontsize=15,
            rotation=0, weight="bold")
for spine in axs[1, 1].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1, 1].xaxis.grid(True)
axs[1, 1].yaxis.grid(True)
legend2 = axs[1, 1].legend(loc='best', ncol=1, frameon=True, fontsize='9',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend2.get_frame().set_edgecolor('black')
legend2.get_frame().set_linewidth(1)

# Plot the results
markers = ['o', 's', 'D', '^', 'v', '*', 'p', 'h', 'H', 'X', 'd', '|', '_']
colors = cm.get_cmap('tab10', X.shape[0]).colors  # Use a colormap to generate colors
axs[1, 2].cla()
axs[1, 2].set_facecolor("white")
axs[1, 2].spines[['top', 'right']].set_visible(False)
for i, (feature, output_changes) in enumerate(results_RES_LC.items()):
    axs[1, 2].plot(variation_range * 100, output_changes, label=feature,
            marker=markers[i % len(markers)], color=colors[i % len(colors)])
axs[1, 2].set_xlabel('Variation in Input Parameter (%)', size=12, fontweight='bold')
axs[1, 2].set_ylabel('Change in Output [¬£]', size=12, fontweight='bold')
#axs[1, 2].set_xticks(np.arange(-95, 100, 10))  # Set x-ticks from -95% to 95% in steps of 10%
#axs[1, 2].set_xticklabels([f'{int(x)}' for x in np.arange(-95, 100, 10)])  # Convert x-ticks to percentage format
axs[1, 2].tick_params(axis='y', rotation=0, labelsize=10)
axs[1, 2].tick_params(axis='x', rotation=30, labelsize=10)
plt.figtext(0.74, -0.02, '(f) Scenario 3 : Spider Plot', fontsize=15,
            rotation=0, weight="bold")
for spine in axs[1, 2].spines.values():
    spine.set_linewidth(2)
    spine.set_edgecolor('black')
axs[1, 2].xaxis.grid(True)
axs[1, 2].yaxis.grid(True)
legend3 = axs[1, 2].legend(loc='best', ncol=1, frameon=True, fontsize='9',
                   fancybox=True, framealpha=1, shadow=False, borderpad=1, labelspacing=0.2)
legend3.get_frame().set_edgecolor('black')
legend3.get_frame().set_linewidth(1)

output_dir = '/content/gdrive/MyDrive/Energy_System_RL_Modelling_Plots'
plt.savefig(f'{output_dir}/tornado_SPIDER_plots_scenario_all.png')
plt.tight_layout()
plt.subplots_adjust(wspace=0.2, hspace=0.4)
plt.show()

"""###**Comparison to the literature**

"""

df = stat_All_Mix.droplevel(level=0)
rows_to_sum = ['Biomass', 'Coal', 'Combined-Cycle Gas', 'Nuclear',
               'Offshore Wind (AC)', 'Offshore Wind (DC)', 'Oil', 'Onshore Wind',
               'Run of River', 'Solar']
sum_row = df.loc[rows_to_sum].sum()
df.loc['Gen'] = sum_row
df = df.fillna(0)
opt_cap_gen_cap = df[['Optimal Capacity']].loc['Gen'].to_list()
inst_cap_gen_cap = df[['Installed Capacity']].loc['Gen'].to_list()
new_exp_gen_cap = [a - b for a, b in zip(opt_cap_gen_cap, inst_cap_gen_cap)]
opt_gen_sup = df[['Supply']].loc['Gen'].to_list()

df = stat_All_Mix.droplevel(level=1)
df_ = (df.groupby(level=0).sum()).fillna(0)
opt_sto = df_[['Optimal Capacity']].loc['StorageUnit'].to_list()
inst_sto = df_[['Installed Capacity']].loc['StorageUnit'].to_list()
new_exp_sto = [a - b for a, b in zip(opt_sto, inst_sto)]

print('================================================================================')
print(f'New Generator Installed Capacity With UQ in MW: {new_exp_gen_cap}')
print('================================================================================')

# New Generation Supply
print('================================================================================')
print(f'New Generation Supply With UQ in MW: {opt_gen_sup}')
print('================================================================================')

# New Storage Capacity
print('================================================================================')
print(f'New Storage Capacity With UQ in MW: {new_exp_sto}')
print('================================================================================')

df = stat_RES.droplevel(level=0)
rows_to_sum = ['Offshore Wind (AC)', 'Offshore Wind (DC)', 'Onshore Wind',
               'Run of River', 'Solar']
sum_row = df.loc[rows_to_sum].sum()
df.loc['Gen'] = sum_row
df = df.fillna(0)
opt_cap_gen_cap = df[['Optimal Capacity']].loc['Gen'].to_list()
inst_cap_gen_cap = df[['Installed Capacity']].loc['Gen'].to_list()
new_exp_gen_cap = [a - b for a, b in zip(opt_cap_gen_cap, inst_cap_gen_cap)]
opt_gen_sup = df[['Supply']].loc['Gen'].to_list()

df = stat_RES.droplevel(level=1)
df_ = (df.groupby(level=0).sum()).fillna(0)
opt_sto = df_[['Optimal Capacity']].loc['StorageUnit'].to_list()
inst_sto = df_[['Installed Capacity']].loc['StorageUnit'].to_list()
new_exp_sto = [a - b for a, b in zip(opt_sto, inst_sto)]

print('================================================================================')
print(f'New Generator Installed Capacity With UQ in MW: {new_exp_gen_cap}')
print('================================================================================')

# New Generation Supply
print('================================================================================')
print(f'New Generation Supply With UQ in MW: {opt_gen_sup}')
print('================================================================================')

# New Storage Capacity
print('================================================================================')
print(f'New Storage Capacity With UQ in MW: {new_exp_sto}')
print('================================================================================')

df = stat_RES_LC.droplevel(level=0)
rows_to_sum = ['Offshore Wind (AC)', 'Offshore Wind (DC)', 'Onshore Wind',
               'Run of River', 'Solar']
sum_row = df.loc[rows_to_sum].sum()
df.loc['Gen'] = sum_row
df = df.fillna(0)
opt_cap_gen_cap = df[['Optimal Capacity']].loc['Gen'].to_list()
inst_cap_gen_cap = df[['Installed Capacity']].loc['Gen'].to_list()
new_exp_gen_cap = [a - b for a, b in zip(opt_cap_gen_cap, inst_cap_gen_cap)]
opt_gen_sup = df[['Supply']].loc['Gen'].to_list()

df = stat_RES_LC.droplevel(level=1)
df_ = (df.groupby(level=0).sum()).fillna(0)
opt_sto = df_[['Optimal Capacity']].loc['StorageUnit'].to_list()
inst_sto = df_[['Installed Capacity']].loc['StorageUnit'].to_list()
new_exp_sto = [a - b for a, b in zip(opt_sto, inst_sto)]

print('================================================================================')
print(f'New Generator Installed Capacity With UQ in MW: {new_exp_gen_cap}')
print('================================================================================')

# New Generation Supply
print('================================================================================')
print(f'New Generation Supply With UQ in MW: {opt_gen_sup}')
print('================================================================================')

# New Storage Capacity
print('================================================================================')
print(f'New Storage Capacity With UQ in MW: {new_exp_sto}')
print('================================================================================')